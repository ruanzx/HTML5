/*
 *
 * SpreadJS Library 8.40.20151.0
 *
 * Copyright(c) GrapeCity, Inc.  All rights reserved.
 *
 * Licensed under the SpreadJS Commercial License. 
 * spread.sales@grapecity.com
 * http://spread.grapecity.com/Pages/Spread-JS-License/
 *
 *
 **/
var __extends = this.__extends || function(d, b)
    {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __()
        {
            this.constructor = d
        }
        __.prototype = b.prototype;
        d.prototype = new __
    };
var GcSpread;
(function(GcSpread)
{
    (function(Sheets)
    {
        (function(Calc)
        {
            Sheets.feature("calc.common", ["core.migrate", "core.stringResource", "core.common", "core.globalize"]);
            var const_undefined = "undefined",
                const_number = "number",
                const_string = "string",
                const_boolean = "boolean",
                const_true = "TRUE",
                const_false = "FALSE",
                const_array = "ARRAY",
                const_arrayRow = "ARRAYROW",
                const_null = "#NULL!",
                const_div0 = "#DIV/0!",
                const_value = "#VALUE!",
                const_ref = "#REF!",
                const_name = "#NAME?",
                const_na = "#N/A",
                const_num = "#NUM!",
                const_expr = "expr",
                const_arrayInfo = "arrayInfo",
                const_workingExpr = "workingExpr",
                ErrorList = [const_null, const_div0, const_value, const_ref, const_name, const_na, const_num],
                ErrorCodeList = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24],
                LetterPows = [1, 26, 676],
                keyword_null = null,
                keyword_undefined = undefined,
                supportRowColumnFormula = false,
                Math_min = Math.min,
                Math_max = Math.max,
                Math_abs = Math.abs,
                Math_pow = Math.pow;
            Calc.missingArgument = {};
            (function(CalcValueType)
            {
                CalcValueType[CalcValueType["anyType"] = 0] = "anyType";
                CalcValueType[CalcValueType["numberType"] = 1] = "numberType";
                CalcValueType[CalcValueType["stringType"] = 2] = "stringType";
                CalcValueType[CalcValueType["booleanType"] = 3] = "booleanType";
                CalcValueType[CalcValueType["dateType"] = 4] = "dateType"
            })(Calc.CalcValueType || (Calc.CalcValueType = {}));
            var CalcValueType = Calc.CalcValueType;
            var CalcValueTypeStrings = ["o", "n", "s", "b", "d"];
            var DefaultValues = [keyword_null, 0, "", false, new Date];
            (function(NodeType)
            {
                NodeType[NodeType["Cell"] = 0] = "Cell";
                NodeType[NodeType["Row"] = 1] = "Row";
                NodeType[NodeType["Col"] = 2] = "Col"
            })(Calc.NodeType || (Calc.NodeType = {}));
            var NodeType = Calc.NodeType;
            var CalcOperatorAdjustor = (function()
                {
                    function CalcOperatorAdjustor()
                    {
                        this._headNames = ["_head", "_headRows", "_headCols"];
                        this._tailNames = ["_tail", "_tailRows", "_tailCols"]
                    }
                    CalcOperatorAdjustor.prototype.isAdjustCell = function(cell)
                    {
                        return cell.preAdj || cell === this._head
                    };
                    CalcOperatorAdjustor.prototype.isAdjust = function(cell)
                    {
                        return cell.preAdj || cell === this._head
                    };
                    CalcOperatorAdjustor.prototype.addAdjust = function(node, type)
                    {
                        var self = this,
                            head = self._headNames[type],
                            tail = self._tailNames[type];
                        if (node && !node.preAdj && node !== self[head])
                        {
                            if (self[head])
                            {
                                self[tail].nextAdj = node
                            }
                            else
                            {
                                self[head] = node
                            }
                            node.preAdj = self[tail];
                            node.nextAdj = keyword_null;
                            self[tail] = node
                        }
                    };
                    CalcOperatorAdjustor.prototype.removeAdjust = function(node, type)
                    {
                        var self = this,
                            head = self._headNames[type],
                            tail = self._tailNames[type];
                        if (node && (node.preAdj || node === self[head]))
                        {
                            var prevAdjust = node.preAdj;
                            var nextAdj = node.nextAdj;
                            if (prevAdjust)
                            {
                                prevAdjust.nextAdj = nextAdj
                            }
                            else
                            {
                                self[head] = nextAdj
                            }
                            if (nextAdj)
                            {
                                nextAdj.preAdj = prevAdjust
                            }
                            else
                            {
                                self[tail] = prevAdjust
                            }
                            node.preAdj = keyword_null;
                            node.nextAdj = keyword_null
                        }
                    };
                    CalcOperatorAdjustor.prototype._adjustIndexesOnAdd = function(baseModel, refModel, baseIndex, index, relative, endIndex, endRelative, addModel, addIndex, addCount)
                    {
                        if (baseIndex >= 0 || !relative)
                        {
                            var refIndex = index + (relative ? baseIndex : 0);
                            var refEndIndex = endIndex + (endRelative ? baseIndex : 0);
                            if (addModel === baseModel)
                            {
                                if (addIndex + addCount <= baseIndex)
                                {
                                    refIndex -= (relative ? addCount : 0);
                                    refEndIndex -= (endRelative ? addCount : 0)
                                }
                            }
                            if (addModel === refModel)
                            {
                                if (addIndex <= refIndex)
                                {
                                    refIndex += addCount;
                                    refEndIndex += addCount
                                }
                                else if (addIndex <= refEndIndex)
                                {
                                    refEndIndex += addCount
                                }
                            }
                            refIndex -= (relative ? baseIndex : 0);
                            refEndIndex -= (endRelative ? baseIndex : 0);
                            return {
                                    index: refIndex, endIndex: refEndIndex
                                }
                        }
                        return {
                                index: index, endIndex: endIndex
                            }
                    };
                    CalcOperatorAdjustor.prototype._adjustCellExpressionOnAddRemove = function(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opIndex, opCount, isRow, isAdd)
                    {
                        if (refModel)
                        {
                            var index = isRow ? refExpr.row : refExpr.column,
                                isRelative = isRow ? refExpr.rowRelative : refExpr.columnRelative,
                                newIndex;
                            if (isRow && baseRow >= 0 || !isRow && baseColumn >= 0 || !isRelative)
                            {
                                if (isAdd)
                                {
                                    newIndex = this._adjustIndexesOnAdd(baseModel, refModel, isRow ? baseRow : baseColumn, index, isRelative, -1, false, opModel, opIndex, opCount).index
                                }
                                else
                                {
                                    newIndex = this._adjustCellOnRemove(baseModel, refModel, isRow ? baseRow : baseColumn, index, isRelative, opModel, opIndex, opCount);
                                    if (Convert.err(newIndex))
                                    {
                                        return new Expressions.ErrorExpression(newIndex)
                                    }
                                }
                                if (newIndex !== index)
                                {
                                    refExpr = refExpr.offset(isRow ? newIndex - index : 0, isRow ? 0 : newIndex - index, true)
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype._adjustRangeExpressionOnAddRemove = function(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opIndex, opCount, isRow, isAdd)
                    {
                        if (refModel)
                        {
                            var rangeType = refExpr._getRangeType();
                            if (rangeType === RangeType.sheet || isRow && rangeType === RangeType.column || !isRow && rangeType === RangeType.row)
                            {
                                return refExpr
                            }
                            var isStartRelative = isRow ? refExpr.startRowRelative : refExpr.startColumnRelative,
                                isEndRelative = isRow ? refExpr.endRowRelative : refExpr.endColumnRelative,
                                startIndex = isRow ? refExpr.startRow : refExpr.startColumn,
                                endIndex = isRow ? refExpr.endRow : refExpr.endColumn,
                                result;
                            if (isRow && baseRow >= 0 || !isRow && baseColumn >= 0 || !isStartRelative || !isEndRelative)
                            {
                                if (isAdd)
                                {
                                    result = this._adjustIndexesOnAdd(baseModel, refModel, isRow ? baseRow : baseColumn, startIndex, isStartRelative, endIndex, isEndRelative, opModel, opIndex, opCount)
                                }
                                else
                                {
                                    result = this._adjustRangeOnRemove(baseModel, refModel, isRow ? baseRow : baseColumn, startIndex, isStartRelative, endIndex, isEndRelative, opModel, opIndex, opCount);
                                    if (Convert.err(result))
                                    {
                                        return new Expressions.ErrorExpression(result)
                                    }
                                }
                                var newStartIndex = result.index;
                                var newEndIndex = result.endIndex;
                                if (newStartIndex !== startIndex || newEndIndex !== endIndex)
                                {
                                    refExpr = refExpr.offset2(isRow ? newStartIndex - startIndex : 0, isRow ? 0 : newStartIndex - startIndex, isRow ? newEndIndex - endIndex : 0, isRow ? 0 : newEndIndex - endIndex)
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype._adjustStructReferenceExpressionOnAddRemoveColumn = function(baseModel, refModel, baseRow, baseColumn, refExpr, opModel, opColumn, opColumnCount, isAdd)
                    {
                        if (refModel)
                        {
                            var table = refExpr;
                            if (table && refModel === table.source())
                            {
                                return table.offsetWhenInsertRemoveColumn(opColumn, opColumnCount, isAdd)
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulaOnAddRemove = function(baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd)
                    {
                        var self = this,
                            selfFunction = self.adjustFormulaOnAddRemove;
                        var newExpr = oldExpr,
                            arg;
                        if (oldExpr.t === 0)
                        {
                            newExpr = self._adjustCellExpressionOnAddRemove(baseModel, baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd)
                        }
                        else if (oldExpr.t === 2)
                        {
                            newExpr = self._adjustRangeExpressionOnAddRemove(baseModel, baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd)
                        }
                        else if (oldExpr.t === 1)
                        {
                            newExpr = self._adjustCellExpressionOnAddRemove(baseModel, oldExpr.source, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd)
                        }
                        else if (oldExpr.t === 3)
                        {
                            newExpr = self._adjustRangeExpressionOnAddRemove(baseModel, oldExpr.source, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isRow, isAdd)
                        }
                        else if (oldExpr.t === 14)
                        {
                            arg = selfFunction.call(self, baseModel, baseRow, baseColumn, oldExpr.argument, opModel, opIndex, opCount, isRow, isAdd);
                            if (arg !== oldExpr.argument)
                            {
                                newExpr = new Expressions.ParenthesesExpression(arg)
                            }
                        }
                        else if (oldExpr.t === 11)
                        {
                            arg = selfFunction.call(self, baseModel, baseRow, baseColumn, oldExpr.operand, opModel, opIndex, opCount, isRow, isAdd);
                            if (arg !== oldExpr.operand)
                            {
                                newExpr = new Expressions.UnaryOperatorExpression(oldExpr.operator, arg)
                            }
                        }
                        else if (oldExpr.t === 10)
                        {
                            var arg0 = selfFunction.call(self, baseModel, baseRow, baseColumn, oldExpr.left, opModel, opIndex, opCount, isRow, isAdd);
                            var arg1 = selfFunction.call(self, baseModel, baseRow, baseColumn, oldExpr.right, opModel, opIndex, opCount, isRow, isAdd);
                            if (arg0 !== oldExpr.left || arg1 !== oldExpr.right)
                            {
                                newExpr = new Expressions.BinaryOperatorExpression(oldExpr.operator, arg0, arg1)
                            }
                        }
                        else if (oldExpr.t === 7)
                        {
                            var args = keyword_null,
                                fnArg,
                                i,
                                funcExpr = oldExpr;
                            var argCount = funcExpr.argCount();
                            for (i = 0; i < argCount; i++)
                            {
                                fnArg = funcExpr.getArg(i);
                                arg = selfFunction.call(self, baseModel, baseRow, baseColumn, fnArg, opModel, opIndex, opCount, isRow, isAdd);
                                if (arg !== fnArg)
                                {
                                    args = [];
                                    args[i] = arg;
                                    break
                                }
                            }
                            if (args)
                            {
                                for (i = 0; i < argCount; i++)
                                {
                                    fnArg = funcExpr.getArg(i);
                                    if (args[i] === keyword_undefined || args[i] === keyword_null)
                                    {
                                        args[i] = selfFunction.call(self, baseModel, baseRow, baseColumn, fnArg, opModel, opIndex, opCount, isRow, isAdd)
                                    }
                                }
                                newExpr = new Expressions.FunctionExpression(funcExpr.fn, args)
                            }
                        }
                        else if (!isRow && oldExpr.t === 17)
                        {
                            newExpr = self._adjustStructReferenceExpressionOnAddRemoveColumn(baseModel, baseModel, baseRow, baseColumn, oldExpr, opModel, opIndex, opCount, isAdd)
                        }
                        return newExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulasOnAddRemove = function(addModel, index, count, isRow, isAdd)
                    {
                        this.adjustFormulasOnOperator(addModel, this.adjustFormulaOnAddRemove, index, count, isRow, isAdd);
                        var row1 = 0,
                            col1 = 0,
                            row2 = 0,
                            col2 = 0;
                        if (index === 0)
                        {
                            if (isRow && isAdd)
                            {
                                row2 = count
                            }
                            else if (isRow && !isAdd)
                            {
                                row1 = count
                            }
                            else if (!isRow && isAdd)
                            {
                                col2 = count
                            }
                            else
                            {
                                col1 = count
                            }
                        }
                        this.adjustValidatorFormulasOnOperator(addModel, this.adjustFormulaOnAddRemove, index, count, row1, col1, row2, col2, isRow, isAdd)
                    };
                    CalcOperatorAdjustor.prototype._adjustCellOnRemove = function(baseModel, refModel, baseIndex, index, relative, removeModel, removeIndex, removeCount)
                    {
                        if (baseIndex >= 0 || !relative)
                        {
                            var refIndex = index + (relative ? baseIndex : 0);
                            if (removeModel === baseModel)
                            {
                                if (removeIndex <= baseIndex)
                                {
                                    refIndex += (relative ? removeCount : 0)
                                }
                            }
                            if (removeModel === refModel)
                            {
                                if (removeIndex + removeCount <= refIndex)
                                {
                                    refIndex -= removeCount
                                }
                                else if (removeIndex <= refIndex)
                                {
                                    return CalcErrorsReference
                                }
                            }
                            refIndex -= (relative ? baseIndex : 0);
                            return refIndex
                        }
                        return index
                    };
                    CalcOperatorAdjustor.prototype._adjustRangeOnRemove = function(baseModel, refModel, baseIndex, index, relative, endIndex, endRelative, removeModel, removeIndex, removeCount)
                    {
                        if (baseIndex >= 0 || !relative)
                        {
                            var refIndex = index + (relative ? baseIndex : 0);
                            var refEndIndex = endIndex + (endRelative ? baseIndex : 0);
                            var removeEndIndex = removeIndex + removeCount - 1;
                            if (removeModel === baseModel)
                            {
                                if (removeIndex <= baseIndex)
                                {
                                    refIndex += (relative ? removeCount : 0);
                                    refEndIndex += (endRelative ? removeCount : 0)
                                }
                            }
                            if (removeModel === refModel)
                            {
                                if (removeEndIndex < refIndex)
                                {
                                    refIndex -= removeCount;
                                    refEndIndex -= removeCount
                                }
                                else if (removeIndex <= refIndex && removeEndIndex >= refEndIndex)
                                {
                                    return CalcErrorsReference
                                }
                                else if (removeIndex > refEndIndex)
                                {}
                                else if (removeEndIndex <= refEndIndex)
                                {
                                    refIndex = removeIndex >= refIndex ? refIndex : removeIndex;
                                    refEndIndex -= removeCount
                                }
                                else
                                {
                                    refEndIndex = removeIndex - 1
                                }
                            }
                            refIndex -= (relative ? baseIndex : 0);
                            refEndIndex -= (endRelative ? baseIndex : 0);
                            return {
                                    index: refIndex, endIndex: refEndIndex
                                }
                        }
                        return {
                                index: index, endIndex: endIndex
                            }
                    };
                    CalcOperatorAdjustor.prototype.adjustValidatorFormulasOnOperator = function(model, expressionAdjustor, index, count, beginRow, beginCol, endRow, endCol, isRow, isAdd)
                    {
                        if (Sheets.features.dataValidator)
                        {
                            var validators = Sheets._DataValidatorCache.getAllValidators();
                            var dataValidator,
                                condition,
                                formulas,
                                formula,
                                sheet;
                            for (var i = 0; i < validators.length; i++)
                            {
                                dataValidator = validators[i].validator;
                                sheet = validators[i].sheet;
                                var sheetSource = sheet._getSheetSource();
                                condition = dataValidator.condition;
                                formulas = condition.getFormulas();
                                var baseRow = endRow,
                                    baseCol = endCol;
                                if (sheetSource !== model)
                                {
                                    baseRow = beginRow;
                                    baseCol = beginCol
                                }
                                if (formulas && formulas.length > 0)
                                {
                                    for (var j = 0; j < formulas.length; j++)
                                    {
                                        formula = formulas[j];
                                        var expr = model.service.parse(model, formula, beginRow, beginCol);
                                        var newExpr = expressionAdjustor.call(this, sheetSource, baseRow, baseCol, expr, model, index, count, isRow, isAdd);
                                        if (expr !== newExpr || beginRow !== endRow || beginCol !== endCol)
                                        {
                                            var newFormula;
                                            newFormula = model.service.unparse(model, newExpr, baseRow, baseCol);
                                            formulas[j] = newFormula
                                        }
                                    }
                                    condition.setFormulas(formulas)
                                }
                            }
                        }
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulasOnOperator = function(model, expressionAdjustor, index, count, isRow, isAdd)
                    {
                        var self = this;
                        var calcModel,
                            row,
                            column,
                            expr;
                        var settedMap = {};
                        while (self._head)
                        {
                            calcModel = self._head.sourceModel;
                            var source = calcModel.source;
                            row = self._head.row;
                            column = self._head.column;
                            if (settedMap[row] && settedMap[row][column])
                            {
                                self.removeAdjust(self._head, 0);
                                continue
                            }
                            expr = calcModel._getExpr(row, column);
                            if (expr)
                            {
                                expr = expressionAdjustor.call(self, source, row, column, expr, model, index, count, isRow, isAdd);
                                var arrayInfo = calcModel.getArrayInfo(row, column);
                                if (arrayInfo)
                                {
                                    arrayInfo = new Sheets.Range(row, column, arrayInfo.rowCount, arrayInfo.colCount);
                                    for (var r = row; r < row + arrayInfo.rowCount; r++)
                                    {
                                        if (!settedMap[r])
                                        {
                                            settedMap[r] = {}
                                        }
                                        for (var c = column; c < column + arrayInfo.colCount; c++)
                                        {
                                            calcModel.setExpression(r, c, expr, arrayInfo, r === row && c === column);
                                            settedMap[r][c] = true
                                        }
                                    }
                                }
                                else
                                {
                                    calcModel.setExpression(row, column, expr, arrayInfo, true)
                                }
                            }
                            else if ((calcModel.getRowExpression && calcModel.getRowExpression(row)) || (calcModel.getColumnExpression && calcModel.getColumnExpression(column)))
                            {
                                calcModel._addCellsToDirty(row, column, 1, 1)
                            }
                            self.removeAdjust(self._head, 0)
                        }
                        while (self._headRows)
                        {
                            calcModel = self._headRows.sourceModel;
                            row = self._headRows.row;
                            if (calcModel.getRowExpression)
                            {
                                expr = calcModel.getRowExpression(row);
                                if (expr && calcModel.setExpression)
                                {
                                    calcModel.setExpression(row, -1, expressionAdjustor.call(self, source, row, -1, expr, model, index, count, isRow, isAdd), keyword_undefined, true)
                                }
                            }
                            self.removeAdjust(self._headRows, 1)
                        }
                        while (self._headCols)
                        {
                            calcModel = self._headCols.sourceModel;
                            column = self._headCols.column;
                            if (calcModel.getColumnExpression)
                            {
                                expr = calcModel.getColumnExpression(column);
                                if (expr && calcModel.setExpression)
                                {
                                    calcModel.setExpression(-1, column, expressionAdjustor.call(self, source, -1, column, expr, model, index, count, isRow, isAdd), keyword_undefined, true)
                                }
                            }
                            self.removeAdjust(self._headCols, 2)
                        }
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulaOnRemoveSheet2 = function(baseModel, baseRow, baseCol, oldExpr, removeModel)
                    {
                        return this.adjustFormulaOnRemoveSheet(baseModel, oldExpr, removeModel)
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulaOnRemoveSheet = function(baseModel, oldExpr, removeModel)
                    {
                        var self = this,
                            selfFunction = self.adjustFormulaOnRemoveSheet;
                        var newExpr = oldExpr,
                            arg,
                            fnArg,
                            i;
                        if (oldExpr instanceof Expressions.ExternalReferenceExpression)
                        {
                            var refModel = oldExpr.source;
                            if ((baseModel !== removeModel && refModel === removeModel) || (baseModel === removeModel && refModel !== removeModel))
                            {
                                newExpr = new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                        }
                        else if (oldExpr.t === 14)
                        {
                            arg = selfFunction.call(this, baseModel, oldExpr.argument, removeModel);
                            if (arg !== oldExpr.argument)
                            {
                                newExpr = new Expressions.ParenthesesExpression(arg)
                            }
                        }
                        else if (oldExpr.t === 11)
                        {
                            arg = selfFunction.call(this, baseModel, oldExpr.operand, removeModel);
                            if (arg !== oldExpr.operand)
                            {
                                newExpr = new Expressions.UnaryOperatorExpression(oldExpr.operator, arg)
                            }
                        }
                        else if (oldExpr.t === 10)
                        {
                            var arg0 = selfFunction.call(this, baseModel, oldExpr.left, removeModel);
                            var arg1 = selfFunction.call(this, baseModel, oldExpr.right, removeModel);
                            if (arg0 !== oldExpr.left || arg1 !== oldExpr.right)
                            {
                                newExpr = new Expressions.BinaryOperatorExpression(oldExpr.operator, arg0, arg1)
                            }
                        }
                        else if (oldExpr.t === 7)
                        {
                            var args = keyword_null;
                            var argCount = oldExpr.argCount();
                            for (i = 0; i < argCount; i++)
                            {
                                fnArg = oldExpr.getArg(i);
                                arg = selfFunction.call(this, baseModel, fnArg, removeModel);
                                if (arg !== fnArg)
                                {
                                    args = [];
                                    args[i] = arg;
                                    break
                                }
                            }
                            if (args)
                            {
                                for (i = 0; i < argCount; i++)
                                {
                                    fnArg = oldExpr.getArg(i);
                                    if (args[i] === keyword_undefined || args[i] === keyword_null)
                                    {
                                        args[i] = selfFunction.call(this, baseModel, fnArg, removeModel)
                                    }
                                }
                                newExpr = new Expressions.FunctionExpression(oldExpr.fn, args)
                            }
                        }
                        return newExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulasOnRemoveSheet = function(removeSource)
                    {
                        var model = removeSource.calcSourceModel,
                            rowCount = removeSource.getRowCount(),
                            colCount = removeSource.getColumnCount();
                        this._addDependentsToAdjust(model, 0, 0, rowCount, colCount);
                        this.adjustFormulasOnOperator(removeSource, this.adjustFormulaOnRemoveSheet2);
                        this.adjustValidatorFormulasOnOperator(removeSource, this.adjustFormulaOnRemoveSheet2, 0, 0, 0, 0, 0, 0, true, false)
                    };
                    CalcOperatorAdjustor.prototype._adjustCellExpressionOnMove = function(baseModel, baseRow, baseColumn, refExpr, info)
                    {
                        var isExternal = !!(refExpr.source);
                        var refModel = isExternal ? refExpr.source : baseModel;
                        var refRowRelative = refExpr.rowRelative;
                        var refColumnRelative = refExpr.columnRelative;
                        var refRow,
                            refColumn,
                            moveRef,
                            moveSource;
                        if ((baseRow >= 0 || !refRowRelative) && (baseColumn >= 0 || !refColumnRelative))
                        {
                            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
                            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
                            moveSource = info.destinationContains(baseModel, baseRow, baseColumn, 1, 1);
                            if (refModel === info._toModel && info.destinationContains(refModel, refRow, refColumn, 1, 1) && (!refRowRelative && !refColumnRelative || !moveSource))
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            moveRef = (isExternal && refModel === info._fromModel || !isExternal && baseModel === info._fromModel) && (!moveSource && info.sourceContains(info._fromModel, refRow, refColumn, 1, 1) || moveSource && info.destinationContains(info._toModel, refRow, refColumn, 1, 1));
                            if (moveSource)
                            {
                                refRow -= (refRowRelative ? info.rowOffset() : 0);
                                refColumn -= (refColumnRelative ? info.colOffset() : 0)
                            }
                            if (moveRef)
                            {
                                refRow += info.rowOffset();
                                refColumn += info.colOffset()
                            }
                            refRow -= (refRowRelative ? baseRow : 0);
                            refColumn -= (refColumnRelative ? baseColumn : 0);
                            if (info._fromModel === info._toModel)
                            {
                                refModel = isExternal ? refExpr.source : keyword_undefined
                            }
                            else
                            {
                                refModel = keyword_undefined;
                                if (moveRef && moveSource && isExternal)
                                {
                                    refModel = info._toModel
                                }
                                else if (moveRef && moveSource)
                                {}
                                else if (moveRef)
                                {
                                    refModel = info._toModel
                                }
                                else if (moveSource && !isExternal)
                                {
                                    refModel = info._fromModel
                                }
                            }
                            if (refRow !== refExpr.row || refColumn !== refExpr.column || refModel != refExpr.source)
                            {
                                if (refModel)
                                {
                                    return new Expressions.ExternalCellExpression(refModel, refRow, refColumn, refRowRelative, refColumnRelative)
                                }
                                else
                                {
                                    return new Expressions.CellExpression(refRow, refColumn, refRowRelative, refColumnRelative)
                                }
                            }
                        }
                        else if ((baseRow >= 0 || !refRowRelative) && baseColumn === -1)
                        {
                            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
                            if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                            {
                                refRow -= (refRowRelative ? info.rowOffset() : 0)
                            }
                            if (info.sourceContains(refModel, refRow, -1, refRowRelative, -1))
                            {
                                refRow += info.rowOffset()
                            }
                            else if (info.destinationContains(refModel, refRow, -1, 1, -1))
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            refRow -= (refRowRelative ? baseRow : 0);
                            if (refRow !== refExpr.row)
                            {
                                if (refExpr.t === 0)
                                {
                                    return new Expressions.CellExpression(refRow, refExpr.column, refRowRelative, refExpr.columnRelative)
                                }
                                else if (refExpr.t === 1)
                                {
                                    return new Expressions.ExternalCellExpression(refExpr.source, refRow, refExpr.column, refRowRelative, refExpr.columnRelative)
                                }
                            }
                        }
                        else if (baseRow === -1 && (baseColumn >= 0 && !refColumnRelative))
                        {
                            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
                            if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                            {
                                refColumn -= (refColumnRelative ? info.colOffset() : 0)
                            }
                            if (info.sourceContains(refModel, refRow, refColumn, 1, 1))
                            {
                                refColumn += info.colOffset()
                            }
                            else if (info.destinationContains(refModel, refRow, refColumn, 1, 1))
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            refColumn -= (refColumnRelative ? baseColumn : 0);
                            if (refRow !== refExpr.row || refColumn !== refExpr.column)
                            {
                                if (refExpr.t === 0)
                                {
                                    return new Expressions.CellExpression(refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative)
                                }
                                else if (refExpr.t === 1)
                                {
                                    return new Expressions.ExternalCellExpression(refExpr.source, refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative)
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype._adjustRangeExpressionOnMove = function(baseModel, baseRow, baseColumn, refExpr, info)
                    {
                        var isExternal = !!refExpr.source;
                        var refModel = isExternal ? refExpr.source : baseModel;
                        var rangeType = refExpr._getRangeType();
                        var refStartRowRelative,
                            refStartColumnRelative,
                            refEndRowRelative,
                            refEndColumnRelative;
                        var refStartRow,
                            refEndRow,
                            refStartColumn,
                            refEndColumn,
                            refRowCount,
                            refColumnCount;
                        var ro,
                            co,
                            ro1,
                            ro2,
                            co1,
                            co2,
                            moveRef,
                            moveSource;
                        if (rangeType === RangeType.cell)
                        {
                            refStartRowRelative = refExpr.startRowRelative;
                            refStartColumnRelative = refExpr.startColumnRelative;
                            refEndRowRelative = refExpr.endRowRelative;
                            refEndColumnRelative = refExpr.endColumnRelative;
                            if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) || (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative))
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                                refRowCount = refEndRow - refStartRow + 1;
                                refColumnCount = refEndColumn - refStartColumn + 1;
                                moveSource = info.destinationContains(baseModel, baseRow, baseColumn, 1, 1);
                                if (moveSource)
                                {
                                    var offsetRow = info._toRow - info._toColumn,
                                        offsetCol = info._toColumn - info._toRow;
                                    refRowCount += (refStartRowRelative ? -offsetRow : 0) + (refEndRowRelative ? offsetRow : 0);
                                    refColumnCount += (refStartColumnRelative ? -offsetCol : 0) + (refEndColumnRelative ? offsetCol : 0)
                                }
                                if (refModel === info._toModel && info.destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount) && (!refStartRowRelative && !refStartColumnRelative && !refEndRowRelative && !refEndColumnRelative || !moveSource))
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                moveRef = (isExternal && refModel === info._fromModel || !isExternal && baseModel === info._fromModel) && (!moveSource && info.sourceContains(info._fromModel, refStartRow, refStartColumn, refRowCount, refColumnCount) || moveSource && info.destinationContains(info._toModel, refStartRow, refStartColumn, refRowCount, refColumnCount));
                                if (moveSource)
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2;
                                    refStartColumn -= co1;
                                    refEndColumn -= co2
                                }
                                var refRangeChanged = false;
                                if (moveRef)
                                {
                                    ro = info.rowOffset();
                                    co = info.colOffset();
                                    refStartRow += ro;
                                    refEndRow += ro;
                                    refStartColumn += co;
                                    refEndColumn += co
                                }
                                else if (info.destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount))
                                {
                                    var intersectedRange = info.intersectWith(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount);
                                    if (intersectedRange && (intersectedRange.rowCount === refRowCount || intersectedRange.columnCount === refColumnCount))
                                    {
                                        refStartRow = intersectedRange.row + info.rowOffset();
                                        refStartColumn = intersectedRange.column + info.colOffset();
                                        refEndRow = refStartRow + intersectedRange.rowCount;
                                        refEndColumn = refStartColumn + intersectedRange.columnCount;
                                        refRangeChanged = true
                                    }
                                    else
                                    {
                                        return new Expressions.ErrorExpression(CalcErrorsReference)
                                    }
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                                if (info._fromModel === info._toModel)
                                {
                                    refModel = isExternal ? refExpr.source : keyword_undefined
                                }
                                else
                                {
                                    refModel = keyword_undefined;
                                    if (moveRef && moveSource && isExternal)
                                    {
                                        refModel = info._toModel
                                    }
                                    else if (moveRef && moveSource)
                                    {}
                                    else if (moveRef)
                                    {
                                        refModel = info._toModel
                                    }
                                    else if (moveSource && !isExternal)
                                    {
                                        refModel = info._fromModel
                                    }
                                }
                                if (refStartRow !== refExpr.startRow || refStartColumn !== refExpr.startColumn || refEndRow !== refExpr.endRow || refEndColumn !== refExpr.endColumn || refRangeChanged || refModel != refExpr.source)
                                {
                                    if (refModel)
                                    {
                                        return new Expressions.ExternalRangeExpression(refModel, refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative)
                                    }
                                    else
                                    {
                                        return new Expressions.RangeExpression(refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative)
                                    }
                                }
                            }
                            else if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && baseColumn === -1)
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                if (refStartRow > refEndRow)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2
                                }
                                refRowCount = refEndRow - refStartRow;
                                if (info.sourceContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow += ro;
                                    refEndRow += ro
                                }
                                else if (info.destinationContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                if (refStartRow !== refExpr.startRow || refEndRow !== refExpr.endRow)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        return new Expressions.RangeExpression(refStartRow, refExpr.startColumn, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.startColumnRelative, refEndRowRelative, refExpr.endColumnRelative)
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        return new Expressions.ExternalRangeExpression(refExpr.source, refStartRow, refExpr.startColumn, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.startColumnRelative, refEndRowRelative, refExpr.endColumnRelative)
                                    }
                                }
                            }
                            else if (baseRow === -1 && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative))
                            {
                                refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                                if (refStartColumn > refEndColumn)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                                {
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartColumn -= co1;
                                    refEndColumn -= co2
                                }
                                refColumnCount = refEndColumn - refStartColumn;
                                if (info.sourceContains(refModel, -1, refStartColumn, -1, refColumnCount))
                                {
                                    co = info.colOffset();
                                    refStartColumn += co;
                                    refEndColumn += co
                                }
                                else if (info.destinationContains(refModel, -1, refStartColumn, -1, refColumnCount))
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                                if (refStartColumn !== refExpr.startColumn || refEndColumn !== refExpr.endColumn)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        return new Expressions.RangeExpression(refExpr.startRow, refStartColumn, refExpr.endRow, refEndColumn, refExpr.startRowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative)
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        return new Expressions.ExternalRangeExpression(refExpr.source, refExpr.startRow, refStartColumn, refExpr.endRow, refEndColumn, refExpr.startRowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative)
                                    }
                                }
                            }
                        }
                        else if (rangeType === RangeType.row)
                        {
                            refStartRowRelative = refExpr.startRowRelative;
                            refEndRowRelative = refExpr.endRowRelative;
                            if (baseRow >= 0 || !refStartRowRelative || !refEndRowRelative)
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                if (refStartRow > refEndRow)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2
                                }
                                refRowCount = refEndRow - refStartRow;
                                if (info.sourceContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow += ro;
                                    refEndRow += ro
                                }
                                else if (info.destinationContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                if (refStartRow !== refExpr.startRow || refEndRow !== refExpr.endRow)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        var r1 = new Expressions.RangeExpression;
                                        r1.initBand(refStartRow, refEndRow, refStartRowRelative, refEndRowRelative, true);
                                        return r1
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        var r2 = new Expressions.ExternalRangeExpression;
                                        r2.initBand(refExpr.source, refStartRow, refEndRow, refStartRowRelative, refEndRowRelative, true);
                                        return r2
                                    }
                                }
                            }
                        }
                        else if (rangeType === RangeType.column)
                        {
                            refStartColumnRelative = refExpr.startColumnRelative;
                            refEndColumnRelative = refExpr.endColumnRelative;
                            refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                            refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                            if (refStartColumn < refEndColumn)
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                            {
                                co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                refStartColumn -= co1;
                                refEndColumn -= co2
                            }
                            refColumnCount = refEndColumn - refStartColumn;
                            if (info.sourceContains(refModel, -1, refStartColumn, -1, refColumnCount))
                            {
                                co = info.colOffset();
                                refStartColumn += co;
                                refEndColumn += co
                            }
                            else if (info.destinationContains(refModel, -1, refStartColumn, -1, refColumnCount))
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                            refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                            if (refStartColumn !== refExpr.startColumn || refEndColumn !== refExpr.endColumn)
                            {
                                if (refExpr.t === 2)
                                {
                                    var r3 = new Expressions.RangeExpression;
                                    r3.initBand(refStartColumn, refEndColumn, refStartColumnRelative, refEndColumnRelative, false);
                                    return r3
                                }
                                else if (refExpr.t === 2)
                                {
                                    var r4 = new Expressions.ExternalRangeExpression;
                                    r4.initBand(refExpr.source, refStartColumn, refEndColumn, refStartColumnRelative, refEndColumnRelative, false);
                                    return r4
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulaOnMoveSwap = function(baseModel, baseRow, baseColumn, oldExpr, info, isMove)
                    {
                        var self = this,
                            selfFunction = self.adjustFormulaOnMoveSwap;
                        var newExpr = oldExpr,
                            arg;
                        if (oldExpr.t === 0 || oldExpr.t === 1)
                        {
                            newExpr = isMove ? self._adjustCellExpressionOnMove(baseModel, baseRow, baseColumn, oldExpr, info) : self._adjustCellExpressionOnSwap(baseModel, baseRow, baseColumn, oldExpr, info)
                        }
                        else if (oldExpr.t === 2 || oldExpr.t === 3)
                        {
                            newExpr = isMove ? self._adjustRangeExpressionOnMove(baseModel, baseRow, baseColumn, oldExpr, info) : self._adjustRangeExpressionOnSwap(baseModel, baseRow, baseColumn, oldExpr, info)
                        }
                        else if (oldExpr.t === 14)
                        {
                            var parenthesesExpr = oldExpr;
                            arg = selfFunction.call(self, baseModel, baseRow, baseColumn, parenthesesExpr.argument, info, isMove);
                            if (arg !== parenthesesExpr.argument)
                            {
                                newExpr = new Expressions.ParenthesesExpression(arg)
                            }
                        }
                        else if (oldExpr.t === 11)
                        {
                            var unaryExpr = oldExpr;
                            arg = selfFunction.call(self, baseModel, baseRow, baseColumn, unaryExpr.operand, info, isMove);
                            if (arg !== unaryExpr.operand)
                            {
                                newExpr = new Expressions.UnaryOperatorExpression(unaryExpr.operator, arg)
                            }
                        }
                        else if (oldExpr.t === 10)
                        {
                            var binaryExpr = oldExpr;
                            var arg0 = selfFunction.call(self, baseModel, baseRow, baseColumn, binaryExpr.left, info, isMove);
                            var arg1 = selfFunction.call(self, baseModel, baseRow, baseColumn, binaryExpr.right, info, isMove);
                            if (arg0 !== binaryExpr.left || arg1 !== binaryExpr.right)
                            {
                                newExpr = new Expressions.BinaryOperatorExpression(binaryExpr.operator, arg0, arg1)
                            }
                        }
                        else if (oldExpr.t === 7)
                        {
                            var args = keyword_null,
                                fnArg,
                                i;
                            var functionExpr = oldExpr;
                            var argCount = functionExpr.argCount();
                            for (i = 0; i < argCount; i++)
                            {
                                fnArg = functionExpr.getArg(i);
                                arg = selfFunction.call(self, baseModel, baseRow, baseColumn, fnArg, info, isMove);
                                if (arg !== fnArg)
                                {
                                    args = [];
                                    args[i] = arg;
                                    break
                                }
                            }
                            if (args)
                            {
                                for (i = 0; i < argCount; i++)
                                {
                                    fnArg = functionExpr.getArg(i);
                                    if (args[i] === keyword_undefined || args[i] === keyword_null)
                                    {
                                        args[i] = selfFunction.call(self, baseModel, baseRow, baseColumn, fnArg, info, isMove)
                                    }
                                }
                                newExpr = new Expressions.FunctionExpression(functionExpr.fn, args)
                            }
                        }
                        return newExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustDataValidatorFormulasOnMoveSwap = function(info, isMove)
                    {
                        var self = this,
                            service = info._fromModel.service;
                        if (Sheets.features.dataValidator)
                        {
                            var validators = Sheets._DataValidatorCache.getAllValidators();
                            var dataValidator,
                                condition,
                                formulas,
                                formula,
                                sheet,
                                baseRow = 0,
                                baseCol = 0;
                            if (info._fromRow === 0 && info._fromColumn === 0 || info._toRow === 0 || info._toColumn === 0)
                            {
                                baseRow = info._rowCount;
                                baseCol = info._columnCount;
                                if (baseRow >= info._toRow && baseRow < info._toRow + info._rowCount && baseCol >= info._toColumn && baseCol < info._toColumn + info._columnCount)
                                {
                                    baseRow = info._toRow + info._rowCount
                                }
                                else if (baseRow >= info._fromRow && baseRow < info._fromRow + info._rowCount && baseCol >= info._fromColumn && baseCol < info._fromColumn + info._columnCount)
                                {
                                    baseRow = info._fromRow + info._rowCount
                                }
                            }
                            for (var i = 0; i < validators.length; i++)
                            {
                                dataValidator = validators[i].validator;
                                sheet = validators[i].sheet;
                                var sheetSource = sheet._getSheetSource();
                                condition = dataValidator.condition;
                                formulas = condition.getFormulas();
                                if (formulas && formulas.length > 0)
                                {
                                    for (var j = 0; j < formulas.length; j++)
                                    {
                                        formula = formulas[j];
                                        var expr = service.parse(info._fromModel, formula, baseRow, baseCol);
                                        var newExpr = self.adjustFormulaOnMoveSwap(sheetSource, baseRow, baseCol, expr, info, isMove);
                                        if (expr !== newExpr)
                                        {
                                            var newFormula = service.unparse(info._fromModel, newExpr, baseRow, baseCol);
                                            formulas[j] = newFormula
                                        }
                                    }
                                    condition.setFormulas(formulas)
                                }
                            }
                        }
                    };
                    CalcOperatorAdjustor.prototype._adjustCellExpressionOnSwap = function(baseModel, baseRow, baseColumn, refExpr, info)
                    {
                        var refModel = refExpr.source || baseModel;
                        var refRowRelative = refExpr.rowRelative,
                            refColumnRelative = refExpr.columnRelative,
                            refRow,
                            refColumn;
                        if ((baseRow >= 0 || !refRowRelative) && (baseColumn >= 0 || !refColumnRelative))
                        {
                            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
                            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
                            if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                            {
                                refRow -= (refRowRelative ? info.rowOffset() : 0);
                                refColumn -= (refColumnRelative ? info.colOffset() : 0)
                            }
                            else if (info.sourceContains(baseModel, refRow, refColumn, 1, 1))
                            {
                                refRow += (refRowRelative ? info.rowOffset() : 0);
                                refColumn += (refColumnRelative ? info.colOffset() : 0)
                            }
                            if (info.sourceContains(refModel, refRow, refColumn, 1, 1))
                            {
                                refRow += info.rowOffset();
                                refColumn += info.colOffset()
                            }
                            else if (info.destinationContains(refModel, refRow, refColumn, 1, 1))
                            {
                                refRow -= info.rowOffset();
                                refColumn -= info.colOffset()
                            }
                            refRow -= (refRowRelative ? baseRow : 0);
                            refColumn -= (refColumnRelative ? baseColumn : 0);
                            if (refRow !== refExpr.row || refColumn !== refExpr.column)
                            {
                                if (refExpr.t === 0)
                                {
                                    return new Expressions.CellExpression(refRow, refColumn, refRowRelative, refColumnRelative)
                                }
                                else if (refExpr.t === 1)
                                {
                                    return new Expressions.ExternalCellExpression(refExpr.source, refRow, refColumn, refRowRelative, refColumnRelative)
                                }
                            }
                        }
                        else if ((baseRow >= 0 || !refRowRelative) && baseColumn === -1)
                        {
                            refRow = refExpr.row + (refRowRelative ? baseRow : 0);
                            if (info.destinationContains(baseModel, baseRow, -1, 1, -1))
                            {
                                refRow -= (refRowRelative ? info.rowOffset() : 0)
                            }
                            else if (info.sourceContains(baseModel, refRow, -1, 1, -1))
                            {
                                refRow += (refRowRelative ? info.rowOffset() : 0)
                            }
                            if (info.sourceContains(refModel, refRow, -1, 1, -1))
                            {
                                refRow += info.rowOffset()
                            }
                            else if (info.destinationContains(refModel, refRow, -1, 1, -1))
                            {
                                refRow -= info.rowOffset()
                            }
                            refRow -= (refRowRelative ? baseRow : 0);
                            if (refRow !== refExpr.row || refColumn !== refExpr.column)
                            {
                                if (refExpr.t === 0)
                                {
                                    return new Expressions.CellExpression(refRow, refExpr.column, refRowRelative, refExpr.columnRelative)
                                }
                                else if (refExpr.t === 1)
                                {
                                    return new Expressions.ExternalCellExpression(refExpr.source, refRow, refExpr.column, refRowRelative, refExpr.columnRelative)
                                }
                            }
                        }
                        else if (baseRow === -1 && (baseColumn >= 0 && !refColumnRelative))
                        {
                            refColumn = refExpr.column + (refColumnRelative ? baseColumn : 0);
                            if (info.destinationContains(baseModel, -1, baseColumn, -1, 1))
                            {
                                refColumn -= (refColumnRelative ? info.colOffset() : 0)
                            }
                            else if (info.sourceContains(baseModel, -1, refColumn, -1, 1))
                            {
                                refColumn += (refColumnRelative ? info.colOffset() : 0)
                            }
                            if (info.sourceContains(refModel, -1, refColumn, -1, 1))
                            {
                                refColumn += info.colOffset()
                            }
                            else if (info.destinationContains(refModel, -1, refColumn, -1, 1))
                            {
                                refColumn -= info.colOffset()
                            }
                            refColumn -= (refColumnRelative ? baseColumn : 0);
                            if (refRow !== refExpr.row || refColumn !== refExpr.column)
                            {
                                if (refExpr.t === 0)
                                {
                                    return new Expressions.CellExpression(refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative)
                                }
                                else if (refExpr.t === 1)
                                {
                                    return new Expressions.ExternalCellExpression(refExpr.source, refExpr.row, refColumn, refExpr.rowRelative, refColumnRelative)
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype._adjustRangeExpressionOnSwap = function(baseModel, baseRow, baseColumn, refExpr, info)
                    {
                        var refModel = refExpr.source || baseModel;
                        var rangeType = refExpr._getRangeType();
                        var refStartRow,
                            refEndRow,
                            refStartColumn,
                            refEndColumn,
                            refRowCount,
                            refColumnCount;
                        var refStartRowRelative,
                            refStartColumnRelative,
                            refEndRowRelative,
                            refEndColumnRelative;
                        var ro,
                            co,
                            ro1,
                            co1,
                            ro2,
                            co2;
                        if (rangeType === RangeType.cell)
                        {
                            refStartRowRelative = refExpr.startRowRelative;
                            refStartColumnRelative = refExpr.startColumnRelative;
                            refEndRowRelative = refExpr.endRowRelative;
                            refEndColumnRelative = refExpr.endColumnRelative;
                            if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative))
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                                refRowCount = refEndRow - refStartRow;
                                refColumnCount = refEndColumn - refStartColumn;
                                if (info.destinationContains(baseModel, baseRow, baseColumn, 1, 1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2;
                                    refStartColumn -= co1;
                                    refEndColumn -= co2
                                }
                                else if (info.sourceContains(baseModel, refStartRow, refStartColumn, refRowCount, refColumnCount))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartRow += ro1;
                                    refEndRow += ro2;
                                    refStartColumn += co1;
                                    refEndColumn += co2
                                }
                                if (info.sourceContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount))
                                {
                                    ro = info.rowOffset();
                                    co = info.colOffset();
                                    refStartRow += ro;
                                    refEndRow += ro;
                                    refStartColumn += co;
                                    refEndColumn += co
                                }
                                else if (info.destinationContains(refModel, refStartRow, refStartColumn, refRowCount, refColumnCount))
                                {
                                    ro = info.rowOffset();
                                    co = info.colOffset();
                                    refStartRow -= ro;
                                    refEndRow -= ro;
                                    refStartColumn -= co;
                                    refEndColumn -= co
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                                if (refStartRow !== refExpr.startRow || refStartColumn !== refExpr.startColumn || refEndRow !== refExpr.endRow || refEndColumn !== refExpr.endColumn)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        return new Expressions.RangeExpression(refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative)
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        return new Expressions.ExternalRangeExpression(refExpr.source, refStartRow, refStartColumn, refEndRow, refEndColumn, refStartRowRelative, refStartColumnRelative, refEndRowRelative, refEndColumnRelative)
                                    }
                                }
                            }
                            else if ((baseRow >= 0 || !refStartRowRelative || !refEndRowRelative) && baseColumn === -1)
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                if (refStartRow < refEndRow)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, baseRow, -1, 1, -1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refStartRowRelative ? info.rowOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2
                                }
                                else if (info.sourceContains(baseModel, baseRow, -1, 1, -1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refStartRowRelative ? info.rowOffset() : 0);
                                    refStartRow += ro1;
                                    refEndRow += ro2
                                }
                                refRowCount = refEndRow - refStartRow;
                                if (info.sourceContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow += ro;
                                    refEndRow += ro
                                }
                                else if (info.destinationContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow -= ro;
                                    refEndRow -= ro
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                if (refStartRow !== refExpr.startRow || refEndRow !== refExpr.endRow)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        return new Expressions.RangeExpression(refStartRow, refExpr.startColumn, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.startColumnRelative, refEndRowRelative, refExpr.endColumnRelative)
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        return new Expressions.ExternalRangeExpression(refExpr.source, refStartRow, refExpr.startColumn, refEndRow, refExpr.endColumn, refStartRowRelative, refExpr.startColumnRelative, refEndRowRelative, refExpr.endColumnRelative)
                                    }
                                }
                            }
                            else if (baseRow === -1 && (baseColumn >= 0 || !refStartColumnRelative || !refEndColumnRelative))
                            {
                                refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                                if (refStartColumn < refEndColumn)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, -1, baseColumn, -1, 1))
                                {
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartColumn -= co1;
                                    refEndColumn -= co2
                                }
                                else if (info.sourceContains(baseModel, -1, baseColumn, -1, 1))
                                {
                                    co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                    co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                    refStartColumn += co1;
                                    refEndColumn += co2
                                }
                                refColumnCount = refEndColumn - refStartColumn;
                                if (info.sourceContains(refModel, -1, refStartColumn, -1, refColumnCount))
                                {
                                    co = info.colOffset();
                                    refStartColumn += co;
                                    refEndColumn += co
                                }
                                else if (info.destinationContains(refModel, -1, refStartColumn, -1, refColumnCount))
                                {
                                    co = info.colOffset();
                                    refStartColumn -= co;
                                    refEndColumn -= co
                                }
                                refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                                refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                                if (refStartColumn !== refExpr.startColumn || refEndColumn !== refExpr.endColumn)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        return new Expressions.RangeExpression(refExpr.startRow, refStartColumn, refExpr.endRow, refEndColumn, refExpr.startRowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative)
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        return new Expressions.ExternalRangeExpression(refExpr.source, refExpr.startRow, refStartColumn, refExpr.endRow, refEndColumn, refExpr.startRowRelative, refStartColumnRelative, refExpr.endRowRelative, refEndColumnRelative)
                                    }
                                }
                            }
                        }
                        else if (rangeType === RangeType.row)
                        {
                            refStartRowRelative = refExpr.startRowRelative;
                            refEndRowRelative = refExpr.endRowRelative;
                            if (baseRow >= 0 || !refStartRowRelative || !refEndRowRelative)
                            {
                                refStartRow = refExpr.startRow + (refStartRowRelative ? baseRow : 0);
                                refEndRow = refExpr.endRow + (refEndRowRelative ? baseRow : 0);
                                if (refStartRow < refEndRow)
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                                if (info.destinationContains(baseModel, baseRow, -1, 1, -1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    refStartRow -= ro1;
                                    refEndRow -= ro2
                                }
                                else if (info.sourceContains(baseModel, baseRow, -1, 1, -1))
                                {
                                    ro1 = (refStartRowRelative ? info.rowOffset() : 0);
                                    ro2 = (refEndRowRelative ? info.rowOffset() : 0);
                                    refStartRow += ro1;
                                    refEndRow += ro2
                                }
                                refRowCount = refEndRow - refStartRow;
                                if (info.sourceContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow += ro;
                                    refEndRow += ro
                                }
                                else if (info.destinationContains(refModel, refStartRow, -1, refRowCount, -1))
                                {
                                    ro = info.rowOffset();
                                    refStartRow -= ro;
                                    refEndRow -= ro
                                }
                                refStartRow -= (refStartRowRelative ? baseRow : 0);
                                refEndRow -= (refEndRowRelative ? baseRow : 0);
                                if (refStartRow !== refExpr.startRow || refEndRow !== refExpr.endRow)
                                {
                                    if (refExpr.t === 2)
                                    {
                                        var r1 = new Expressions.RangeExpression;
                                        r1.initBand(refStartRow, refEndRow, refStartRowRelative, refEndRowRelative, true);
                                        return r1
                                    }
                                    else if (refExpr.t === 3)
                                    {
                                        var r2 = new Expressions.ExternalRangeExpression;
                                        r2.initBand(refExpr.source, refStartRow, refEndRow, refStartRowRelative, refEndRowRelative, true);
                                        return r2
                                    }
                                }
                            }
                        }
                        else if (rangeType === RangeType.column)
                        {
                            refStartColumnRelative = refExpr.startColumnRelative;
                            refEndColumnRelative = refExpr.endColumnRelative;
                            refStartColumn = refExpr.startColumn + (refStartColumnRelative ? baseColumn : 0);
                            refEndColumn = refExpr.endColumn + (refEndColumnRelative ? baseColumn : 0);
                            if (refStartColumn > refEndColumn)
                            {
                                return new Expressions.ErrorExpression(CalcErrorsReference)
                            }
                            if (info.destinationContains(baseModel, -1, baseColumn, -1, 1))
                            {
                                co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                refStartColumn -= co1;
                                refEndColumn -= co2
                            }
                            else if (info.sourceContains(baseModel, -1, baseColumn, -1, 1))
                            {
                                co1 = (refStartColumnRelative ? info.colOffset() : 0);
                                co2 = (refEndColumnRelative ? info.colOffset() : 0);
                                refStartColumn += co1;
                                refEndColumn += co2
                            }
                            refColumnCount = refEndColumn - refStartColumn;
                            if (info.sourceContains(refModel, -1, refStartColumn, -1, refColumnCount))
                            {
                                co = info.colOffset();
                                refStartColumn += co;
                                refEndColumn += co
                            }
                            else if (info.destinationContains(refModel, -1, refStartColumn, -1, refColumnCount))
                            {
                                co = info.colOffset();
                                refStartColumn -= co;
                                refEndColumn -= co
                            }
                            refStartColumn -= (refStartColumnRelative ? baseColumn : 0);
                            refEndColumn -= (refEndColumnRelative ? baseColumn : 0);
                            if (refStartColumn !== refExpr.startColumn || refEndColumn !== refExpr.endColumn)
                            {
                                if (refExpr.t === 2)
                                {
                                    var r3 = new Expressions.RangeExpression;
                                    r3.initBand(refStartColumn, refEndColumn, refStartColumnRelative, refEndColumnRelative, false);
                                    return r3
                                }
                                else if (refExpr.t === 3)
                                {
                                    var r4 = new Expressions.ExternalRangeExpression;
                                    r4.initBand(refExpr.source, refStartColumn, refEndColumn, refStartColumnRelative, refEndColumnRelative, false);
                                    return r4
                                }
                            }
                        }
                        return refExpr
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulasOnMoveSwap = function(fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount, isMove)
                    {
                        var self = this,
                            adjustor = self.adjustFormulaOnMoveSwap;
                        var info = new MoveSwapInfo(fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount);
                        var calcModel,
                            row,
                            column,
                            expr,
                            settedMap = {};
                        self.adjustDataValidatorFormulasOnMoveSwap(info, isMove);
                        while (self._head)
                        {
                            calcModel = self._head.sourceModel;
                            row = self._head.row;
                            column = self._head.column;
                            if (settedMap[row] && settedMap[row][column])
                            {
                                self.removeAdjust(self._head, 0);
                                continue
                            }
                            expr = calcModel.getExpression(row, column);
                            if (expr)
                            {
                                expr = adjustor.call(self, calcModel.source, row, column, expr, info, isMove);
                                var arrayInfo = calcModel.getArrayInfo(row, column);
                                if (arrayInfo)
                                {
                                    arrayInfo = new Sheets.Range(row, column, arrayInfo.rowCount, arrayInfo.colCount);
                                    for (var r = row; r < row + arrayInfo.rowCount; r++)
                                    {
                                        if (!settedMap[r])
                                        {
                                            settedMap[r] = {}
                                        }
                                        for (var c = column; c < column + arrayInfo.colCount; c++)
                                        {
                                            calcModel.setExpression(r, c, expr, arrayInfo, r === row && c === column);
                                            settedMap[r][c] = true
                                        }
                                    }
                                }
                                else
                                {
                                    calcModel.setExpression(row, column, expr, arrayInfo, true)
                                }
                            }
                            else if ((calcModel.getRowExpression && calcModel.getRowExpression(row)) || (calcModel.getColumnExpression && calcModel.getColumnExpression(column)))
                            {
                                calcModel._addCellsToDirty(row, column, 1, 1)
                            }
                            self.removeAdjust(self._head, 0)
                        }
                        while (self._headRows)
                        {
                            calcModel = self._headRows.sourceModel;
                            row = self._headRows.row;
                            if (calcModel.getRowExpression)
                            {
                                expr = calcModel.getRowExpression(row);
                                if (expr && calcModel._setRowExpression)
                                {
                                    calcModel._setRowExpression(row, adjustor.call(self, calcModel.source, row, -1, expr, info, isMove), keyword_undefined)
                                }
                            }
                            self.removeAdjust(self._headRows, 1)
                        }
                        while (self._headCols)
                        {
                            calcModel = self._headCols.sourceModel;
                            column = self._headCols.column;
                            if (calcModel.getColumnExpression)
                            {
                                expr = calcModel.getColumnExpression(column);
                                if (expr && calcModel._setColumnExpression)
                                {
                                    calcModel._setColumnExpression(column, adjustor.call(self, calcModel.source, -1, column, expr, info, isMove), keyword_undefined)
                                }
                            }
                            self.removeAdjust(self._headCols, 2)
                        }
                    };
                    CalcOperatorAdjustor.prototype._addDependentsToAdjust = function(sourceModel, row, col, rowCount, colCount)
                    {
                        sourceModel.addDependents(row, col, rowCount, colCount, true, false)
                    };
                    CalcOperatorAdjustor.prototype._addCellsToAdjust = function(sourceModel, row, column, rowCount, columnCount)
                    {
                        var self = this;
                        var endRow = row + rowCount,
                            endCol = column + columnCount;
                        var calc,
                            expr;
                        for (var r = row; r < endRow; r++)
                        {
                            for (var c = column; c < endCol; c++)
                            {
                                calc = sourceModel._getCalc(r, c);
                                expr = sourceModel._getExpr(r, c);
                                if (!calc && !expr)
                                {
                                    continue
                                }
                                sourceModel._setCalc(r, c, keyword_null);
                                var cellCalc = sourceModel._getCellCalc(r, c, true);
                                self.addAdjust(cellCalc, 0)
                            }
                        }
                    };
                    CalcOperatorAdjustor.prototype._addColumnsToAdjust = function(sourceModel, col, colCount)
                    {
                        var self = this;
                        for (var c = col; c !== -1 && c < col + colCount; c++)
                        {
                            if (!sourceModel._getCalc(-1, c) && !sourceModel._getExpr(-1, c))
                            {
                                continue
                            }
                            sourceModel._setCalc(-1, c, keyword_null);
                            var columnCalc = sourceModel._getColumnCalc(c, true);
                            self.addAdjust(columnCalc, 2)
                        }
                    };
                    CalcOperatorAdjustor.prototype._addRowsToAdjust = function(sourceModel, row, rowCount)
                    {
                        var self = this;
                        for (var r = row; r !== -1 && r < row + rowCount; r++)
                        {
                            if (!sourceModel._getCalc(r, -1) && !sourceModel._getExpr(r, -1))
                            {
                                continue
                            }
                            sourceModel._setCalc(r, -1, keyword_null);
                            var rowCalc = sourceModel._getRowCalc(r, true);
                            self.addAdjust(rowCalc, 1)
                        }
                    };
                    CalcOperatorAdjustor.prototype._addVolatitleToAdjust = function(sourceModel)
                    {
                        var self = this,
                            calcModel;
                        var sheetModels = sourceModel.getCalcService().getAllSouceModels(),
                            volatiles,
                            volatiCalc;
                        for (var sheetIndex = 0; sheetIndex < sheetModels.length; sheetIndex++)
                        {
                            calcModel = sheetModels[sheetIndex];
                            volatiles = calcModel._getAllVolatitles();
                            for (var volatileIndex = 0; volatileIndex < volatiles.length; volatileIndex++)
                            {
                                volatiCalc = volatiles[volatileIndex];
                                if (volatiCalc && (volatiCalc instanceof CellCalc) && !self.isAdjustCell(volatiCalc))
                                {
                                    self.addAdjust(volatiCalc, 0)
                                }
                            }
                        }
                    };
                    CalcOperatorAdjustor.prototype.onBeforeAddRemoveRows = function(sourceModel, row)
                    {
                        var self = this;
                        var rc = sourceModel.rC(),
                            cc = sourceModel.cC();
                        sourceModel.unlinkCellExpression(row, 0, rc - row, cc);
                        sourceModel.unlinkRowExpression(row, rc - row);
                        self._addDependentsToAdjust(sourceModel, row, -1, rc - row, -1)
                    };
                    CalcOperatorAdjustor.prototype.onAfterAddRemoveRows = function(sourceModel, row, count, isAdd)
                    {
                        var self = this;
                        var rc = sourceModel.rC(),
                            cc = sourceModel.cC();
                        if (isAdd)
                        {
                            sourceModel._addCellsToDirty(row, 0, count, cc)
                        }
                        self._addCellsToAdjust(sourceModel, row, 0, rc - row, cc);
                        self._addRowsToAdjust(sourceModel, row, rc - row);
                        self._addVolatitleToAdjust(sourceModel);
                        self.adjustFormulasOnAddRemove(sourceModel.source, row, count, true, isAdd);
                        if (sourceModel.getCalcService().autoCalculation)
                        {
                            sourceModel.getCalcService().recalculateAll(false)
                        }
                    };
                    CalcOperatorAdjustor.prototype.onAfterAddRemoveColumns = function(sourceModel, column, count, isAdd)
                    {
                        var self = this;
                        var rc = sourceModel.rC(),
                            cc = sourceModel.cC();
                        if (isAdd)
                        {
                            sourceModel._addCellsToDirty(0, column, rc, count)
                        }
                        self._addCellsToAdjust(sourceModel, 0, column, rc, cc - column);
                        self._addColumnsToAdjust(sourceModel, column, cc - column);
                        self._addVolatitleToAdjust(sourceModel);
                        self.adjustFormulasOnAddRemove(sourceModel.source, column, count, false, isAdd);
                        if (sourceModel.getCalcService().autoCalculation)
                        {
                            sourceModel.getCalcService().recalculateAll(false)
                        }
                    };
                    CalcOperatorAdjustor.prototype.onBeforeAddRemoveColumns = function(sourceModel, column)
                    {
                        var self = this;
                        var rc = sourceModel.rC(),
                            cc = sourceModel.cC();
                        sourceModel.unlinkCellExpression(0, column, rc, cc - column);
                        sourceModel.unlinkColumnExpression(column, cc - column);
                        self._addDependentsToAdjust(sourceModel, -1, column, -1, cc - column)
                    };
                    CalcOperatorAdjustor._copyExpression = function(expr, row, column, offsetRow, offsetColumn)
                    {
                        var newExpr = expr,
                            self = CalcOperatorAdjustor,
                            selfFunction = self._copyExpression;
                        if (!Sheets.util.hasCalc() || !expr)
                        {
                            return newExpr
                        }
                        var Expressions = Calc.Expressions;
                        var maxRowCount = Parser.maxRowCount,
                            maxColCount = Parser.maxColumnCount;
                        var Reference = Calc.Errors.Reference;
                        var ErrorExpression = Expressions.ErrorExpression,
                            ExternalErrorExpression = Expressions.ExternalErrorExpression;
                        if (expr.t === 14)
                        {
                            newExpr = new Expressions.ParenthesesExpression;
                            newExpr.argument = selfFunction.call(self, expr.argument, row, column, offsetRow, offsetColumn)
                        }
                        else if (expr.t === 0 || expr.t === 1)
                        {
                            if (expr.rowRelative && ((expr.row + row < 0) || (expr.row + row > maxRowCount)) || expr.columnRelative && ((expr.column + column < 0) || (expr.column + column > maxColCount)))
                            {
                                return expr.source ? new ExternalErrorExpression(expr.source, Reference) : new ErrorExpression(Reference)
                            }
                            newExpr = expr.offset(0, 0, false)
                        }
                        else if (expr.t === 2 || expr.t === 3 || expr.t === 16)
                        {
                            var rangeExpr = expr;
                            if (rangeExpr.startRowRelative && ((rangeExpr.startRow + row < 0) || (rangeExpr.startRow + row > maxRowCount)) || rangeExpr.startColumnRelative && ((rangeExpr.startColumn + column < 0) || (rangeExpr.startColumn + column > maxColCount)) || rangeExpr.endRowRelative && ((rangeExpr.endRow + row < 0) || (rangeExpr.endRow + row > maxRowCount)) || rangeExpr.endColumnRelative && ((rangeExpr.endColumn + column < 0) || (rangeExpr.endColumn + column > maxColCount)))
                            {
                                return expr.startSource ? new Expressions.SheetRangeErrorExpression(expr.startSource, expr.endSource, Reference) : expr.source ? new ExternalErrorExpression(expr.source, Reference) : new ErrorExpression(Reference)
                            }
                            newExpr = expr.offset(0, 0, false)
                        }
                        else if (expr.t === 11)
                        {
                            newExpr = new Expressions.UnaryOperatorExpression(expr.operator, selfFunction.call(self, expr.operand, row, column, offsetRow, offsetColumn))
                        }
                        else if (expr.t === 10)
                        {
                            newExpr = new Expressions.BinaryOperatorExpression(expr.operator, selfFunction.call(self, expr.left, row, column, offsetRow, offsetColumn), selfFunction.call(self, expr.right, row, column, offsetRow, offsetColumn))
                        }
                        else if (expr.t === 7)
                        {
                            newExpr = new Expressions.FunctionExpression(expr.fn, []);
                            if (expr.args && expr.args.length > 0)
                            {
                                for (var i = 0; i < expr.args.length; i++)
                                {
                                    newExpr.args[i] = selfFunction.call(self, expr.args[i], row, column, offsetRow, offsetColumn)
                                }
                            }
                        }
                        else if (expr.t === 17)
                        {
                            newExpr = expr.offsetWhenCopy(offsetRow, offsetColumn)
                        }
                        return newExpr
                    };
                    CalcOperatorAdjustor.copyFormula = function(src, srcRow, srcColumn, dest, destRow, destColumn, copyRowCount, copyColumnCount, ignoreFilteredOutRow)
                    {
                        var srcCalcModel = src,
                            destCalcModel = dest,
                            srcSheetSource = src.source,
                            destSheetSource = dest.source,
                            self = CalcOperatorAdjustor;
                        if (!srcCalcModel || !destCalcModel)
                        {
                            return
                        }
                        var conditions = {},
                            condition;
                        var fromRow = srcRow;
                        var fromColumn = srcColumn;
                        var toRow = destRow;
                        var toColumn = destColumn;
                        var rowCount = copyRowCount;
                        var columnCount = copyColumnCount;
                        if (srcRow < 0)
                        {
                            fromRow = 0;
                            rowCount = Math_min(src.rC(), dest.rC())
                        }
                        if (srcColumn < 0)
                        {
                            fromColumn = 0;
                            columnCount = Math_min(src.cC(), dest.cC())
                        }
                        if (destRow < 0)
                        {
                            toRow = 0
                        }
                        if (destColumn < 0)
                        {
                            toColumn = 0
                        }
                        var crossSheet = !(src === dest);
                        if (srcCalcModel)
                        {
                            srcCalcModel.unlinkCellExpression(toRow, toColumn, rowCount, columnCount)
                        }
                        var mc = new Calc.CalcSourceModel(src.getCalcService(), srcSheetSource);
                        var r,
                            c;
                        for (r = 0; r < rowCount; r++)
                        {
                            for (c = 0; c < columnCount; c++)
                            {
                                srcCalcModel._copyExpr(mc, r + fromRow, c + fromColumn, r, c);
                                var style = src.source.getSheet().getStyleObject(r + toRow, c + toColumn);
                                if (style && style.validator)
                                {
                                    condition = style.validator.condition;
                                    if (condition && condition.getFormulas && condition.getFormulas().length > 0)
                                    {
                                        conditions[style.validator.id] = condition
                                    }
                                }
                            }
                        }
                        var exprSettedObj = {};
                        var calcSvc = dest.getCalcService();
                        for (r = 0; r < rowCount; r++)
                        {
                            if (ignoreFilteredOutRow && destSheetSource.isHiddenRow(r + toRow))
                            {
                                continue
                            }
                            var toR = r + toRow;
                            for (c = 0; c < columnCount; c++)
                            {
                                var toC = c + toColumn;
                                var expr = mc._getExpr(r, c);
                                if (expr)
                                {
                                    if (expr === exprSettedObj)
                                    {
                                        continue
                                    }
                                    expr = self._copyExpression(mc._getExpr(r, c), toR, toC, destRow - srcRow, destColumn - srcColumn);
                                    var arrayInfo = mc.getArrayInfo(r, c);
                                    if (destSheetSource)
                                    {
                                        if (arrayInfo)
                                        {
                                            var arrayRowCount = rowCount - r < arrayInfo.rowCount ? rowCount - r : arrayInfo.rowCount;
                                            var arrayColCount = columnCount - c < arrayInfo.colCount ? columnCount - c : arrayInfo.colCount;
                                            for (var i = 0; i < arrayRowCount; i++)
                                            {
                                                for (var j = 0; j < arrayColCount; j++)
                                                {
                                                    mc._setExpr(r + i, c + j, expr)
                                                }
                                            }
                                            dest.setArrayFormula(toR, toC, arrayRowCount, arrayColCount, calcSvc.unparseWithoutCulture(destSheetSource, expr, toR, toC), false)
                                        }
                                        else
                                        {
                                            var formula = expr ? calcSvc.unparseWithoutCulture(destSheetSource, expr, toR, toC) : keyword_undefined;
                                            destSheetSource.setFormula(toR, toC, formula);
                                            var workIngExpr = mc._getWorkingExpr(r, c);
                                            if (workIngExpr)
                                            {
                                                workIngExpr = self._copyExpression(workIngExpr, toR, toC, destRow - srcRow, destColumn - srcColumn)
                                            }
                                            destCalcModel._setCellExpression(toR, toC, expr, workIngExpr, arrayInfo)
                                        }
                                    }
                                    else
                                    {
                                        destCalcModel._setExpr(r + toRow, c + toColumn, expr);
                                        destCalcModel._setArrayInfo(r + toRow, c + toColumn, arrayInfo)
                                    }
                                }
                                else if (destCalcModel && destCalcModel.getExpression(toR, toC))
                                {
                                    destCalcModel._clearAllExpr(toR, toC)
                                }
                            }
                        }
                        for (var vkey in conditions)
                        {
                            condition = conditions[vkey];
                            var formulas = condition.getFormulas();
                            for (var i = 0; i < formulas.length; i++)
                            {
                                formula = formulas[i];
                                expr = calcSvc.parse(src.source, formula, fromRow, fromColumn);
                                formula = calcSvc.unparse(src.source, expr, toRow, toColumn);
                                formulas[i] = formula
                            }
                            condition.setFormulas(formulas)
                        }
                    };
                    CalcOperatorAdjustor.prototype.onAfterRemoveName = function(calcModel, name)
                    {
                        var nameCalc = calcModel._getNameCalc(name, false);
                        if (nameCalc)
                        {
                            nameCalc.updateListening(true, false);
                            nameCalc.addToDirty();
                            nameCalc.updateListeningOnRemoved()
                        }
                    };
                    CalcOperatorAdjustor.prototype.adjustFormulaOnRemoveName = function(baseModel, oldExpr, name)
                    {
                        var self = this,
                            selfFunction = self.adjustFormulaOnRemoveName;
                        var newExpr = oldExpr,
                            arg,
                            fnArg,
                            i;
                        if (oldExpr.t === 8 || oldExpr.t === 18 || oldExpr.t === 9)
                        {
                            if (oldExpr.name === name && (!oldExpr.source || oldExpr.source === baseModel.source))
                            {
                                if (oldExpr.source)
                                {
                                    return new Expressions.ExternalErrorExpression(oldExpr.source, CalcErrorsReference)
                                }
                                else
                                {
                                    return new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                            }
                        }
                        else if (oldExpr.t === 14)
                        {
                            arg = selfFunction.call(this, baseModel, oldExpr.argument, name);
                            if (arg !== oldExpr.argument)
                            {
                                newExpr = new Expressions.ParenthesesExpression(arg)
                            }
                        }
                        else if (oldExpr.t === 11)
                        {
                            arg = selfFunction.call(this, baseModel, oldExpr.operand, name);
                            if (arg !== oldExpr.operand)
                            {
                                newExpr = new Expressions.UnaryOperatorExpression(oldExpr.operator, arg)
                            }
                        }
                        else if (oldExpr.t === 10)
                        {
                            var arg0 = selfFunction.call(this, baseModel, oldExpr.left, name);
                            var arg1 = selfFunction.call(this, baseModel, oldExpr.right, name);
                            if (arg0 !== oldExpr.left || arg1 !== oldExpr.right)
                            {
                                newExpr = new Expressions.BinaryOperatorExpression(oldExpr.operator, arg0, arg1)
                            }
                        }
                        else if (oldExpr.t === 7)
                        {
                            var args = keyword_null;
                            var argCount = oldExpr.argCount();
                            for (i = 0; i < argCount; i++)
                            {
                                fnArg = oldExpr.getArg(i);
                                arg = selfFunction.call(this, baseModel, fnArg, name);
                                if (arg !== fnArg)
                                {
                                    args = [];
                                    args[i] = arg;
                                    break
                                }
                            }
                            if (args)
                            {
                                for (i = 0; i < argCount; i++)
                                {
                                    fnArg = oldExpr.getArg(i);
                                    if (args[i] === keyword_undefined || args[i] === keyword_null)
                                    {
                                        args[i] = selfFunction.call(this, baseModel, fnArg, name)
                                    }
                                }
                                newExpr = new Expressions.FunctionExpression(oldExpr.fn, args)
                            }
                        }
                        return newExpr
                    };
                    return CalcOperatorAdjustor
                })();
            Calc.CalcOperatorAdjustor = CalcOperatorAdjustor;
            var MoveSwapInfo = (function()
                {
                    function MoveSwapInfo(fromModel, fromRow, fromColumn, toModel, toRow, toColumn, rowCount, columnCount)
                    {
                        var self = this;
                        self._fromModel = fromModel;
                        self._fromRow = fromRow;
                        self._fromColumn = fromColumn;
                        self._toModel = toModel;
                        self._toRow = toRow;
                        self._toColumn = toColumn;
                        self._rowCount = rowCount;
                        self._columnCount = columnCount
                    }
                    MoveSwapInfo.prototype.rowOffset = function()
                    {
                        return this._toRow - this._fromRow
                    };
                    MoveSwapInfo.prototype.colOffset = function()
                    {
                        return this._toColumn - this._fromColumn
                    };
                    MoveSwapInfo.prototype.sourceContains = function(model, row, column, rowCount, columnCount)
                    {
                        var self = this;
                        return (self._fromModel === model) && ((self._fromRow === -1) || (self._fromRow <= row && row + rowCount <= self._fromRow + self._rowCount)) && ((self._fromColumn === -1) || (self._fromColumn <= column && column + columnCount <= self._fromColumn + self._columnCount))
                    };
                    MoveSwapInfo.prototype.destinationContains = function(model, row, column, rowCount, columnCount)
                    {
                        var self = this;
                        return (self._toModel === model) && ((self._toRow === -1) || (self._toRow <= row && row + rowCount <= self._toRow + self._rowCount)) && ((self._toColumn === -1) || (self._toColumn <= column && column + columnCount <= self._toColumn + self._columnCount))
                    };
                    MoveSwapInfo.prototype.intersectWith = function(model, row, column, rowCount, columnCount)
                    {
                        var self = this;
                        if (self._toModel !== model)
                        {
                            return keyword_null
                        }
                        var range = self._createValidCellRange(model, row, column, rowCount, columnCount);
                        var sourceRange = self._createValidCellRange(model, self._fromRow, self._fromColumn, rowCount, columnCount);
                        return sourceRange.intersectWith(range)
                    };
                    MoveSwapInfo.prototype._createValidCellRange = function(model, row, column, rowCount, columnCount)
                    {
                        var validFromRow = (row === -1 ? 0 : row);
                        var validFromRowCount = ((row === -1 || rowCount === -1) ? model.rowCount : rowCount);
                        var validFromColumn = (column === -1 ? 0 : column);
                        var validFromColumnCount = ((column === -1 || columnCount === -1) ? model.columnCount : columnCount);
                        return {
                                row: validFromRow, column: validFromColumn, rowCount: validFromRowCount, columnCount: validFromColumnCount, intersectWith: fnIntersectWith
                            }
                    };
                    return MoveSwapInfo
                })();
            function fnIntersectWith(current, range)
            {
                if (!range)
                {
                    range = this
                }
                var top = Math_max(current.row, range.row);
                var left = Math_max(current.column, range.column);
                var bottom = Math_min(current.row + current.rowCount, range.row + range.rowCount);
                var right = Math_min(current.column + current.columnCount, range.column + range.columnCount);
                if (top >= bottom || left >= right)
                {
                    return keyword_null
                }
                return {
                        row: top, column: left, rowCount: bottom - top, columnCount: right - left, intersectWith: fnIntersectWith
                    }
            }
            var CalcSource = (function()
                {
                    function CalcSource(service)
                    {
                        this.id = CalcSource.sourceId++;
                        this.service = service;
                        this.calcSourceModel = null
                    }
                    CalcSource.prototype.getValue = function(row, column, valueType)
                    {
                        return keyword_null
                    };
                    CalcSource.prototype.getName = function()
                    {
                        return ""
                    };
                    CalcSource.prototype.setValue = function(row, column, value){};
                    CalcSource.prototype.getReference = function(row, column, rowCount, columnCount)
                    {
                        return new SheetReference(this, [new Sheets.Range(row, column, rowCount, columnCount)])
                    };
                    CalcSource.prototype.getSheetRangeReference = function(endSource, row, column, rowCount, columnCount)
                    {
                        return new SheetReference(this, [new Sheets.Range(row, column, rowCount, columnCount)])
                    };
                    CalcSource.prototype.getSources = function(endSource)
                    {
                        return [this]
                    };
                    CalcSource.prototype.referenceToArray = function(reference, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var self = this,
                            row,
                            col,
                            rowCount = 1,
                            colCount = 1,
                            startRow,
                            startCol,
                            rangeCount,
                            result = [],
                            cellCache,
                            value,
                            rowValues,
                            rowCaches,
                            cacheKey,
                            typeString = CalcValueTypeStrings[valueType],
                            defaultValues = DefaultValues,
                            errorObject = Convert.CalcConvertedError;
                        rangeCount = reference.getRangeCount();
                        if (rangeCount === 0)
                        {
                            result.isError = true;
                            return []
                        }
                        var maxRowCount = this.getRowCount(),
                            maxColCount = this.getColumnCount();
                        toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
                        for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++)
                        {
                            if (!toOneDimension)
                            {
                                rowValues = [];
                                result.push(rowValues)
                            }
                            rowCount = reference.getRowCount(rangeIndex);
                            if (rowCount === 0)
                            {
                                result.isError = true;
                                return []
                            }
                            colCount = reference.getColumnCount(rangeIndex);
                            if (colCount === 0)
                            {
                                result.isError = true;
                                return []
                            }
                            startRow = reference.getRow(rangeIndex);
                            startCol = reference.getColumn(rangeIndex);
                            rowCount = Math.min(startRow + rowCount, maxRowCount) - startRow;
                            colCount = Math.min(startCol + colCount, maxColCount) - startCol;
                            var r,
                                c,
                                colValues;
                            for (var i = 0; i < rowCount; i++)
                            {
                                row = startRow + i;
                                if (!toOneDimension)
                                {
                                    colValues = [];
                                    rowValues.push(colValues)
                                }
                                for (var j = 0; j < colCount; j++)
                                {
                                    col = startCol + j;
                                    value = self.getValue(row, col);
                                    if (Convert.err(breakOnError && (value)))
                                    {
                                        result = [value];
                                        result.isError = true;
                                        return result
                                    }
                                    value = Convert.convertValue(value, valueType, true, ignoreBlank);
                                    if (breakOnConvertError)
                                    {
                                        result = [CalcErrorsValue];
                                        result.isError = true;
                                        return result
                                    }
                                    if (toOneDimension)
                                    {
                                        result.push(value)
                                    }
                                    else
                                    {
                                        colValues.push(value)
                                    }
                                }
                            }
                        }
                        if (!toOneDimension && rangeCount === 1)
                        {
                            result = result[0]
                        }
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.rangeCount = rangeCount;
                        return result
                    };
                    CalcSource.prototype.getSheetReference = function()
                    {
                        var self = this;
                        self._reference = self._reference || (new SheetReference(self));
                        return self._reference
                    };
                    CalcSource.prototype.setFormula = function(row, column, formula){};
                    CalcSource.prototype.setArrayFormula = function(row, column, rowCount, columnCount, formula){};
                    CalcSource.prototype.getRowCount = function()
                    {
                        return Parser.maxRowCount
                    };
                    CalcSource.prototype.getColumnCount = function()
                    {
                        return Parser.maxColumnCount
                    };
                    CalcSource.prototype.isHiddenRow = function(row, onlyFiltered)
                    {
                        return false
                    };
                    CalcSource.prototype.getParserContext = function(useR1C1, baseRow, baseColumn, option)
                    {
                        return new ParserContext(this, useR1C1, baseRow, baseColumn, option)
                    };
                    CalcSource.prototype.startCalculation = function(){};
                    CalcSource.prototype.endCalculation = function(){};
                    CalcSource.prototype.getEvaluatorContext = function(row, col, arrayFormula, baseRow, baseCol, rowCount, colCount)
                    {
                        if (arrayFormula)
                        {
                            baseRow = typeof baseRow === const_undefined ? row : baseRow;
                            baseCol = typeof baseCol === const_undefined ? col : baseCol;
                            return new EvaluateContext(this, arrayFormula, baseRow, baseCol, rowCount, colCount, row, col)
                        }
                        else
                        {
                            return new EvaluateContext(this, arrayFormula, row, col)
                        }
                    };
                    CalcSource.prototype.getCustomFunction = function(name)
                    {
                        return keyword_null
                    };
                    CalcSource.prototype.getCustomName = function(name)
                    {
                        return keyword_null
                    };
                    CalcSource.prototype.refresh = function(){};
                    CalcSource.sourceId = 1;
                    return CalcSource
                })();
            Calc.CalcSource = CalcSource;
            var CalcService = (function()
                {
                    function CalcService()
                    {
                        this._sourceModeles = {};
                        this.autoCalculation = true;
                        this._headNames = ["_head", "_headRows", "_headCols"];
                        this._tailNames = ["_tail", "_tailRows", "_tailCols"];
                        this.maximumIterations = 1;
                        this.maximumChange = 0.01;
                        var self = this;
                        self._parser = new Parser;
                        self._evaluator = new Evaluator;
                        self.useR1C1 = false;
                        self._suspended = 0;
                        self._operatorAdjustor = new CalcOperatorAdjustor
                    }
                    CalcService.prototype.getOperatorAdjustor = function()
                    {
                        return this._operatorAdjustor
                    };
                    CalcService.prototype.getSourceModel = function(source)
                    {
                        var model = this._sourceModeles[source.id];
                        if (!model)
                        {
                            model = this._sourceModeles[source.id] = new CalcSourceModel(this, source);
                            source.calcSourceModel = model
                        }
                        return model
                    };
                    CalcService.prototype.setSourceModel = function(source, model)
                    {
                        this._sourceModeles[source.id] = model
                    };
                    CalcService.prototype.getAllSouceModels = function()
                    {
                        var result = [],
                            models = this._sourceModeles;
                        for (var modelName in models)
                        {
                            result.push(models[modelName])
                        }
                        return result
                    };
                    CalcService.prototype.removeSource = function(source)
                    {
                        var model = this._sourceModeles[source.id];
                        if (model)
                        {
                            this._operatorAdjustor.adjustFormulasOnRemoveSheet(source);
                            delete this._sourceModeles[source.id]
                        }
                    };
                    CalcService.prototype.clearSource = function()
                    {
                        this._sourceModeles = {};
                        this.clearDirties()
                    };
                    CalcService.prototype.ignoreDirty = function()
                    {
                        return this._ignoreDirty
                    };
                    CalcService.prototype.suspend = function(ignoreDirty)
                    {
                        if (!this._parseCache)
                        {
                            this._parseCache = {}
                        }
                        this._suspended++;
                        this._ignoreDirty = ignoreDirty ? true : ignoreDirty
                    };
                    CalcService.prototype.resume = function(recalcAll)
                    {
                        var self = this;
                        self._suspended--;
                        if (self._suspended < 0)
                        {
                            self._suspended = 0
                        }
                        if (!self.IsSuspended())
                        {
                            this._parseCache = keyword_null;
                            self._ignoreDirty = false;
                            self.recalculateAll(recalcAll)
                        }
                    };
                    CalcService.prototype.clearDirties = function()
                    {
                        var self = this;
                        var node,
                            nextNode,
                            nodes = [self._head, self._headRows, self._headCols];
                        for (var i = 0; i < nodes.length; i++)
                        {
                            node = nodes[i];
                            while (node)
                            {
                                nextNode = node.nextDirty;
                                if (nextNode)
                                {
                                    node.nextDirty = nextNode.preDirty = keyword_undefined;
                                    node = nextNode
                                }
                                else
                                {
                                    node = keyword_null
                                }
                            }
                        }
                        self._head = self._tail = self._headRows = self._tailRows = self._headCols = self._tailCols = keyword_null
                    };
                    CalcService.prototype.resumeWithoutCalc = function()
                    {
                        this._suspended = 0;
                        this.clearDirties()
                    };
                    CalcService.prototype.IsSuspended = function()
                    {
                        return this._suspended > 0
                    };
                    CalcService.prototype.recalculate = function(source, row, column)
                    {
                        var model = this.getSourceModel(source);
                        if (column === -1)
                        {
                            model._addCellsToDirty(row, 0, 1, model.cC())
                        }
                        else if (row === -1)
                        {
                            model._addCellsToDirty(0, column, model.rC(), 1)
                        }
                        else
                        {
                            model._addCellsToDirty(row, column, 1, 1)
                        }
                        if (!this.IsSuspended())
                        {
                            this.recalculateAll(false)
                        }
                    };
                    CalcService.prototype.recalcRange = function(source, row, column, rowCount, columnCount)
                    {
                        var model = this.getSourceModel(source);
                        if (column === -1)
                        {
                            model._addCellsToDirty(row, 0, rowCount, model.cC())
                        }
                        else if (row === -1)
                        {
                            model._addCellsToDirty(0, column, model.rC(), columnCount)
                        }
                        else
                        {
                            model._addCellsToDirty(row, column, rowCount, columnCount)
                        }
                        if (!this.IsSuspended())
                        {
                            this.recalculateAll(false)
                        }
                    };
                    CalcService.prototype.recalculateAll = function(dirtyAll)
                    {
                        var self = this,
                            sourceModel;
                        if (self.IsSuspended())
                        {
                            return
                        }
                        self._evaluator.startCache();
                        var sourceModeles = this._sourceModeles;
                        for (var sourceName in sourceModeles)
                        {
                            sourceModel = sourceModeles[sourceName];
                            sourceModel.source.startCalculation();
                            if (dirtyAll !== false)
                            {
                                var colCount = sourceModel.cC();
                                var rowCount = sourceModel.rC();
                                sourceModel._addColumnsToDirty(0, colCount);
                                sourceModel._addRowsToDirty(0, rowCount);
                                sourceModel._addCellsToDirty(0, 0, rowCount, colCount)
                            }
                            else
                            {
                                sourceModel._addVolatitlesToDirty()
                            }
                        }
                        self._recalculateImp();
                        for (var sourceName in sourceModeles)
                        {
                            sourceModel = sourceModeles[sourceName];
                            sourceModel.source.endCalculation()
                        }
                        self._evaluator.endCache()
                    };
                    CalcService.prototype._cacheHeadDirtyColumns = function(cachedDirtyColumns, currentHeadDirtyColumns)
                    {
                        var index = cachedDirtyColumns.length;
                        var dirtyColumn = currentHeadDirtyColumns;
                        while (dirtyColumn)
                        {
                            cachedDirtyColumns[index] = dirtyColumn;
                            index++;
                            dirtyColumn = dirtyColumn.nextDirty
                        }
                    };
                    CalcService.prototype._recalculateImp = function(dirtyDependency)
                    {
                        if (dirtyDependency === undefined)
                        {
                            dirtyDependency = true
                        }
                        var self = this;
                        var nextDirty = keyword_null,
                            progress = false,
                            sheetSource,
                            r,
                            c,
                            row,
                            col,
                            rowCount,
                            columnCount,
                            cell,
                            rowCalc,
                            columnCalc,
                            rangesCalc;
                        if (dirtyDependency)
                        {
                            var cachedHeadDirtyColumns = [];
                            if (self._headCols)
                            {
                                self._cacheHeadDirtyColumns(cachedHeadDirtyColumns, self._headCols)
                            }
                            while (self._headRows)
                            {
                                sheetSource = self._headRows.sourceModel;
                                columnCount = sheetSource.cC();
                                for (c = 0; c < columnCount; c++)
                                {
                                    self.addDirty(sheetSource._getCellCalc(self._headRows.row, c, true), 0)
                                }
                                self.removeDirty(self._headRows, 1)
                            }
                            while (self._headCols)
                            {
                                sheetSource = self._headCols.sourceModel;
                                rowCount = sheetSource.rC();
                                if (rowCount > 0)
                                {
                                    for (r = 0; r < rowCount; r++)
                                    {
                                        self.addDirty(sheetSource._getCellCalc(r, self._headCols.column, true), 0)
                                    }
                                }
                                else
                                {
                                    self._headCols.addListenersToDirty()
                                }
                                self.removeDirty(self._headCols, 2)
                            }
                            for (cell = self._head; cell; cell = cell.nextDirty)
                            {
                                sheetSource = cell.sourceModel;
                                row = cell.row;
                                col = cell.column;
                                rowCalc = sheetSource._getRowCalc(row, false);
                                columnCalc = sheetSource._getColumnCalc(col, false);
                                rangesCalc = sheetSource._getRangeCalc(false);
                                cell.addListenersToDirty();
                                if (rowCalc)
                                {
                                    rowCalc.addListenersToDirty()
                                }
                                if (columnCalc)
                                {
                                    columnCalc.addListenersToDirty()
                                }
                                if (rangesCalc)
                                {
                                    rangesCalc.addListenersToDirty(row, col, 1, 1)
                                }
                                while (self._headRows)
                                {
                                    sheetSource = self._headRows.sourceModel;
                                    columnCount = sheetSource.cC();
                                    for (c = 0; c < columnCount; c++)
                                    {
                                        self.addDirty(sheetSource._getCellCalc(self._headRows.row, c, true), 0)
                                    }
                                    self.removeDirty(self._headRows, 1)
                                }
                                while (self._headCols)
                                {
                                    var reapted = false;
                                    for (var i = 0; i < cachedHeadDirtyColumns.length; i++)
                                    {
                                        if (cachedHeadDirtyColumns[i] == self._headCols)
                                        {
                                            reapted = true;
                                            break
                                        }
                                    }
                                    if (reapted)
                                    {
                                        self.removeDirty(self._headCols, 2);
                                        continue
                                    }
                                    else
                                    {
                                        cachedHeadDirtyColumns[cachedHeadDirtyColumns.length] = self._headCols
                                    }
                                    sheetSource = self._headCols.sourceModel;
                                    rowCount = sheetSource.rC();
                                    for (r = 0; r < rowCount; r++)
                                    {
                                        self.addDirty(sheetSource._getCellCalc(r, self._headCols.column, true), 0)
                                    }
                                    self.removeDirty(self._headCols, 2)
                                }
                            }
                        }
                        for (cell = self._head; cell; cell = nextDirty)
                        {
                            sheetSource = cell.sourceModel;
                            var maxRowCount = sheetSource.rC();
                            var maxColCount = sheetSource.cC();
                            nextDirty = cell.nextDirty;
                            if (cell.row < maxRowCount && cell.column < maxColCount)
                            {
                                if (supportRowColumnFormula)
                                {
                                    columnCalc = sheetSource._getColumnCalc(cell.column, false);
                                    if (columnCalc)
                                    {
                                        columnCalc.delay = 0
                                    }
                                }
                                cell.delay = 0
                            }
                            else
                            {
                                self.removeDirty(cell, 0)
                            }
                        }
                        for (cell = self._head; cell; cell = cell.nextDirty)
                        {
                            sheetSource = cell.sourceModel;
                            r = cell.row;
                            c = cell.column;
                            rowCalc = sheetSource._getRowCalc(r, false);
                            columnCalc = sheetSource._getColumnCalc(c, false);
                            rangesCalc = sheetSource._getRangeCalc(false);
                            cell.adjustDelayOfListeners(true);
                            if (rowCalc)
                            {
                                rowCalc.adjustDelayOfListeners(true)
                            }
                            if (columnCalc)
                            {
                                columnCalc.adjustDelayOfListeners(true)
                            }
                            if (rangesCalc)
                            {
                                rangesCalc.adjustDelayOfListeners(r, c, true)
                            }
                        }
                        do
                        {
                            progress = false;
                            for (cell = self._head; cell; cell = cell.nextDirty)
                            {
                                nextDirty = cell.nextDirty;
                                if (cell.delay === 0)
                                {
                                    sheetSource = cell.sourceModel;
                                    r = cell.row;
                                    c = cell.column;
                                    rowCalc = sheetSource._getRowCalc(r, false);
                                    columnCalc = sheetSource._getColumnCalc(c, false);
                                    if (columnCalc && columnCalc.delay !== 0)
                                    {
                                        continue
                                    }
                                    rangesCalc = sheetSource._getRangeCalc(false);
                                    sheetSource.recalculateCell(r, c);
                                    self.removeDirty(cell, 0);
                                    cell.adjustDelayOfListeners(false);
                                    if (rowCalc)
                                    {
                                        rowCalc.adjustDelayOfListeners(false)
                                    }
                                    if (columnCalc)
                                    {
                                        columnCalc.adjustDelayOfListeners(false)
                                    }
                                    if (rangesCalc)
                                    {
                                        rangesCalc.adjustDelayOfListeners(r, c, false)
                                    }
                                    progress = true
                                }
                            }
                        } while (progress);
                        if (self._head)
                        {
                            var moreIterations = true;
                            for (var i = 0; moreIterations && i < self.maximumIterations; i++)
                            {
                                moreIterations = false;
                                for (cell = self._head; cell; cell = cell.nextDirty)
                                {
                                    var formulaContext = cell.sourceModel;
                                    r = cell.row;
                                    c = cell.column;
                                    var oldValue = formulaContext.source.getValue(r, c);
                                    formulaContext.recalculateCell(r, c);
                                    var newValue = formulaContext.source.getValue(r, c);
                                    if (self._iterationChange(oldValue, newValue) >= self.maximumChange)
                                    {
                                        moreIterations = true
                                    }
                                }
                            }
                        }
                    };
                    CalcService.prototype._iterationChange = function(oldValue, newValue)
                    {
                        var oldDouble = parseFloat(oldValue);
                        var newDouble = parseFloat(newValue);
                        return Math_abs(newDouble - oldDouble)
                    };
                    CalcService.prototype.initParserContext = function(source)
                    {
                        var parseContext = this._parserContext;
                        if (!parseContext)
                        {
                            this._parserContext = parseContext = source.getParserContext(this.useR1C1, 0, 0, keyword_null)
                        }
                    };
                    CalcService.prototype.parse = function(source, formula, row, col, ignoreError, forceA1)
                    {
                        var self = this,
                            parseCache = self._parseCache;
                        var parseContext = self._parserContext;
                        if (!parseContext)
                        {
                            if (!source)
                            {
                                parseContext = new ParserContext(keyword_null, self.useR1C1, 0, 0, keyword_null)
                            }
                            else
                            {
                                self._parserContext = parseContext = source.getParserContext(self.useR1C1, 0, 0, keyword_null)
                            }
                        }
                        parseContext.setSource(source);
                        parseContext.useR1C1 = forceA1 ? false : self.useR1C1;
                        parseContext.ignoreError = ignoreError;
                        parseContext.row = row;
                        parseContext.column = col;
                        if (parseCache)
                        {
                            if (!parseContext.useR1C1)
                            {
                                parseContext.useR1C1 = true;
                                formula = self._parser.a1ToR1C1(parseContext, formula)
                            }
                            var cache = parseCache[formula];
                            if (cache)
                            {
                                return cache
                            }
                            var expr = self._parser.parse(formula, parseContext);
                            parseCache[formula] = expr;
                            return expr
                        }
                        else
                        {
                            return self._parser.parse(formula, parseContext)
                        }
                    };
                    CalcService.prototype.unparse = function(source, expr, row, col)
                    {
                        var parseContext = this._parserContext;
                        parseContext.source = source;
                        parseContext.useR1C1 = this.useR1C1;
                        parseContext.row = row;
                        parseContext.column = col;
                        return this._parser.unparse(expr, parseContext)
                    };
                    CalcService.prototype.unparseWithoutCulture = function(source, expr, row, col, toStandard)
                    {
                        var parseContext = this._parserContext;
                        parseContext.row = row;
                        parseContext.column = col;
                        parseContext.useR1C1 = this.useR1C1;
                        parseContext.source = source;
                        if (toStandard)
                        {
                            parseContext.toStandard = true
                        }
                        var formula = this._parser.unparseWithoutCulture(expr, parseContext);
                        parseContext.toStandard = false;
                        return formula
                    };
                    CalcService.prototype.isDirtyCell = function(cell)
                    {
                        return !!cell.preDirty || cell === this._head
                    };
                    CalcService.prototype.addDirty = function(node, type)
                    {
                        var self = this,
                            head = self._headNames[type],
                            tail = self._tailNames[type];
                        if (node && !node.preDirty && node !== self[head])
                        {
                            if (self[head])
                            {
                                self[tail].nextDirty = node
                            }
                            else
                            {
                                self[head] = node
                            }
                            node.preDirty = self[tail];
                            node.nextDirty = keyword_null;
                            self[tail] = node
                        }
                    };
                    CalcService.prototype.removeDirty = function(node, type)
                    {
                        var self = this,
                            head = self._headNames[type],
                            tail = self._tailNames[type];
                        if (node && (node.preDirty || node === self[head]))
                        {
                            var prevDirty = node.preDirty;
                            var nextDirty = node.nextDirty;
                            if (prevDirty)
                            {
                                prevDirty.nextDirty = nextDirty
                            }
                            else
                            {
                                self[head] = nextDirty
                            }
                            if (nextDirty)
                            {
                                nextDirty.preDirty = prevDirty
                            }
                            else
                            {
                                self[tail] = prevDirty
                            }
                            node.preDirty = keyword_null;
                            node.nextDirty = keyword_null
                        }
                    };
                    CalcService.prototype.isDirtyRow = function(row)
                    {
                        return row.preDirty || row === this._headRows
                    };
                    CalcService.prototype.isDirtyColumn = function(column)
                    {
                        return column.preDirty || column === this._headCols
                    };
                    CalcService.prototype.evaluateParsedFormula = function(source, expr, row, col, isArrayFormula, convertNullToZero, baseRow, baseCol, rowCount, colCount)
                    {
                        var evalContext = source.getEvaluatorContext(row, col, isArrayFormula, baseRow, baseCol, rowCount, colCount);
                        var val = this._evaluator.evaluateExpression(expr, evalContext, convertNullToZero);
                        if (isArrayFormula && arguments.length <= 5)
                        {
                            return (val === keyword_undefined || val === keyword_null) ? 0 : val
                        }
                        if (Convert.ref(val))
                        {
                            var rc = val.getRowCount(0),
                                cc = val.getColumnCount(0);
                            if (val.getRangeCount() <= 0)
                            {
                                return CalcErrorsReference
                            }
                            else
                            {
                                if (val.getRangeCount() !== 1)
                                {
                                    return CalcErrorsValue
                                }
                                else
                                {
                                    try
                                    {
                                        var ro = isArrayFormula ? row - baseRow : row - val.getRow(0),
                                            co = isArrayFormula ? col - baseCol : col - val.getColumn(0);
                                        if (rc === 1 && cc === 1)
                                        {
                                            val = val.getValue(0, 0, 0)
                                        }
                                        else if (rc === 1 && cc > 1 && co >= 0 && co < cc)
                                        {
                                            val = val.getValue(0, 0, co)
                                        }
                                        else if (rc > 1 && cc === 1 && ro >= 0 && ro < rc)
                                        {
                                            val = val.getValue(0, ro, 0)
                                        }
                                        else if (isArrayFormula && ro < rc && co < cc)
                                        {
                                            val = val.getValue(0, ro, co)
                                        }
                                        else if (isArrayFormula)
                                        {
                                            return CalcErrorsNotAvailable
                                        }
                                        else
                                        {
                                            return CalcErrorsValue
                                        }
                                    }
                                    catch(iex)
                                    {
                                        return CalcErrorsValue
                                    }
                                }
                            }
                        }
                        else if (Convert.arr(val))
                        {
                            if (!isArrayFormula)
                            {
                                val = val.getValueByIndex(0)
                            }
                            else
                            {
                                var arrayValue = val;
                                var rc1 = arrayValue.getRowCount();
                                var cc1 = arrayValue.getColumnCount();
                                if (rc1 != 1 && row - baseRow >= rc1 || cc1 != 1 && col - baseCol >= cc1)
                                {
                                    return CalcErrorsNotAvailable
                                }
                                val = val.getValue(rc1 == 1 ? 0 : row - baseRow, cc1 == 1 ? 0 : col - baseCol)
                            }
                        }
                        return (val === keyword_undefined || val === keyword_null) ? 0 : val
                    };
                    CalcService.prototype._getParserContext = function(source, row, col)
                    {
                        var self = this,
                            parseCache = self._parseCache;
                        var parseContext = self._parserContext;
                        if (!parseContext)
                        {
                            self._parserContext = parseContext = source.getParserContext(self.useR1C1, 0, 0, keyword_null)
                        }
                        parseContext.useR1C1 = self.useR1C1;
                        parseContext.row = row;
                        parseContext.column = col;
                        return parseContext
                    };
                    CalcService.prototype.evaluate = function(source, formula, row, col)
                    {
                        var self = this;
                        return self._evaluator.evaluateFormula(formula, source.getParserContext(self.useR1C1, row, col), source.getEvaluatorContext(row, col, false))
                    };
                    return CalcService
                })();
            Calc.CalcService = CalcService;
            (function(ListenerActions)
            {
                ListenerActions[ListenerActions["Adjust"] = 0] = "Adjust";
                ListenerActions[ListenerActions["dirty"] = 1] = "dirty"
            })(Calc.ListenerActions || (Calc.ListenerActions = {}));
            var ListenerActions = Calc.ListenerActions;
            var CalcSourceModel = (function()
                {
                    function CalcSourceModel(service, source)
                    {
                        this._lastNonNullRow = 0;
                        this._lastNonNullColumn = 0;
                        this._volatitleCells = [];
                        var self = this;
                        self.dataTable = {};
                        self._rowDataArray = [];
                        self._columnDataArray = [];
                        self._defaultDataNode = keyword_null;
                        self.source = source;
                        self._service = service
                    }
                    CalcSourceModel.prototype.getAllNodes = function()
                    {
                        var nodes = [],
                            cells = this.dataTable,
                            rows = this._rowDataArray,
                            cols = this._columnDataArray,
                            sheet = this._defaultDataNode,
                            node;
                        if (sheet)
                        {
                            nodes.push(sheet)
                        }
                        for (var key in rows)
                        {
                            nodes.push(rows[key])
                        }
                        for (var key in cols)
                        {
                            nodes.push(cols[key])
                        }
                        for (var rowKey in cells)
                        {
                            node = cells[rowKey];
                            for (key in node)
                            {
                                nodes.push(node[key])
                            }
                        }
                        return nodes
                    };
                    CalcSourceModel.prototype.getNode = function(row, col, create)
                    {
                        var self = this;
                        var node = keyword_null;
                        if (row >= 0 && col >= 0)
                        {
                            var dr = self.dataTable[row];
                            if (create && !dr)
                            {
                                dr = self.dataTable[row] = {};
                                if (row > self._lastNonNullRow)
                                {
                                    self._lastNonNullRow = row
                                }
                            }
                            if (dr)
                            {
                                node = dr[col];
                                if (create && !node)
                                {
                                    node = dr[col] = {};
                                    if (col > self._lastNonNullColumn)
                                    {
                                        self._lastNonNullColumn = col
                                    }
                                }
                            }
                        }
                        else if (row === -1 && col >= 0)
                        {
                            node = self._columnDataArray[col];
                            if (create && !node)
                            {
                                node = self._columnDataArray[col] = {};
                                if (col > self._lastNonNullColumn)
                                {
                                    self._lastNonNullColumn = col
                                }
                            }
                        }
                        else if (row >= 0 && col === -1)
                        {
                            node = self._rowDataArray[row];
                            if (create && !node)
                            {
                                node = self._rowDataArray[row] = {};
                                if (col > self._lastNonNullColumn)
                                {
                                    self._lastNonNullColumn = col
                                }
                            }
                        }
                        else if (row === -1 && col === -1)
                        {
                            node = self._defaultDataNode;
                            if (create && !node)
                            {
                                node = self._defaultDataNode = {}
                            }
                        }
                        return node
                    };
                    CalcSourceModel.prototype._getExpr = function(row, col)
                    {
                        var node = this.getNode(row, col);
                        return (node && node.expr)
                    };
                    CalcSourceModel.prototype.getExpr = function(row, col)
                    {
                        return this._getExpr(row, col)
                    };
                    CalcSourceModel.prototype.getArray = function(row, col)
                    {
                        return this._getArrayInfo(row, col)
                    };
                    CalcSourceModel.prototype.clear = function(row, column, rowCount, columnCount)
                    {
                        this._clear(row, column, rowCount, columnCount)
                    };
                    CalcSourceModel.prototype.addRows = function(row, count)
                    {
                        var self = this;
                        var rowCount = self.rC();
                        if (row < 0 || row > rowCount || count < 0)
                        {
                            return
                        }
                        Sheets._ModelHelper.addElements(self.dataTable, rowCount, row, count);
                        Sheets._ModelHelper.addElements(self._rowDataArray, rowCount, row, count);
                        for (var i = 0; i < count; i++)
                        {
                            self.dataTable[row + i] = {rs: "n"}
                        }
                    };
                    CalcSourceModel.prototype.deleteRows = function(row, count)
                    {
                        var self = this;
                        var n = self.rC();
                        if (row < 0 || row >= n || count <= 0)
                        {
                            return
                        }
                        if (row + count > n)
                        {
                            count = n - row
                        }
                        Sheets._ModelHelper.deleteElements(self.dataTable, n, row, count);
                        Sheets._ModelHelper.deleteElements(self._rowDataArray, n, row, count)
                    };
                    CalcSourceModel.prototype.addColumns = function(col, count)
                    {
                        var self = this;
                        var rowCount = self.rC(),
                            colCount = self.cC();
                        if (col < 0 || col > colCount || count < 0)
                        {
                            return
                        }
                        for (var i = 0; i < rowCount; i++)
                        {
                            var tr = self.dataTable[i];
                            if (tr && col < colCount)
                            {
                                Sheets._ModelHelper.addElements(tr, colCount, col, count)
                            }
                        }
                        Sheets._ModelHelper.addElements(this._columnDataArray, colCount, col, count)
                    };
                    CalcSourceModel.prototype.deleteColumns = function(col, count)
                    {
                        var self = this;
                        var rowCount = self.rC(),
                            colCount = self.cC();
                        if (col < 0 || col >= colCount || count < 0)
                        {
                            return
                        }
                        for (var i = 0; i < rowCount; i++)
                        {
                            var tr = this.dataTable[i];
                            if (tr && col < colCount)
                            {
                                Sheets._ModelHelper.deleteElements(tr, colCount, col, count)
                            }
                        }
                        Sheets._ModelHelper.deleteElements(this._columnDataArray, colCount, col, count)
                    };
                    CalcSourceModel.prototype._setExpr = function(row, col, expr)
                    {
                        var node = this.getNode(row, col, true);
                        node.expr = expr
                    };
                    CalcSourceModel.prototype._clearAllExpr = function(row, col)
                    {
                        var node = this.getNode(row, col, true);
                        if (node)
                        {
                            node.expr = keyword_undefined;
                            if (node.workingExpr)
                            {
                                node.workingExpr = keyword_undefined
                            }
                            if (node.arrayInfo)
                            {
                                node.arrayInfo = keyword_undefined
                            }
                            if (node.isVolatile)
                            {
                                this._removeVolatile(node)
                            }
                        }
                    };
                    CalcSourceModel.prototype._copyExpr = function(dest, row, col, desRow, desCol)
                    {
                        var node = this.getNode(row, col);
                        if (node && node.expr)
                        {
                            var destNode = dest.getNode(desRow, desCol, true);
                            if (node.arrayInfo)
                            {
                                destNode.arrayInfo = new Sheets.Range(desRow, desCol, node.arrayInfo.rowCount - (row - node.arrayInfo.row), node.arrayInfo.colCount - (col - node.arrayInfo.col))
                            }
                            destNode.expr = node.expr;
                            if (node.workingExpr)
                            {
                                destNode.workingExpr = node.workingExpr
                            }
                        }
                        if (node && node.isVolatile)
                        {
                            destNode.isVolatile = true
                        }
                    };
                    CalcSourceModel.prototype._containsNoe = function(row, col)
                    {
                        var dt = this.dataTable;
                        var dr = dt[row];
                        return dr && dr[col]
                    };
                    CalcSourceModel.prototype._getWorkingExpr = function(row, col)
                    {
                        var node = this.getNode(row, col);
                        return (node && node.workingExpr)
                    };
                    CalcSourceModel.prototype._setWorkingExpr = function(row, col, expr)
                    {
                        var node = this.getNode(row, col, true);
                        node.workingExpr = expr
                    };
                    CalcSourceModel.prototype._getArrayInfo = function(row, col)
                    {
                        var node = this.getNode(row, col);
                        return (node && node.arrayInfo)
                    };
                    CalcSourceModel.prototype._setArrayInfo = function(row, col, arrayInfo)
                    {
                        var node = this.getNode(row, col, true);
                        node.arrayInfo = arrayInfo
                    };
                    CalcSourceModel.prototype._getCalc = function(row, col)
                    {
                        var node = this.getNode(row, col);
                        return (node && node.calc)
                    };
                    CalcSourceModel.prototype._setCalc = function(row, col, calc)
                    {
                        var node = this.getNode(row, col, true);
                        if (node)
                        {
                            if (node.calc && node.calc.isVolatile)
                            {
                                this._removeVolatile(node)
                            }
                            node.calc = calc
                        }
                    };
                    CalcSourceModel.prototype._setNode4Swap = function(or, oc, row, col, node)
                    {
                        var self = this;
                        if (row >= 0 && col >= 0)
                        {
                            var dr = self.dataTable[row];
                            if (!dr)
                            {
                                dr = self.dataTable[row] = {}
                            }
                            dr[col] = node;
                            if (node && node.calc)
                            {
                                delete node.calc
                            }
                        }
                        else if (row >= 0 && col === -1 && or >= 0 && oc === -1)
                        {
                            self._rowDataArray[row] = node
                        }
                        else if (col >= 0 && row === -1 && oc >= 0 && or === -1)
                        {
                            self._columnDataArray[col] = node
                        }
                    };
                    CalcSourceModel.prototype._swapNode = function(row, col, row2, col2)
                    {
                        var self = this;
                        var node = self.getNode(row, col);
                        var node2 = self.getNode(row2, col2);
                        if (node)
                        {
                            self._setNode4Swap(row, col, row2, col2, node)
                        }
                        else if (node2)
                        {
                            self._setNode4Swap(row, col, row2, col2, keyword_null)
                        }
                        if (node2)
                        {
                            self._setNode4Swap(row2, col2, row, col, node2)
                        }
                        else if (node)
                        {
                            self._setNode4Swap(row2, col2, row, col, keyword_null)
                        }
                    };
                    CalcSourceModel.prototype._getAllVolatitles = function()
                    {
                        return this._volatitleCells
                    };
                    CalcSourceModel.prototype._setVolatile = function(calc)
                    {
                        if (!calc.isVolatile)
                        {
                            calc.isVolatile = true;
                            this._volatitleCells.push(calc)
                        }
                    };
                    CalcSourceModel.prototype._removeVolatile = function(calc)
                    {
                        calc.isVolatile = undefined;
                        var caches = this._volatitleCells,
                            length = caches.length;
                        for (var i = 0; i < length; i++)
                        {
                            if (caches[i] === calc)
                            {
                                caches.splice(i, 1);
                                return
                            }
                        }
                    };
                    CalcSourceModel.prototype._clearCore = function(nodes, type)
                    {
                        for (var i = 0; i < nodes.length; i++)
                        {
                            var node = nodes[i];
                            if (node)
                            {
                                if ((type & 1) > 0)
                                {
                                    if (node.arrayInfo)
                                    {
                                        node.arrayInfo = keyword_undefined
                                    }
                                    if (node.expr)
                                    {
                                        node.expr = keyword_undefined
                                    }
                                    if (node.workingExpr)
                                    {
                                        node.workingExpr = keyword_undefined
                                    }
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype.getCalcService = function()
                    {
                        return this._service
                    };
                    CalcSourceModel.prototype.hasFormula = function(row, col)
                    {
                        row = row !== keyword_undefined ? row : -1;
                        col = col !== keyword_undefined ? col : -1;
                        return !!this.getExpression(row, col)
                    };
                    CalcSourceModel.prototype.setFormula = function(row, col, formula, ignoreError)
                    {
                        var self = this;
                        if (formula && formula.length === 0)
                        {
                            formula = keyword_null
                        }
                        if (!ignoreError && self._intersectWithArrayFormula(row, col, 1, 1))
                        {
                            self._throwArrayPartException()
                        }
                        ;
                        var oldFormula = self.getFormula(row, col);
                        if ((oldFormula !== formula) && !((oldFormula === "" && !formula) || (!oldFormula && formula === "")))
                        {
                            var svc = self.getCalcService();
                            var expr = keyword_null;
                            if (svc)
                            {
                                try
                                {
                                    var expr = formula ? svc.parse(self.source, formula, row >= 0 ? row : 0, col >= 0 ? col : 0, ignoreError) : keyword_null;
                                    self.setExpression(row, col, expr, keyword_undefined, false)
                                }
                                catch(ex)
                                {
                                    if (!ignoreError)
                                    {
                                        throw ex;
                                    }
                                }
                            }
                            if (row >= 0 && col >= 0)
                            {
                                var isDefaultCulture = Sheets.Culture() === "" || Sheets.Culture() === "en-us";
                                self.source.setFormula(row, col, (ignoreError || isDefaultCulture) ? formula : svc.unparseWithoutCulture(self.source, expr, row, col, true))
                            }
                        }
                    };
                    CalcSourceModel.prototype.getFormula = function(row, col)
                    {
                        var svc = this.getCalcService();
                        if (svc)
                        {
                            var expr = this.getExpression(row, col);
                            if (expr)
                            {
                                var arrayInfo = this.getArrayInfo(row, col);
                                row = arrayInfo ? arrayInfo.row : row;
                                col = arrayInfo ? arrayInfo.col : col;
                                return svc.unparse(this.source, expr, row, col)
                            }
                        }
                        return keyword_null
                    };
                    CalcSourceModel.prototype._throwArrayPartException = function()
                    {
                        throw Sheets.SR.Exp_ArrayFromulaPart;
                    };
                    CalcSourceModel.prototype.rC = function()
                    {
                        return this.source.getRowCount()
                    };
                    CalcSourceModel.prototype.cC = function()
                    {
                        return this.source.getColumnCount()
                    };
                    CalcSourceModel.prototype.setArrayFormula = function(row, col, rowCount, colCount, formula, ignoreError)
                    {
                        var self = this;
                        if (formula && formula.length === 0)
                        {
                            formula = keyword_null
                        }
                        if (self._intersectWithArrayFormula(row, col, rowCount, colCount))
                        {
                            self._throwArrayPartException()
                        }
                        row = row < 0 ? 0 : row;
                        col = col < 0 ? 0 : col;
                        var svc = self.getCalcService();
                        if (!svc)
                        {
                            return
                        }
                        self._clear(row, col, rowCount, colCount);
                        if (!formula)
                        {
                            return
                        }
                        try
                        {
                            var expr = formula ? svc.parse(self.source, formula, row, col) : keyword_null
                        }
                        catch(ex)
                        {
                            if (!ignoreError)
                            {
                                throw ex;
                            }
                            return
                        }
                        for (var rowIndex = row; rowIndex < row + rowCount; rowIndex++)
                        {
                            for (var colIndex = col; colIndex < col + colCount; colIndex++)
                            {
                                self.setExpression(rowIndex, colIndex, expr, new Sheets.Range(row, col, rowCount, colCount), false)
                            }
                        }
                        if (row >= 0 && col >= 0)
                        {
                            self.source.setArrayFormula(row, col, rowCount, colCount, svc.unparseWithoutCulture(self.source, expr, row, col, true))
                        }
                    };
                    CalcSourceModel.prototype.getExprInfo = function(row, col, type)
                    {
                        var self = this;
                        var result = keyword_null,
                            node,
                            source = self.source;
                        if (row > source.getRowCount() || col >= source.getColumnCount())
                        {
                            return result
                        }
                        if (row >= 0 && col >= 0)
                        {
                            node = self.getNode(row, col);
                            result = node && node[type];
                            if (!result)
                            {
                                node = self.getNode(row, -1);
                                result = node && node[type]
                            }
                            if (!result && col < self.cC())
                            {
                                node = self.getNode(-1, col);
                                result = node && node[type]
                            }
                        }
                        else if (row >= 0 && col === -1)
                        {
                            node = self.getNode(row, -1);
                            result = node && node[type]
                        }
                        else if (row === -1 && col >= 0)
                        {
                            node = self.getNode(-1, col);
                            result = node && node[type]
                        }
                        else
                        {
                            node = self.getNode(-1, -1);
                            result = node && node[type]
                        }
                        return result
                    };
                    CalcSourceModel.prototype.getArrayInfo = function(row, col)
                    {
                        return this.getExprInfo(row, col, const_arrayInfo)
                    };
                    CalcSourceModel.prototype.getWorkingExpression = function(row, col)
                    {
                        return this.getExprInfo(row, col, const_workingExpr)
                    };
                    CalcSourceModel.prototype.getExpression = function(row, col)
                    {
                        return this.getExprInfo(row, col, const_expr)
                    };
                    CalcSourceModel.prototype.setExpression = function(row, col, expr, baseRange, updateModel)
                    {
                        var self = this;
                        var svc = self.getCalcService();
                        var isArrayFormula = baseRange !== keyword_undefined && baseRange !== null;
                        var context = new EvaluateContext(self.source, isArrayFormula, isArrayFormula ? baseRange.row : row, isArrayFormula ? baseRange.col : col);
                        var workingExpr = Expressions._mappingArray(context, expr, isArrayFormula, isArrayFormula ? row - baseRange.row : 0, isArrayFormula ? col - baseRange.col : 0);
                        workingExpr = workingExpr === expr ? keyword_undefined : workingExpr;
                        var arrayInfo;
                        if (baseRange !== keyword_undefined)
                        {
                            arrayInfo = baseRange
                        }
                        if (row >= 0 && col >= 0)
                        {
                            if (updateModel === keyword_undefined || updateModel)
                            {
                                var formula = expr ? svc.unparseWithoutCulture(self.source, expr, row >= 0 ? row : 0, col >= 0 ? col : 0, true) : keyword_undefined;
                                self.source.setFormula(row, col, formula)
                            }
                            self._setCellExpression(row, col, expr, workingExpr, arrayInfo)
                        }
                        else if (row >= 0 && col === -1)
                        {
                            self._setRowExpression(row, expr, workingExpr)
                        }
                        else if (row === -1 && col >= 0)
                        {
                            self._setColumnExpression(col, expr, workingExpr)
                        }
                        if (svc.autoCalculation && !svc.IsSuspended())
                        {
                            svc.recalculateAll(false)
                        }
                    };
                    CalcSourceModel.prototype.getRowExpression = function(row)
                    {
                        return this.getExpression(row, -1)
                    };
                    CalcSourceModel.prototype.getColumnExpression = function(column)
                    {
                        return this.getExpression(-1, column)
                    };
                    CalcSourceModel.prototype._setCellExpression = function(row, col, value, workingExpr, arrayInfo)
                    {
                        var self = this;
                        var cellCalc;
                        if (arrayInfo)
                        {
                            cellCalc = self._getCellCalc(row, col, true)
                        }
                        else
                        {
                            cellCalc = self._getCellCalc(row, col, true)
                        }
                        if (cellCalc)
                        {
                            cellCalc.stopListening();
                            self._setExpr(row, col, value);
                            if (value)
                            {
                                if (workingExpr || self._getWorkingExpr(row, col))
                                {
                                    self._setWorkingExpr(row, col, workingExpr)
                                }
                                if (arrayInfo || self.getArrayInfo(row, col))
                                {
                                    self._setArrayInfo(row, col, arrayInfo)
                                }
                            }
                            else
                            {
                                self._setWorkingExpr(row, col, keyword_undefined);
                                self._setArrayInfo(row, col, keyword_undefined)
                            }
                            cellCalc.startListening();
                            self._service.addDirty(cellCalc, 0)
                        }
                    };
                    CalcSourceModel.prototype._setRowExpression = function(row, value, workingExpr)
                    {
                        var self = this;
                        var rowCalc = self._getRowCalc(row, true);
                        if (rowCalc)
                        {
                            rowCalc.stopListening();
                            self._setExpr(row, -1, value);
                            if (workingExpr || self._getWorkingExpr(row, -1))
                            {
                                self._setWorkingExpr(row, -1, workingExpr)
                            }
                            rowCalc.startListening();
                            self._service.addDirty(rowCalc, 1)
                        }
                    };
                    CalcSourceModel.prototype._setColumnExpression = function(column, value, workingExpr)
                    {
                        var self = this;
                        var columnCalc = self._getColumnCalc(column, true);
                        if (columnCalc)
                        {
                            columnCalc.stopListening();
                            self._setExpr(-1, column, value);
                            if (workingExpr || self._getWorkingExpr(-1, column))
                            {
                                self._setWorkingExpr(-1, column, workingExpr)
                            }
                            columnCalc.startListening();
                            self._service.addDirty(columnCalc, 2)
                        }
                    };
                    CalcSourceModel.prototype._clear = function(row, col, rowCount, colCount)
                    {
                        var self = this;
                        var row1 = row < 0 ? 0 : row;
                        var col1 = col < 0 ? 0 : col;
                        var rowCount1 = row < 0 ? self.rC() : rowCount;
                        var colCount1 = col < 0 ? self.cC() : colCount;
                        var row2 = row1 + rowCount1 - 1;
                        var col2 = col1 + colCount1 - 1;
                        var svc = self.getCalcService();
                        var hasPart = false;
                        var ranges = [],
                            formulas = [];
                        var workingExpr,
                            expr,
                            arrayInfo;
                        for (var r = row1; r <= row2 && r >= 0; r++)
                        {
                            for (var c = col1; c <= col2 && c >= 0; c++)
                            {
                                workingExpr = self._getWorkingExpr(r, c);
                                expr = self._getExpr(r, c);
                                if (workingExpr || expr)
                                {
                                    arrayInfo = self._getArrayInfo(r, c);
                                    var baseRange = arrayInfo ? new Sheets.Range(arrayInfo.row, arrayInfo.col, arrayInfo.rowCount, arrayInfo.colCount) : keyword_undefined;
                                    self.setExpression(r, c, keyword_null, baseRange, true)
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype._intersectWithArrayFormula = function(row, col, rowCount, colCount)
                    {
                        return this._getFormulaExps(row, col, rowCount, colCount, true, true)
                    };
                    CalcSourceModel.prototype._getFormulaExps = function(row, col, rowCount, colCount, testIntersect, onlyArrayFormula)
                    {
                        var self = this;
                        var row1 = row < 0 ? 0 : row;
                        var col1 = col < 0 ? 0 : col;
                        var rowCount1 = row < 0 ? self.rC() : rowCount;
                        var colCount1 = col < 0 ? self.cC() : colCount;
                        var row2 = row1 + (rowCount1 === 0 ? 1 : rowCount1) - 1;
                        var col2 = col1 + (colCount1 === 0 ? 1 : colCount1) - 1;
                        var svc = self.getCalcService();
                        var hasPart = false;
                        var ranges = [],
                            formulas = [],
                            node,
                            dr,
                            dataTable = self.dataTable;
                        for (var r = row1; r <= row2 && r >= 0; r++)
                        {
                            if (r > self._lastNonNullRow)
                            {
                                break
                            }
                            dr = dataTable[r];
                            if (!dr)
                            {
                                continue
                            }
                            for (var c = col1; c <= col2 && c >= 0; c++)
                            {
                                if (c > self._lastNonNullColumn)
                                {
                                    break
                                }
                                node = dr[c];
                                if (node)
                                {
                                    var array = node.arrayInfo,
                                        expr;
                                    if (array)
                                    {
                                        if (array.row < row1 || array.row + array.rowCount - 1 > row2 || array.col < col1 || array.col + array.colCount - 1 > col2)
                                        {
                                            if (testIntersect)
                                            {
                                                return true
                                            }
                                            hasPart = true
                                        }
                                        if (r !== array.row && r !== row1)
                                        {
                                            continue
                                        }
                                        ranges.push(new Sheets.Range(array.row, array.col, array.rowCount, array.colCount));
                                        expr = node.expr;
                                        formulas.push(expr);
                                        c = array.col + array.colCount - 1
                                    }
                                    else if (!onlyArrayFormula && (expr = node.expr))
                                    {
                                        ranges.push({
                                            row: r, col: c
                                        });
                                        formulas.push(expr)
                                    }
                                }
                            }
                        }
                        if (testIntersect)
                        {
                            return false
                        }
                        return {
                                hasPart: hasPart, ranges: ranges, formulas: formulas
                            }
                    };
                    CalcSourceModel.prototype._getCellCalc = function(row, col, create)
                    {
                        var self = this;
                        var cell = keyword_null;
                        if (row >= 0 && col >= 0)
                        {
                            var dataTable = self.dataTable;
                            var dr = dataTable[row];
                            if (!dr)
                            {
                                if (create)
                                {
                                    dr = dataTable[row] = {};
                                    if (row > self._lastNonNullRow)
                                    {
                                        self._lastNonNullRow = row
                                    }
                                }
                                else
                                {
                                    return cell
                                }
                            }
                            var dc = dr[col];
                            if (!dc)
                            {
                                if (create)
                                {
                                    dc = dr[col] = {};
                                    cell = new CellCalc(self, row, col);
                                    dc.calc = cell;
                                    if (col > self._lastNonNullColumn)
                                    {
                                        self._lastNonNullColumn = col
                                    }
                                }
                                return cell
                            }
                            cell = dc.calc;
                            if (!cell && create)
                            {
                                cell = new CellCalc(self, row, col);
                                dc.calc = cell;
                                if (row > self._lastNonNullRow)
                                {
                                    self._lastNonNullRow = row
                                }
                                if (col > self._lastNonNullColumn)
                                {
                                    self._lastNonNullColumn = col
                                }
                            }
                        }
                        return cell
                    };
                    CalcSourceModel.prototype._getRowCalc = function(row, create)
                    {
                        var self = this;
                        var calc = keyword_null;
                        if (row >= 0)
                        {
                            var calc = self._getCalc(row, -1);
                            if (!calc && create)
                            {
                                calc = new RowCalc(self, row);
                                self._setCalc(row, -1, calc);
                                if (row > self._lastNonNullRow)
                                {
                                    self._lastNonNullRow = row
                                }
                            }
                        }
                        return calc
                    };
                    CalcSourceModel.prototype._getColumnCalc = function(column, create)
                    {
                        var self = this;
                        var calc = keyword_null;
                        if (column >= 0)
                        {
                            var calc = self._getCalc(-1, column);
                            if (!calc && create)
                            {
                                calc = new ColumnCalc(self, column);
                                self._setCalc(-1, column, calc);
                                if (column > self._lastNonNullColumn)
                                {
                                    self._lastNonNullColumn = column
                                }
                            }
                        }
                        return calc
                    };
                    CalcSourceModel.prototype._getRangeCalc = function(create)
                    {
                        var self = this;
                        if (!self._rangeCalc && create)
                        {
                            self._rangeCalc = new RangeCalc(self)
                        }
                        return self._rangeCalc
                    };
                    CalcSourceModel.prototype._getNameCalc = function(name, create)
                    {
                        var self = this;
                        var nameCalc = keyword_null,
                            calcModel;
                        if (!self._nameCalcs)
                        {
                            self._nameCalcs = {}
                        }
                        nameCalc = self._nameCalcs[name];
                        if (!nameCalc && create)
                        {
                            nameCalc = self._nameCalcs[name] = new NameCalc(name)
                        }
                        return nameCalc
                    };
                    CalcSourceModel.prototype._addColumnsToDirty = function(col, colCount)
                    {
                        var self = this;
                        for (var c = col; c !== -1 && c < col + colCount; c++)
                        {
                            if (!self.isDirty(-1, c))
                            {
                                continue
                            }
                            var columnCalc = self._getColumnCalc(c, true);
                            self._service.addDirty(columnCalc, 2)
                        }
                    };
                    CalcSourceModel.prototype._addRowsToDirty = function(row, rowCount)
                    {
                        var self = this;
                        for (var r = row; r !== -1 && r < row + rowCount; r++)
                        {
                            if (!self.isDirty(r, -1))
                            {
                                continue
                            }
                            var rowCalc = self._getRowCalc(r, true);
                            self._service.addDirty(rowCalc, 1)
                        }
                    };
                    CalcSourceModel.prototype._addCellsToDirty = function(row, col, rowCount, colCount)
                    {
                        var self = this;
                        var endRow = row + rowCount,
                            endCol = col + colCount;
                        for (var r = row; r < endRow; r++)
                        {
                            for (var c = col; c < endCol; c++)
                            {
                                if (!self._containsNoe(r, c))
                                {
                                    continue
                                }
                                var cellCalc = self._getCellCalc(r, c, true);
                                self._service.addDirty(cellCalc, 0)
                            }
                        }
                        self._addRowsToDirty(row, rowCount);
                        self._addColumnsToDirty(col, colCount);
                        var rangesCalc = self._getRangeCalc(false);
                        if (rangesCalc)
                        {
                            rangesCalc.addListenersToDirty(row, col, rowCount, colCount)
                        }
                    };
                    CalcSourceModel.prototype._addVolatitlesToDirty = function()
                    {
                        var self = this,
                            volatiles = self._getAllVolatitles(),
                            rowCalc,
                            colCalc;
                        for (var volatileIndex = 0; volatileIndex < volatiles.length; volatileIndex++)
                        {
                            var volatiCalc = volatiles[volatileIndex];
                            if (volatiCalc && (volatiCalc instanceof CellCalc) && !self._service.isDirtyCell(volatiCalc))
                            {
                                var cellCalc = self._getCellCalc(volatiCalc.row, volatiCalc.column, true);
                                self._service.addDirty(cellCalc, 0);
                                rowCalc = self._getRowCalc(volatiCalc.row, false);
                                if (rowCalc && !self._service.isDirtyRow(rowCalc))
                                {
                                    self._addRowsToDirty(volatiCalc.row, 1)
                                }
                                colCalc = self._getColumnCalc(volatiCalc.column, false);
                                if (colCalc && !self._service.isDirtyRow(colCalc))
                                {
                                    self._addColumnsToDirty(volatiCalc.column, 1)
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype.isDirty = function(row, col)
                    {
                        return !!(this._getCalc(row, col) || this._getExpr(row, col))
                    };
                    CalcSourceModel.prototype.recalculateCell = function(row, column)
                    {
                        var self = this,
                            source = self.source;
                        var expr = (self.getWorkingExpression(row, column) || self.getExpression(row, column));
                        if (expr)
                        {
                            var oldValue = source.getValue(row, column);
                            var isArrayFormula = false,
                                baseRow,
                                baseCol,
                                rowCount,
                                colCount;
                            var arrayInfo = self.getArrayInfo(row, column);
                            if (arrayInfo)
                            {
                                isArrayFormula = true;
                                baseRow = arrayInfo.row;
                                baseCol = arrayInfo.col;
                                rowCount = arrayInfo.rowCount;
                                colCount = arrayInfo.colCount
                            }
                            var value = self._service.evaluateParsedFormula(self.source, expr, row, column, isArrayFormula, true, baseRow, baseCol, rowCount, colCount);
                            if (oldValue === value)
                            {
                                return
                            }
                            else if ((oldValue instanceof Date) && (value instanceof Date))
                            {
                                if (oldValue.valueOf() === value.valueOf())
                                {
                                    return
                                }
                            }
                            source.setValue(row, column, value)
                        }
                    };
                    CalcSourceModel.prototype._dealWithExpression = function(exprCalc, row, column, expr, isAdd)
                    {
                        var self = this;
                        while (expr.t === 24)
                        {
                            expr = expr.expr
                        }
                        while (expr.t === 14)
                        {
                            expr = expr.argument
                        }
                        if (expr.t === 17)
                        {
                            var cellRange = expr.getRange(row, column, true);
                            if (cellRange === keyword_null)
                            {
                                return
                            }
                            if (cellRange.rowCount === 1 && cellRange.columnCount === 1)
                            {
                                expr = new Expressions.CellExpression(cellRange.row, cellRange.column, false, false)
                            }
                            else
                            {
                                expr = new Expressions.RangeExpression(cellRange.row, cellRange.column, cellRange.row + cellRange.rowCount - 1, cellRange.column + cellRange.columnCount - 1, false, false, false, false)
                            }
                        }
                        var refRow,
                            refColumn,
                            refStartRow,
                            refEndRow,
                            refStartColumn,
                            refEndColumn,
                            refRowCount,
                            refColumnCount,
                            refCellCalc,
                            refRowCalc,
                            refColumnCalc,
                            r,
                            c,
                            sheetSource,
                            calcModel;
                        if (expr.t === 0 || expr.t === 1)
                        {
                            var cellExpr = expr;
                            sheetSource = expr.source || self.source;
                            calcModel = sheetSource.calcSourceModel;
                            if (0 <= row && 0 <= column)
                            {
                                refRow = cellExpr.row + (cellExpr.rowRelative ? row : 0);
                                refColumn = cellExpr.column + (cellExpr.columnRelative ? column : 0);
                                refCellCalc = calcModel._getCellCalc(refRow, refColumn, true);
                                if (!refCellCalc)
                                {
                                    return
                                }
                                refCellCalc.processCellListener(exprCalc, isAdd)
                            }
                            else if (0 <= row && column === -1)
                            {
                                refRow = cellExpr.row + (cellExpr.rowRelative ? row : 0);
                                refColumn = cellExpr.column;
                                if (cellExpr.columnRelative)
                                {
                                    refRowCalc = calcModel._getRowCalc(refRow, true);
                                    if (!refRowCalc)
                                    {
                                        return
                                    }
                                    refRowCalc.processRowListener2(exprCalc, -refColumn, isAdd)
                                }
                                else
                                {
                                    refCellCalc = calcModel._getCellCalc(refRow, refColumn, true);
                                    if (!refCellCalc)
                                    {
                                        return
                                    }
                                    refCellCalc.processRowListener(exprCalc, isAdd)
                                }
                            }
                            else if (row === -1 && 0 <= column)
                            {
                                refRow = cellExpr.row;
                                refColumn = cellExpr.column + (cellExpr.columnRelative ? column : 0);
                                if (cellExpr.rowRelative)
                                {
                                    refColumnCalc = calcModel._getColumnCalc(refColumn, true);
                                    if (!refColumnCalc)
                                    {
                                        return
                                    }
                                    refColumnCalc.processColumnListener2(exprCalc, -refRow, isAdd)
                                }
                                else
                                {
                                    refCellCalc = calcModel._getCellCalc(refRow, refColumn, true);
                                    if (!refCellCalc)
                                    {
                                        return
                                    }
                                    refCellCalc.processColumnListener(exprCalc, isAdd)
                                }
                            }
                        }
                        else if (expr.t === 2 || expr.t === 3)
                        {
                            sheetSource = expr.source || self.source;
                            calcModel = sheetSource.calcSourceModel;
                            var rangeExpr = expr;
                            var refRangeType = rangeExpr._getRangeType();
                            if (refRangeType === RangeType.cell)
                            {
                                if (0 <= row && 0 <= column)
                                {
                                    refStartRow = rangeExpr.startRow + (rangeExpr.startRowRelative ? row : 0);
                                    refStartColumn = rangeExpr.startColumn + (rangeExpr.startColumnRelative ? column : 0);
                                    refEndRow = rangeExpr.endRow + (rangeExpr.endRowRelative ? row : 0);
                                    refEndColumn = rangeExpr.endColumn + (rangeExpr.endColumnRelative ? column : 0);
                                    refRowCount = Math_abs(refEndRow - refStartRow) + 1;
                                    refColumnCount = Math_abs(refEndColumn - refStartColumn) + 1;
                                    if (self.shouldUseRange(refRow, refColumn, refRowCount, refColumnCount))
                                    {
                                        var rangeCalc = calcModel._getRangeCalc(true);
                                        if (!rangeCalc)
                                        {
                                            return
                                        }
                                        rangeCalc.processCellListener(refStartRow, refStartColumn, refRowCount, refColumnCount, exprCalc, isAdd)
                                    }
                                    else
                                    {
                                        for (r = refStartRow; r <= refEndRow; r++)
                                        {
                                            for (c = refStartColumn; c <= refEndColumn; c++)
                                            {
                                                refCellCalc = calcModel._getCellCalc(r, c, true);
                                                if (refCellCalc)
                                                {
                                                    refCellCalc.processCellListener(exprCalc, isAdd)
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (0 <= row && column === -1)
                                {
                                    refStartRow = rangeExpr.startRow + (rangeExpr.startRowRelative ? row : 0);
                                    refStartColumn = rangeExpr.startColumn + (rangeExpr.startColumnRelative ? column : 0);
                                    refEndRow = rangeExpr.endRow + (rangeExpr.endRowRelative ? row : 0);
                                    refEndColumn = rangeExpr.endColumn + (rangeExpr.endColumnRelative ? column : 0);
                                    for (r = refStartRow; r <= refEndRow; r++)
                                    {
                                        for (c = refStartColumn; c <= refEndColumn; c++)
                                        {
                                            if (rangeExpr.startColumnRelative || rangeExpr.endColumnRelative)
                                            {
                                                refRowCalc = calcModel._getRowCalc(r, true);
                                                if (refRowCalc)
                                                {
                                                    refRowCalc.processRowListener2(exprCalc, -c, isAdd)
                                                }
                                            }
                                            else
                                            {
                                                refCellCalc = calcModel._getCellCalc(r, c, true);
                                                if (refCellCalc)
                                                {
                                                    refCellCalc.processRowListener(exprCalc, isAdd)
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (row === -1 && 0 <= column)
                                {
                                    refStartRow = rangeExpr.startRow + (rangeExpr.startRowRelative ? row : 0);
                                    refStartColumn = rangeExpr.startColumn + (rangeExpr.startColumnRelative ? column : 0);
                                    refEndRow = rangeExpr.endRow + (rangeExpr.endRowRelative ? row : 0);
                                    refEndColumn = rangeExpr.endColumn + (rangeExpr.endColumnRelative ? column : 0);
                                    for (r = refStartRow; r <= refEndRow; r++)
                                    {
                                        for (c = refStartColumn; c <= refEndColumn; c++)
                                        {
                                            if (rangeExpr.startRowRelative || rangeExpr.endRowRelative)
                                            {
                                                refColumnCalc = calcModel._getColumnCalc(c, true);
                                                if (refColumnCalc)
                                                {
                                                    refColumnCalc.processColumnListener2(exprCalc, -r, isAdd)
                                                }
                                            }
                                            else
                                            {
                                                refCellCalc = calcModel._getCellCalc(r, c, true);
                                                if (refCellCalc)
                                                {
                                                    refCellCalc.processColumnListener(exprCalc, isAdd)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (refRangeType === RangeType.row)
                            {
                                if (0 <= row && 0 <= column)
                                {
                                    refStartRow = rangeExpr.startRow + (rangeExpr.startRowRelative ? row : 0);
                                    refEndRow = rangeExpr.endRow + (rangeExpr.endRowRelative ? row : 0);
                                    for (r = refStartRow; r <= refEndRow; r++)
                                    {
                                        refRowCalc = calcModel._getRowCalc(r, true);
                                        if (refRowCalc)
                                        {
                                            refRowCalc.processCellListener(exprCalc, isAdd)
                                        }
                                    }
                                }
                                else if (0 <= row && column === -1)
                                {}
                                else if (row === -1 && 0 <= column)
                                {
                                    if (rangeExpr.startRowRelative || rangeExpr.endRowRelative)
                                    {}
                                    else
                                    {
                                        refStartRow = rangeExpr.startRow;
                                        refEndRow = rangeExpr.endRow;
                                        for (r = refStartRow; r <= refEndRow; r++)
                                        {
                                            refRowCalc = calcModel._getRowCalc(r, true);
                                            if (refRowCalc)
                                            {
                                                refRowCalc.processColumnListener(exprCalc, isAdd)
                                            }
                                        }
                                    }
                                }
                            }
                            else if (refRangeType === RangeType.column)
                            {
                                if (0 <= row && 0 <= column)
                                {
                                    refStartColumn = rangeExpr.startColumn + (rangeExpr.startColumnRelative ? column : 0);
                                    refEndColumn = rangeExpr.endColumn + (rangeExpr.endColumnRelative ? column : 0);
                                    for (c = refStartColumn; c <= refEndColumn; c++)
                                    {
                                        refColumnCalc = calcModel._getColumnCalc(c, true);
                                        if (refColumnCalc)
                                        {
                                            refColumnCalc.processCellListener(exprCalc, isAdd)
                                        }
                                    }
                                }
                                else if (0 <= row && column === -1)
                                {}
                                else if (row === -1 && 0 <= column)
                                {
                                    refStartColumn = rangeExpr.startColumn + (rangeExpr.startColumnRelative ? column : 0);
                                    refEndColumn = rangeExpr.endColumn + (rangeExpr.endColumnRelative ? column : 0);
                                    for (c = refStartColumn; c <= refEndColumn; c++)
                                    {
                                        refColumnCalc = calcModel._getColumnCalc(c, true);
                                        if (refColumnCalc)
                                        {
                                            refColumnCalc.processColumnListener(exprCalc, isAdd)
                                        }
                                    }
                                }
                            }
                            else if (refRangeType === RangeType.sheet)
                            {
                                if (0 <= row && 0 <= column)
                                {}
                                else if (0 <= row && column === -1)
                                {}
                                else if (row === -1 && 0 <= column)
                                {}
                            }
                        }
                        else if (expr.t === 16)
                        {
                            var sheetRangeExpr = expr;
                            var sources = sheetRangeExpr.startSource.getSources(sheetRangeExpr.endSource);
                            for (var i = 0; i < sources.length; i++)
                            {
                                var subExpr = new Expressions.ExternalRangeExpression(sources[i], sheetRangeExpr.startRow, sheetRangeExpr.startColumn, sheetRangeExpr.endRow, sheetRangeExpr.endColumn, sheetRangeExpr.startRowRelative, sheetRangeExpr.startColumnRelative, sheetRangeExpr.endRowRelative, sheetRangeExpr.endColumnRelative);
                                if (sheetRangeExpr.isFullRow)
                                {
                                    subExpr.initBand(sources[i], sheetRangeExpr.startRow, sheetRangeExpr.endRow, sheetRangeExpr.startRowRelative, sheetRangeExpr.endRowRelative, true)
                                }
                                else if (sheetRangeExpr.isFullColumn)
                                {
                                    subExpr.initBand(sources[i], sheetRangeExpr.startColumn, sheetRangeExpr.endColumn, sheetRangeExpr.startColumnRelative, sheetRangeExpr.endColumnRelative, false)
                                }
                                self._dealWithExpression(exprCalc, row, column, subExpr, isAdd)
                            }
                        }
                        else if (expr.t === 11)
                        {
                            self._dealWithExpression(exprCalc, row, column, expr.operand, isAdd)
                        }
                        else if (expr.t === 10)
                        {
                            self._dealWithExpression(exprCalc, row, column, expr.left, isAdd);
                            self._dealWithExpression(exprCalc, row, column, expr.right, isAdd)
                        }
                        else if (expr.t === 8 || expr.t === 9)
                        {
                            sheetSource = expr.source || self;
                            calcModel = sheetSource.calcSourceModel;
                            var refNameCalc = calcModel._getNameCalc(expr.name, true);
                            if (!refNameCalc)
                            {
                                return
                            }
                            refNameCalc.processCellListener(exprCalc, isAdd);
                            self._dealWithExpression(exprCalc, row, column, sheetSource.getCustomName(expr.name), isAdd)
                        }
                        else if (expr.t === 7)
                        {
                            var funcExpr = expr;
                            if (funcExpr.fn && (funcExpr.fn instanceof Calc.Functions.Function))
                            {
                                if (funcExpr.fn.isVolatile())
                                {
                                    if (isAdd)
                                    {
                                        self._setVolatile(exprCalc)
                                    }
                                    else
                                    {
                                        self._removeVolatile(exprCalc)
                                    }
                                }
                                if (!funcExpr.fn.precedentReference())
                                {
                                    return
                                }
                            }
                            var argCount = funcExpr.argCount();
                            for (var i = 0; i < argCount; i++)
                            {
                                self._dealWithExpression(exprCalc, row, column, funcExpr.getArg(i), isAdd)
                            }
                        }
                    };
                    CalcSourceModel.prototype.shouldUseRange = function(row, col, rowCount, colCount)
                    {
                        return (row === -1 && colCount > 127) || (col === -1 && rowCount > 127) || (rowCount * colCount > 127)
                    };
                    CalcSourceModel.prototype._dealWithCellExpression = function(row, column, rowCount, columnCount, isAdd)
                    {
                        var self = this;
                        var endRow = row + rowCount,
                            endCol = column + columnCount;
                        var workingExpr,
                            expr,
                            arrayInfo;
                        for (var r = row; r < endRow; r++)
                        {
                            for (var c = column; c < endCol; c++)
                            {
                                workingExpr = self._getWorkingExpr(r, c);
                                expr = self._getExpr(r, c);
                                if (workingExpr || expr)
                                {
                                    arrayInfo = self._getArrayInfo(r, c);
                                    if (arrayInfo)
                                    {
                                        self._dealWithExpression(self._getCellCalc(r, c), arrayInfo.row, arrayInfo.col, workingExpr || expr, isAdd)
                                    }
                                    else
                                    {
                                        self._dealWithExpression(self._getCellCalc(r, c), r, c, workingExpr || expr, isAdd)
                                    }
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype._dealWithColumnExpression = function(col, colCount, isAdd)
                    {
                        var endCol = col + colCount;
                        for (var c = col; c !== -1 && c < endCol; c++)
                        {
                            var expr = this.getColumnExpression(c);
                            if (expr)
                            {
                                this._dealWithExpression(this._getColumnCalc(c, false), -1, c, expr, isAdd)
                            }
                        }
                    };
                    CalcSourceModel.prototype.linkCellExpression = function(row, column, rowCount, columnCount)
                    {
                        this._dealWithCellExpression(row, column, rowCount, columnCount, true)
                    };
                    CalcSourceModel.prototype.unlinkCellExpression = function(row, column, rowCount, columnCount)
                    {
                        this._dealWithCellExpression(row, column, rowCount, columnCount, false)
                    };
                    CalcSourceModel.prototype.linkRowExpression = function(row, rowCount){};
                    CalcSourceModel.prototype.unlinkRowExpression = function(row, rowCount){};
                    CalcSourceModel.prototype.linkColumnExpression = function(col, colCount)
                    {
                        this._dealWithColumnExpression(col, colCount, true)
                    };
                    CalcSourceModel.prototype.unlinkColumnExpression = function(col, colCount)
                    {
                        this._dealWithColumnExpression(col, colCount, false)
                    };
                    CalcSourceModel.prototype._iterateEachCell = function(row, column, rowCount, columnCount, setAdjust, setDirty)
                    {
                        var endRow = row + rowCount,
                            endCol = column + columnCount;
                        for (var r = row; r < endRow; r++)
                        {
                            for (var c = column; c < endCol; c++)
                            {
                                var cellCalc = this._getCellCalc(r, c, false);
                                if (cellCalc)
                                {
                                    if (setAdjust)
                                    {
                                        cellCalc.addListenersToAdjust()
                                    }
                                    if (setDirty)
                                    {
                                        cellCalc.addListenersToDirty()
                                    }
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype._iterateEachRow = function(row, rowCount, setAdjust, setDirty)
                    {
                        var rowData = this._rowDataArray;
                        if (rowData)
                        {
                            for (var r = row; r !== -1 && r < row + rowCount && r < rowData.length; r++)
                            {
                                var node = rowData[r];
                                if (!node || !node.calc)
                                {
                                    continue
                                }
                                var rowCalc = node.calc;
                                if (setAdjust)
                                {
                                    rowCalc.addListenersToAdjust()
                                }
                                if (setDirty)
                                {
                                    rowCalc.addListenersToDirty()
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype._iterateEachColumn = function(column, columnCount, setAdjust, setDirty)
                    {
                        var columnData = this._columnDataArray;
                        if (columnData)
                        {
                            for (var c = column; c !== -1 && c < column + columnCount && c < columnData.length; c++)
                            {
                                var node = columnData[c];
                                if (!node || !node.calc)
                                {
                                    continue
                                }
                                var columnCalc = node.calc;
                                if (setAdjust)
                                {
                                    columnCalc.addListenersToAdjust()
                                }
                                if (setDirty)
                                {
                                    columnCalc.addListenersToDirty()
                                }
                            }
                        }
                    };
                    CalcSourceModel.prototype.addDependents = function(row, column, rowCount, columnCount, setAdjust, setDirty)
                    {
                        if (setAdjust || setDirty)
                        {
                            var self = this;
                            if (0 <= row && 0 <= column)
                            {
                                self._iterateEachCell(row, column, rowCount, columnCount, setAdjust, setDirty);
                                self._iterateEachRow(row, rowCount, setAdjust, setDirty);
                                self._iterateEachColumn(column, columnCount, setAdjust, setDirty);
                                if (self._rangeCalc)
                                {
                                    if (setAdjust)
                                    {
                                        self._rangeCalc.addListenersToAdjust(row, column, rowCount, columnCount)
                                    }
                                    if (setDirty)
                                    {
                                        self._rangeCalc.addListenersToDirty(row, column, rowCount, columnCount)
                                    }
                                }
                            }
                            else if (0 <= row && column === -1)
                            {
                                self._iterateEachCell(row, 0, rowCount, self.cC(), setAdjust, setDirty);
                                self._iterateEachRow(row, rowCount, setAdjust, setDirty);
                                if (self._rangeCalc)
                                {
                                    if (setAdjust)
                                    {
                                        self._rangeCalc.addListenersToAdjust(row, column, rowCount, columnCount)
                                    }
                                    if (setDirty)
                                    {
                                        self._rangeCalc.addListenersToDirty(row, column, rowCount, columnCount)
                                    }
                                }
                            }
                            else if (row === -1 && 0 <= column)
                            {
                                self._iterateEachCell(0, column, self.rC(), columnCount, setAdjust, setDirty);
                                self._iterateEachColumn(column, columnCount, setAdjust, setDirty);
                                if (self._rangeCalc)
                                {
                                    if (setAdjust)
                                    {
                                        self._rangeCalc.addListenersToAdjust(row, column, rowCount, columnCount)
                                    }
                                    if (setDirty)
                                    {
                                        self._rangeCalc.addListenersToDirty(row, column, rowCount, columnCount)
                                    }
                                }
                            }
                            else if (row === -1 && column === -1)
                            {
                                var rc = self.rC(),
                                    cc = self.cC();
                                self._iterateEachCell(0, 0, rc, cc, setAdjust, setDirty);
                                self._iterateEachRow(0, rc, setAdjust, setDirty);
                                self._iterateEachColumn(0, cc, setAdjust, setDirty);
                                if (self._rangeCalc)
                                {
                                    if (setAdjust)
                                    {
                                        self._rangeCalc.addListenersToAdjust(row, column, rowCount, columnCount)
                                    }
                                    if (setDirty)
                                    {
                                        self._rangeCalc.addListenersToDirty(row, column, rowCount, columnCount)
                                    }
                                }
                            }
                        }
                    };
                    return CalcSourceModel
                })();
            Calc.CalcSourceModel = CalcSourceModel;
            var typeCell = "cell",
                typeRow = "row",
                typeCol = "column";
            var cellListeners = "cellListeners",
                rowListeners = "rowListeners",
                columnListeners = "columnListeners",
                rowSliceListeners = "rowSliceListeners",
                columnSliceListeners = "columnSliceListeners";
            var BaseCalc = (function()
                {
                    function BaseCalc(sourceModel)
                    {
                        this.cellListeners = [];
                        this.rowListeners = [];
                        this.columnListeners = [];
                        this.sourceModel = sourceModel
                    }
                    BaseCalc.prototype.hasListeners = function()
                    {
                        var self = this,
                            listeners = self._listeners;
                        for (var i = 0; i < listeners.length; i++)
                        {
                            var listener = self[listeners[i]];
                            if (listener && listener.length > 0)
                            {
                                return true
                            }
                        }
                        return false
                    };
                    BaseCalc.prototype.processCellListener = function(cell, isAdd)
                    {
                        var listeners = this.cellListeners;
                        if (isAdd)
                        {
                            listeners.push(cell)
                        }
                        else
                        {
                            for (var i = 0; i < listeners.length; i++)
                            {
                                if (listeners[i] === cell)
                                {
                                    listeners.splice(i, 1);
                                    return
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.processRowListener = function(row, isAdd)
                    {
                        var listeners = this.rowListeners;
                        if (isAdd)
                        {
                            listeners.push(row)
                        }
                        else
                        {
                            for (var i = 0; i < listeners.length; i++)
                            {
                                if (listeners[i] === row)
                                {
                                    listeners.splice(i, 1);
                                    return
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.processColumnListener = function(column, isAdd)
                    {
                        var listeners = this.columnListeners;
                        if (isAdd)
                        {
                            listeners.push(column)
                        }
                        else
                        {
                            for (var i = 0; i < listeners.length; i++)
                            {
                                if (listeners[i] === column)
                                {
                                    listeners.splice(i, 1);
                                    return
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.addListenersToAdjust = function()
                    {
                        var listeners = this._listeners,
                            calc;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    calc.addToAdjust()
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.addListenersToDirty = function()
                    {
                        var listeners = this._listeners,
                            calc;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    calc.addToDirty()
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.adjustDelayOfListeners = function(isIncrement)
                    {
                        var listeners = this._listeners,
                            calc,
                            increment = isIncrement ? 1 : -1;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    calc.delay += increment
                                }
                            }
                        }
                    };
                    BaseCalc.prototype.addToAdjust = function(){};
                    BaseCalc.prototype.addToDirty = function(){};
                    BaseCalc.prototype.stopListening = function(){};
                    BaseCalc.prototype.startListening = function(){};
                    return BaseCalc
                })();
            Calc.BaseCalc = BaseCalc;
            var CellCalc = (function(_super)
                {
                    __extends(CellCalc, _super);
                    function CellCalc(sourceModel, row, column)
                    {
                        _super.call(this, sourceModel);
                        var self = this;
                        self.row = row;
                        self.column = column;
                        self.delay = 0;
                        self._listeners = [cellListeners, rowListeners, columnListeners]
                    }
                    CellCalc.prototype.startListening = function()
                    {
                        var self = this;
                        self.sourceModel.linkCellExpression(self.row, self.column, 1, 1)
                    };
                    CellCalc.prototype.stopListening = function()
                    {
                        var self = this;
                        self.sourceModel.unlinkCellExpression(self.row, self.column, 1, 1)
                    };
                    CellCalc.prototype.addToAdjust = function()
                    {
                        this.sourceModel.getCalcService().getOperatorAdjustor().addAdjust(this, 0)
                    };
                    CellCalc.prototype.addToDirty = function()
                    {
                        this.sourceModel.getCalcService().addDirty(this, 0)
                    };
                    return CellCalc
                })(BaseCalc);
            Calc.CellCalc = CellCalc;
            function addListenerImp(obj, prop, item)
            {
                if (!obj[prop])
                {
                    obj[prop] = []
                }
                obj[prop].push(item)
            }
            function removeListenerImp(obj, prop, item)
            {
                var collection = obj[prop];
                if (collection)
                {
                    for (var i = 0; i < collection.length; i++)
                    {
                        if (collection[i] === item)
                        {
                            collection.splice(i, 1);
                            return
                        }
                    }
                }
            }
            var RowCalc = (function(_super)
                {
                    __extends(RowCalc, _super);
                    function RowCalc(sourceModel, row)
                    {
                        _super.call(this, sourceModel);
                        var self = this;
                        self.row = row;
                        self._listeners = [cellListeners, rowListeners, rowSliceListeners, columnListeners]
                    }
                    RowCalc.prototype.incrementDelay2 = function(column, columnCount){};
                    RowCalc.prototype.decrementDelay2 = function(column, columnCount){};
                    RowCalc.prototype.startListening = function()
                    {
                        this.sourceModel.linkRowExpression(this.row, 1)
                    };
                    RowCalc.prototype.stopListening = function()
                    {
                        this.sourceModel.unlinkRowExpression(this.row, 1)
                    };
                    RowCalc.prototype.processRowListener2 = function(row, columnOffset, isAdd)
                    {
                        if (isAdd)
                        {
                            addListenerImp(this, rowSliceListeners, {
                                row: row, columnOffset: columnOffset, columnCount: 1
                            })
                        }
                        else
                        {
                            removeListenerImp(this, rowSliceListeners, {
                                row: row, columnOffset: columnOffset, columnCount: 1
                            })
                        }
                    };
                    RowCalc.prototype.addToAdjust = function()
                    {
                        this.sourceModel.getCalcService().getOperatorAdjustor().addAdjust(this, 1)
                    };
                    RowCalc.prototype.addToDirty = function()
                    {
                        this.sourceModel.getCalcService().addDirty(this, 1)
                    };
                    return RowCalc
                })(BaseCalc);
            Calc.RowCalc = RowCalc;
            var ColumnCalc = (function(_super)
                {
                    __extends(ColumnCalc, _super);
                    function ColumnCalc(sourceModel, column)
                    {
                        _super.call(this, sourceModel);
                        var self = this;
                        self.column = column;
                        self._listeners = [cellListeners, rowListeners, columnListeners, columnSliceListeners]
                    }
                    ColumnCalc.prototype.incrementDelay2 = function(row, rowCount){};
                    ColumnCalc.prototype.decrementDelay2 = function(row, rowCount){};
                    ColumnCalc.prototype.startListening = function()
                    {
                        this.sourceModel.linkColumnExpression(this.column, 1)
                    };
                    ColumnCalc.prototype.stopListening = function()
                    {
                        this.sourceModel.unlinkColumnExpression(this.column, 1)
                    };
                    ColumnCalc.prototype.processColumnListener2 = function(column, rowOffset, isAdd)
                    {
                        this.processColumnListener(column, isAdd)
                    };
                    ColumnCalc.prototype.addToAdjust = function()
                    {
                        this.sourceModel.getCalcService().getOperatorAdjustor().addAdjust(this, 2)
                    };
                    ColumnCalc.prototype.addToDirty = function()
                    {
                        this.sourceModel.getCalcService().addDirty(this, 2)
                    };
                    return ColumnCalc
                })(BaseCalc);
            Calc.ColumnCalc = ColumnCalc;
            var NameCalc = (function(_super)
                {
                    __extends(NameCalc, _super);
                    function NameCalc(name)
                    {
                        _super.call(this, keyword_null);
                        this.name = name;
                        this._listeners = [cellListeners, rowListeners, columnListeners]
                    }
                    NameCalc.prototype.updateListening = function(stop, start)
                    {
                        var self = this;
                        var listeners = self._listeners,
                            calc;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = self[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    if (stop)
                                    {
                                        calc.stopListening()
                                    }
                                    if (start)
                                    {
                                        calc.startListening()
                                    }
                                }
                            }
                        }
                    };
                    NameCalc.prototype.updateListeningOnRemoved = function()
                    {
                        var self = this;
                        var listeners = self._listeners,
                            calc,
                            depModel,
                            row,
                            col,
                            expr,
                            baseModel = self.sourceModel,
                            service = baseModel.getCalcService();
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = self[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    depModel = calc.sourceModel;
                                    row = calc.row;
                                    col = calc.col;
                                    row = row === keyword_undefined ? -1 : row;
                                    col = col === keyword_undefined ? -1 : col;
                                    expr = depModel.getExpr(row, col);
                                    var baseRange = depModel.getArrayInfo(row, col);
                                    if (expr)
                                    {
                                        var newExpr = service.getOperatorAdjustor().adjustFormulaOnRemoveName(baseModel, expr, self.name);
                                        if (newExpr !== expr)
                                        {
                                            depModel.setExpression(row, col, newExpr, baseRange, true)
                                        }
                                    }
                                }
                            }
                        }
                    };
                    NameCalc.prototype.addToDirty = function()
                    {
                        var listeners = this._listeners,
                            calc;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    calc = cls[i];
                                    calc.addToDirty()
                                }
                            }
                        }
                    };
                    return NameCalc
                })(BaseCalc);
            Calc.NameCalc = NameCalc;
            var RangeCalc = (function()
                {
                    function RangeCalc(sourceModel)
                    {
                        this.sourceModel = sourceModel;
                        this._listeners = [cellListeners, rowListeners, columnListeners]
                    }
                    RangeCalc.prototype.processListener = function(listenerType, row, column, rowCount, columnCount, listener, isAdd)
                    {
                        var self = this,
                            caches = self[listenerType],
                            key = row + "," + column + "," + rowCount + "," + columnCount,
                            list;
                        if (!caches)
                        {
                            self[listenerType] = caches = {}
                        }
                        list = caches[key];
                        if (!list)
                        {
                            if (!isAdd)
                            {
                                return
                            }
                            list = caches[key] = [];
                            list.row = row;
                            list.column = column;
                            list.rowCount = rowCount;
                            list.columnCount = columnCount
                        }
                        if (isAdd)
                        {
                            for (var i = 0; i < list.length; i++)
                            {
                                if (list[i] === listener)
                                {
                                    return
                                }
                            }
                            list.push(listener)
                        }
                        else
                        {
                            for (var i = 0; i < list.length; i++)
                            {
                                if (list[i] === listener)
                                {
                                    list.splice(i, 1)
                                }
                            }
                        }
                    };
                    RangeCalc.prototype.processCellListener = function(row, column, rowCount, columnCount, listener, isAdd)
                    {
                        this.processListener(cellListeners, row, column, rowCount, columnCount, listener, isAdd)
                    };
                    RangeCalc.prototype.processRowListener = function(row, column, rowCount, columnCount, listener, all, sliceOffset, sliceCount, isAdd)
                    {
                        this.processListener(rowListeners, row, column, rowCount, columnCount, listener, isAdd)
                    };
                    RangeCalc.prototype.processColumnListener = function(row, column, rowCount, columnCount, listener, all, sliceOffset, sliceCount, isAdd)
                    {
                        this.processListener(columnListeners, row, column, rowCount, columnCount, listener, isAdd)
                    };
                    RangeCalc.prototype.addListenersToAdjust = function(row, column, rowCount, columnCount)
                    {
                        this.visit(0, row, column, rowCount, columnCount)
                    };
                    RangeCalc.prototype.visit = function(action, row, column, rowCount, columnCount)
                    {
                        var listeners = this._listeners,
                            calc,
                            rangeKey;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                for (rangeKey in cls)
                                {
                                    var list = cls[rangeKey];
                                    var r = list.row;
                                    var c = list.column;
                                    var rc = list.rowCount;
                                    var cc = list.columnCount;
                                    if ((r === -1 || row === -1 || r < row + rowCount && row < r + rc) && (c === -1 || column === -1 || c < column + columnCount && column < c + cc))
                                    {
                                        var listenerLength = list.length;
                                        for (var listenerIndex = 0; listenerIndex < listenerLength; listenerIndex++)
                                        {
                                            calc = list[listenerIndex];
                                            if (action === 0)
                                            {
                                                calc.addToAdjust()
                                            }
                                            else
                                            {
                                                calc.addToDirty()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                    RangeCalc.prototype.addListenersToDirty = function(row, column, rowCount, columnCount)
                    {
                        this.visit(1, row, column, rowCount, columnCount)
                    };
                    RangeCalc.prototype.adjustDelayOfListeners = function(row, column, isIncrement)
                    {
                        var listeners = this._listeners,
                            range,
                            increment = isIncrement ? 1 : -1;
                        for (var lIndex = 0; lIndex < listeners.length; lIndex++)
                        {
                            var cls = this[listeners[lIndex]];
                            if (cls)
                            {
                                var cLength = cls.length;
                                for (var i = 0; i < cLength; i++)
                                {
                                    range = cls[i];
                                    if ((range.row === -1 || range.row <= row && row < range.row + range.rowCount) && (range.column === -1 || range.column <= column && column < range.column + range.columnCount))
                                    {
                                        var list = cls[i],
                                            listenerLength = list.length;
                                        for (var listenerIndex = 0; listenerIndex < listenerLength; listenerIndex++)
                                        {
                                            list[listenerIndex].delay += increment
                                        }
                                    }
                                }
                            }
                        }
                    };
                    return RangeCalc
                })();
            Calc.RangeCalc = RangeCalc;
            var CalcError = (function()
                {
                    function CalcError(error, errorCode)
                    {
                        this._error = error;
                        this._code = errorCode
                    }
                    CalcError.prototype.toString = function()
                    {
                        return this._error
                    };
                    CalcError.parse = function(value)
                    {
                        var err = CalcError._parseCore(value);
                        if (err === keyword_undefined)
                        {
                            throw'Incorrect error!';
                        }
                        return err
                    };
                    CalcError._parseCore = function(value)
                    {
                        if (typeof value !== const_undefined && value !== keyword_null && value !== '')
                        {
                            for (var i = 0; i < ErrorList.length; i++)
                            {
                                var errItem = ErrorList[i];
                                if (errItem === value || errItem === value.toUpperCase())
                                {
                                    return new CalcError(errItem, ErrorCodeList[i])
                                }
                            }
                        }
                        return keyword_undefined
                    };
                    return CalcError
                })();
            Calc.CalcError = CalcError;
            var CalcErrorsNull = new CalcError(const_null, 0x00),
                CalcErrorsDivideByZero = new CalcError(const_div0, 0x07),
                CalcErrorsValue = new CalcError(const_value, 0x0F),
                CalcErrorsReference = new CalcError(const_ref, 0x17),
                CalcErrorsName = new CalcError(const_name, 0x1D),
                CalcErrorsNotAvailable = new CalcError(const_na, 0x2A),
                CalcErrorsNumber = new CalcError(const_num, 0x24);
            var Errors = (function()
                {
                    function Errors(){}
                    Errors.Null = CalcErrorsNull;
                    Errors.DivideByZero = CalcErrorsDivideByZero;
                    Errors.Value = CalcErrorsValue;
                    Errors.Reference = CalcErrorsReference;
                    Errors.Name = CalcErrorsName;
                    Errors.NotAvailable = CalcErrorsNotAvailable;
                    Errors.Number = CalcErrorsNumber;
                    return Errors
                })();
            Calc.Errors = Errors;
            ;
            var CalcArray = (function()
                {
                    function CalcArray(){}
                    CalcArray.prototype.getRowCount = function()
                    {
                        return 1
                    };
                    CalcArray.prototype.getColumnCount = function()
                    {
                        return 1
                    };
                    CalcArray.prototype.length = function()
                    {
                        return this.getRowCount() * this.getColumnCount()
                    };
                    CalcArray.prototype.getValueByIndex = function(index)
                    {
                        var rc = this.getColumnCount(),
                            r = parseInt((index / rc), 10),
                            c = index % rc;
                        return this.getValue(r, c)
                    };
                    CalcArray.prototype.getValue = function(row, column)
                    {
                        return keyword_null
                    };
                    CalcArray.prototype.toArray = function(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var self = this,
                            rowCount = 1,
                            colCount = 1,
                            result = [],
                            value,
                            colValues,
                            errorOjbect = Convert.CalcConvertedError;
                        toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
                        rowCount = self.getRowCount();
                        colCount = self.getColumnCount();
                        for (var i = 0; i < rowCount; i++)
                        {
                            if (!toOneDimension)
                            {
                                colValues = [];
                                result.push(colValues)
                            }
                            for (var j = 0; j < colCount; j++)
                            {
                                value = self.getValue(i, j);
                                if (breakOnError && Convert.err(value))
                                {
                                    result = [value];
                                    result.isError = true;
                                    return result
                                }
                                value = Convert.convertValue(value, valueType, false, ignoreBlank);
                                if (breakOnConvertError && value === errorOjbect)
                                {
                                    result = [value];
                                    result.isError = true;
                                    return result
                                }
                                if (toOneDimension)
                                {
                                    result.push(value)
                                }
                                else
                                {
                                    colValues.push(value)
                                }
                            }
                        }
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.rangeCount = 1;
                        return result
                    };
                    CalcArray.prototype.slice = function(row, column, rowCount, columnCount)
                    {
                        throw"slice function not implement.";
                    };
                    return CalcArray
                })();
            Calc.CalcArray = CalcArray;
            var _ConcreteArray = (function(_super)
                {
                    __extends(_ConcreteArray, _super);
                    function _ConcreteArray(value, columnCount)
                    {
                        _super.call(this);
                        var self = this,
                            valueLength = value.length;
                        self._array = value;
                        self._rowCount = valueLength;
                        if (arguments.length < 2)
                        {
                            columnCount = 0;
                            for (var r = 0; r < valueLength; r++)
                            {
                                columnCount = Math_max(value[r].length, columnCount)
                            }
                        }
                        self._columnCount = columnCount
                    }
                    _ConcreteArray.prototype.getRowCount = function()
                    {
                        return this._rowCount
                    };
                    _ConcreteArray.prototype.getColumnCount = function()
                    {
                        return this._columnCount
                    };
                    _ConcreteArray.prototype.getValue = function(row, column)
                    {
                        return this._array[row][column]
                    };
                    _ConcreteArray.prototype.toArray = function(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var self = this,
                            rowCount = 1,
                            colCount = 1,
                            result = [],
                            value,
                            array = self._array,
                            colValues,
                            rowValue,
                            convertedArray,
                            errorObject = Convert.CalcConvertedError;
                        rowCount = array.length;
                        if (rowCount === 0)
                        {
                            result.isError = true;
                            return result
                        }
                        convertedArray = Convert.convertArray(array, valueType, false);
                        if (convertedArray.isError)
                        {
                            return convertedArray
                        }
                        colCount = array[0].length;
                        for (var i = 0; i < rowCount; i++)
                        {
                            if (!toOneDimension)
                            {
                                colValues = [];
                                result.push(colValues)
                            }
                            rowValue = convertedArray[i];
                            for (var j = 0; j < colCount; j++)
                            {
                                value = rowValue[j];
                                if (breakOnError && Convert.err(value))
                                {
                                    result = [value];
                                    result.isError = true;
                                    return result
                                }
                                value = Convert.convertValue(value, valueType, false);
                                if (breakOnConvertError && value === errorObject)
                                {
                                    result = [CalcErrorsValue];
                                    result.isError = true;
                                    return result
                                }
                                if (toOneDimension)
                                {
                                    result.push(value)
                                }
                                else
                                {
                                    colValues.push(value)
                                }
                            }
                        }
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.rangeCount = 1;
                        return result
                    };
                    _ConcreteArray.prototype.slice = function(row, column, rowCount, columnCount)
                    {
                        var self = this,
                            array = self._array,
                            result = [],
                            colArray;
                        row = row < 0 ? 0 : row;
                        column = column < 0 ? 0 : column;
                        rowCount = row + rowCount > self._rowCount ? self._rowCount - row : rowCount;
                        columnCount = column + columnCount > self._columnCount ? self._columnCount - column : columnCount;
                        for (var i = 0; i < rowCount; i++)
                        {
                            colArray = [];
                            result.push(colArray);
                            for (var j = 0; j < columnCount; j++)
                            {
                                colArray.push(array[i + row][j + column])
                            }
                        }
                        return new _ConcreteArray(result)
                    };
                    return _ConcreteArray
                })(CalcArray);
            Calc._ConcreteArray = _ConcreteArray;
            var Reference = (function()
                {
                    function Reference(){}
                    Reference.prototype.getRangeCount = function()
                    {
                        return 1
                    };
                    Reference.prototype.getRow = function(range)
                    {
                        return 0
                    };
                    Reference.prototype.getColumn = function(range)
                    {
                        return 0
                    };
                    Reference.prototype.getRowCount = function(range)
                    {
                        return 0
                    };
                    Reference.prototype.getColumnCount = function(range)
                    {
                        return 0
                    };
                    Reference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        return keyword_null
                    };
                    Reference.prototype.isSubtotal = function(range, rowOffset, columnOffset)
                    {
                        return false
                    };
                    Reference.prototype.isHiddenRow = function(range, rowOffset, onlyFiltered)
                    {
                        return false
                    };
                    Reference.prototype.getSource = function()
                    {
                        return keyword_null
                    };
                    Reference.prototype.create = function(ranges)
                    {
                        throw"create not implement.";
                    };
                    Reference.prototype.toArray = function(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var self = this,
                            rowCount = 1,
                            colCount = 1,
                            rangeCount,
                            result = [],
                            value,
                            rowValues,
                            colValues,
                            errorObject = Convert.CalcConvertedError;
                        toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
                        rangeCount = self.getRangeCount();
                        if (rangeCount === 0)
                        {
                            result.isError = true;
                            return []
                        }
                        rowCount = self.getRowCount(0);
                        if (rowCount === 0)
                        {
                            result.isError = true;
                            return []
                        }
                        colCount = self.getColumnCount(0);
                        if (colCount === 0)
                        {
                            result.isError = true;
                            return []
                        }
                        for (var i = 0; i < rangeCount; i++)
                        {
                            if (!toOneDimension)
                            {
                                rowValues = [];
                                result.push(rowValues)
                            }
                            for (var j = 0; j < rowCount; j++)
                            {
                                if (!toOneDimension)
                                {
                                    colValues = [];
                                    rowValues.push(colValues)
                                }
                                for (var k = 0; k < colCount; k++)
                                {
                                    value = self.getValue(i, j, k);
                                    if (breakOnError && Convert.err(value))
                                    {
                                        result = [value];
                                        result.isError = true;
                                        return result
                                    }
                                    value = Convert.convertValue(value, valueType, true, ignoreBlank);
                                    if (breakOnConvertError && value === errorObject)
                                    {
                                        result = [CalcErrorsValue];
                                        result.isError = true;
                                        return result
                                    }
                                    if (toOneDimension)
                                    {
                                        result.push(value)
                                    }
                                    else
                                    {
                                        colValues.push(value)
                                    }
                                }
                            }
                        }
                        if (!toOneDimension && rangeCount === 1)
                        {
                            result = result[0]
                        }
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.rangeCount = rangeCount;
                        return result
                    };
                    return Reference
                })();
            Calc.Reference = Reference;
            var _SheetRangeReference = (function(_super)
                {
                    __extends(_SheetRangeReference, _super);
                    function _SheetRangeReference(references)
                    {
                        _super.call(this);
                        if (!references || references.length === 0)
                        {
                            throw Sheets.SR.Exp_InvalidArgument;
                        }
                        var sourceReference = keyword_null;
                        for (var i = 0; i < references.length; i++)
                        {
                            var ref = references[i];
                            if (!sourceReference)
                            {
                                sourceReference = ref
                            }
                            else
                            {
                                if (ref.getRangeCount() !== sourceReference.getRangeCount())
                                {
                                    throw Sheets.SR.Exp_InvalidArgument;
                                }
                                for (var r = 0; r < ref.getRangeCount(); r++)
                                {
                                    if (ref.getColumn(r) !== sourceReference.getColumn(r) || ref.getColumnCount(r) !== sourceReference.getColumnCount(r) || ref.getRow(r) !== sourceReference.getRow(r) || ref.getRowCount(r) !== sourceReference.getRowCount(r))
                                    {
                                        throw Sheets.SR.Exp_InvalidArgument;
                                    }
                                }
                            }
                        }
                        this._references = references.slice(0)
                    }
                    _SheetRangeReference.prototype.getSheetCount = function()
                    {
                        return this._references.length
                    };
                    _SheetRangeReference.prototype.getRangeCount = function()
                    {
                        return this._references[0].getRangeCount()
                    };
                    _SheetRangeReference.prototype.getRow = function(range)
                    {
                        return this._references[0].getRow(range)
                    };
                    _SheetRangeReference.prototype.getColumn = function(range)
                    {
                        return this._references[0].getColumn(range)
                    };
                    _SheetRangeReference.prototype.getRowCount = function(range)
                    {
                        return this._references[0].getRowCount(range)
                    };
                    _SheetRangeReference.prototype.getColumnCount = function(range)
                    {
                        return this._references[0].getColumnCount(range)
                    };
                    _SheetRangeReference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        return keyword_null
                    };
                    _SheetRangeReference.prototype.isHiddenRow = function(range, rowOffset, onlyFiltered)
                    {
                        return false
                    };
                    _SheetRangeReference.prototype.isSubtotal = function(range, rowOffset, columnOffset)
                    {
                        return false
                    };
                    _SheetRangeReference.prototype.getSource = function()
                    {
                        return keyword_null
                    };
                    _SheetRangeReference.prototype.toArray = function(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var result = [],
                            referens = this._references,
                            subArray,
                            rowCount,
                            colCount,
                            isError;
                        for (var i = 0; i < referens.length; i++)
                        {
                            subArray = referens[i].toArray(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank);
                            if (subArray.rangeCount > 1)
                            {
                                result.isError = true;
                                return []
                            }
                            if (toOneDimension)
                            {
                                result = result.concat(subArray)
                            }
                            else
                            {
                                result.push(subArray[0])
                            }
                            rowCount = subArray.rowCount;
                            colCount = subArray.colCount;
                            isError = isError || subArray.isError
                        }
                        result.isArray = false;
                        result.isReference = true;
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.isError = isError;
                        return result
                    };
                    return _SheetRangeReference
                })(Reference);
            Calc._SheetRangeReference = _SheetRangeReference;
            (function(sheetRangeReferencePrototype)
            {
                sheetRangeReferencePrototype.getSource = function(sourceIndex)
                {
                    return this._references[sourceIndex].getSource()
                };
                sheetRangeReferencePrototype.getValue = function(sourceIndex, range, rowOffset, columnOffset)
                {
                    if (typeof sourceIndex === const_undefined || sourceIndex === keyword_null)
                    {
                        sourceIndex = 0
                    }
                    return this._references[sourceIndex].getValue(range, rowOffset, columnOffset)
                };
                sheetRangeReferencePrototype.isSubtotal = function(sourceIndex, range, rowOffset, columnOffset)
                {
                    if (typeof sourceIndex === const_undefined || sourceIndex === keyword_null)
                    {
                        sourceIndex = 0
                    }
                    return this._references[sourceIndex].isSubtotal(range, rowOffset, columnOffset)
                };
                sheetRangeReferencePrototype.isHiddenRow = function(sourceIndex, range, rowOffset, onlyFiltered)
                {
                    if (typeof sourceIndex === const_undefined || sourceIndex === keyword_null)
                    {
                        sourceIndex = 0
                    }
                    return this._references[sourceIndex].isHiddenRow(range, rowOffset, onlyFiltered)
                }
            })(_SheetRangeReference.prototype);
            var SheetReference = (function(_super)
                {
                    __extends(SheetReference, _super);
                    function SheetReference(calcSource, ranges)
                    {
                        _super.call(this);
                        var self = this;
                        self._sheetSource = calcSource;
                        if (ranges)
                        {
                            self._ranges = ranges;
                            self._rangeCount = ranges.length
                        }
                        else
                        {
                            self._rangeCount = 1
                        }
                    }
                    SheetReference.prototype.getRangeCount = function()
                    {
                        return this._rangeCount
                    };
                    SheetReference.prototype.getRow = function(range)
                    {
                        return this._ranges ? this._ranges[range].row : 0
                    };
                    SheetReference.prototype.getColumn = function(range)
                    {
                        return this._ranges ? this._ranges[range].col : 0
                    };
                    SheetReference.prototype.getRowCount = function(range)
                    {
                        return this._ranges ? this._ranges[range].rowCount : this._sheetSource.getRowCount()
                    };
                    SheetReference.prototype.getColumnCount = function(range)
                    {
                        return this._ranges ? this._ranges[range].colCount : this._sheetSource.getColumnCount()
                    };
                    SheetReference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        if (rowOffset >= 0 || columnOffset >= 0)
                        {
                            var ranges = this._ranges;
                            if (!ranges)
                            {
                                return this._sheetSource.getValue(rowOffset, columnOffset)
                            }
                            else if (range < ranges.length)
                            {
                                return this._sheetSource.getValue(rowOffset + ranges[range].row, columnOffset + ranges[range].col)
                            }
                        }
                        return CalcErrorsReference
                    };
                    SheetReference.prototype.isHiddenRow = function(range, rowOffset, onlyFiltered)
                    {
                        return this._sheetSource.isHiddenRow(rowOffset + this.getRow(range), onlyFiltered)
                    };
                    SheetReference.prototype.isSubtotal = function(range, rowOffset, columnOffset)
                    {
                        var sheetSource = this._sheetSource;
                        if (range === 0 && rowOffset < sheetSource.getRowCount() && columnOffset < sheetSource.getColumnCount())
                        {
                            var expr = sheetSource.calcSourceModel.getExpression(rowOffset, columnOffset);
                            return expr && expr.t === 7 && expr.getFunctionName().toUpperCase() === "SUBTOTAL"
                        }
                        return false
                    };
                    SheetReference.prototype.getSource = function()
                    {
                        return this._sheetSource
                    };
                    SheetReference.prototype.create = function(ranges)
                    {
                        return new SheetReference(this._sheetSource, ranges)
                    };
                    SheetReference.prototype.toArray = function(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        return this._sheetSource.referenceToArray(this, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    };
                    return SheetReference
                })(Reference);
            Calc.SheetReference = SheetReference;
            var _TernaryCompositeConcreteReference = (function(_super)
                {
                    __extends(_TernaryCompositeConcreteReference, _super);
                    function _TernaryCompositeConcreteReference(source, row, column, rowCount, columnCount, action, operand1, operand2)
                    {
                        _super.call(this, source, [new Sheets.Range(row, column, rowCount, columnCount)]);
                        var self = this;
                        self.Action = action;
                        self.Operand1 = operand1;
                        self.Operand2 = operand2
                    }
                    _TernaryCompositeConcreteReference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        var self = this;
                        return self.Action(_super.prototype.getValue.call(this, range, rowOffset, columnOffset), self.Operand1, self.Operand2)
                    };
                    return _TernaryCompositeConcreteReference
                })(SheetReference);
            Calc._TernaryCompositeConcreteReference = _TernaryCompositeConcreteReference;
            var _UnaryCompositeConcreteReference = (function(_super)
                {
                    __extends(_UnaryCompositeConcreteReference, _super);
                    function _UnaryCompositeConcreteReference(source, row, column, rowCount, columnCount, action)
                    {
                        _super.call(this, source, [new Sheets.Range(row, column, rowCount, columnCount)]);
                        this.Action = action
                    }
                    _UnaryCompositeConcreteReference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        return this.Action(_super.prototype.getValue.call(this, range, rowOffset, columnOffset))
                    };
                    return _UnaryCompositeConcreteReference
                })(SheetReference);
            Calc._UnaryCompositeConcreteReference = _UnaryCompositeConcreteReference;
            var _BinaryCompositeConcreteReference = (function(_super)
                {
                    __extends(_BinaryCompositeConcreteReference, _super);
                    function _BinaryCompositeConcreteReference(source, row, column, rowCount, columnCount, action, operand1, switchOrder)
                    {
                        _super.call(this, source, [new Sheets.Range(row, column, rowCount, columnCount)]);
                        var self = this;
                        self.Action = action;
                        self.Operand1 = operand1;
                        self.SwitchOrder = switchOrder
                    }
                    _BinaryCompositeConcreteReference.prototype.getValue = function(range, rowOffset, columnOffset)
                    {
                        var self = this;
                        var actualValue = _super.prototype.getValue.call(this, range, rowOffset, columnOffset);
                        return self.SwitchOrder ? self.Action(self.Operand1, actualValue) : self.Action(actualValue, self.Operand1)
                    };
                    return _BinaryCompositeConcreteReference
                })(SheetReference);
            Calc._BinaryCompositeConcreteReference = _BinaryCompositeConcreteReference;
            var Convert = (function()
                {
                    function Convert(){}
                    Convert.num = function(value)
                    {
                        return (typeof value === const_number) || (typeof value === const_boolean) || (!isNaN(value) && !isNaN(parseFloat(value))) || (value instanceof Date)
                    };
                    Convert.err = function(value)
                    {
                        return value instanceof CalcError
                    };
                    Convert.arr = function(value)
                    {
                        return value instanceof CalcArray
                    };
                    Convert.ref = function(value)
                    {
                        return value instanceof Reference
                    };
                    Convert.toResult = function(value)
                    {
                        if (isNaN(value) || !isFinite(value))
                        {
                            return CalcErrorsNumber
                        }
                        return value
                    };
                    Convert.toArr = function(value, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var result;
                        if (value && value.length && value.rowCount && value.colCount)
                        {
                            return value
                        }
                        else if (Convert.arr(value))
                        {
                            result = value.toArray(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank);
                            result.isArray = true
                        }
                        else if (Convert.ref(value))
                        {
                            result = value.toArray(valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank);
                            result.isReference = true
                        }
                        else if ($.isArray(value) && value.length > 0)
                        {
                            result = [];
                            if ($.isArray([0]))
                            {
                                return Convert.convertArray(value, valueType, true)
                            }
                            for (var i = 0; i < value.length; i++)
                            {
                                var arg = Convert.convertValue(value[i], valueType, false);
                                if (arg === Convert.CalcConvertedError)
                                {
                                    result.isConvertError = true
                                }
                                result.push(arg)
                            }
                            result.rowCount = 1;
                            result.colCount = value.length;
                            result.rangeCount = 1
                        }
                        else if (Convert.arr(value))
                        {
                            result = []
                        }
                        else
                        {
                            value = Convert.convertValue(value, valueType, true);
                            if (breakOnError && Convert.err(value))
                            {
                                result = [CalcErrorsValue];
                                result.isError = true
                            }
                            else if (value === Convert.CalcConvertedError)
                            {
                                result = [Convert.CalcConvertedError];
                                result.isConvertError = true
                            }
                            else if (toOneDimension)
                            {
                                result = [];
                                result.push(value)
                            }
                            else
                            {
                                result = [[]];
                                result[0].push(value)
                            }
                            result.rowCount = 1;
                            result.colCount = 1;
                            result.rangeCount = 1
                        }
                        return result
                    };
                    Convert.convertValue = function(value, valueType, convert, ignoreBlank)
                    {
                        if (Convert.err(value))
                        {
                            return value
                        }
                        var refValue = {value: keyword_null},
                            error = Convert.CalcConvertedError;
                        if (ignoreBlank && valueType !== 0 && (value === keyword_null || value === keyword_undefined))
                        {
                            return error
                        }
                        switch (valueType)
                        {
                            case 1:
                                if (!convert)
                                {
                                    if ((typeof value) !== const_number && !(value instanceof Date))
                                    {
                                        value = error
                                    }
                                }
                                else
                                {
                                    if (Convert.rD(value, refValue))
                                    {
                                        value = refValue.value
                                    }
                                    else
                                    {
                                        value = error
                                    }
                                }
                                break;
                            case 4:
                                if (typeof(value) === const_string)
                                {
                                    var date = Sheets._DateTimeHelper.parseLocale(value);
                                    if (typeof date !== const_undefined && date !== keyword_null)
                                    {
                                        value = new Sheets._DateTimeHelper(date).toOADate()
                                    }
                                    else
                                    {
                                        value = error
                                    }
                                }
                                else if (!convert)
                                {
                                    if ((typeof value) !== const_number && !(value instanceof Date))
                                    {
                                        value = error
                                    }
                                }
                                else
                                {
                                    if (Convert.rD(value, refValue))
                                    {
                                        value = refValue.value
                                    }
                                    else
                                    {
                                        value = error
                                    }
                                }
                                break;
                            case 3:
                                if (!convert)
                                {
                                    if ((typeof value) !== const_boolean)
                                    {
                                        value = error
                                    }
                                }
                                else
                                {
                                    if (Convert.rB(value, refValue))
                                    {
                                        value = refValue.value
                                    }
                                    else
                                    {
                                        value = false
                                    }
                                }
                                break;
                            case 2:
                                value = value === keyword_null || value === keyword_undefined ? "" : value.toString();
                                break
                        }
                        return value
                    };
                    Convert.convertArray = function(array, valueType, convert)
                    {
                        var convertedArray;
                        if (!array || !array.length || !array[0].length)
                        {
                            convertedArray = [];
                            convertedArray.isError = true;
                            return convertedArray
                        }
                        if (valueType === 0)
                        {
                            return array
                        }
                        else
                        {
                            var typeString = CalcValueTypeStrings[valueType];
                            var rowCount = array.length,
                                colCount = array[0].length,
                                rowValue,
                                convertedRowValue,
                                value,
                                refValue = {value: keyword_null};
                            var errorMarked = false,
                                convertErrorMarked = false,
                                errorObject = Convert.CalcConvertedError;
                            convertedArray = array[typeString];
                            if (!convertedArray)
                            {
                                convertedArray = [];
                                array[typeString] = convertedArray;
                                for (var i = 0; i < rowCount; i++)
                                {
                                    rowValue = array[i];
                                    convertedRowValue = convertedArray[i] = [];
                                    for (var j = 0; j < colCount; j++)
                                    {
                                        value = rowValue[j];
                                        if (!errorMarked && Convert.err(value))
                                        {
                                            convertedArray.isError = true;
                                            errorMarked = true
                                        }
                                        switch (valueType)
                                        {
                                            case 1:
                                                if (!convert)
                                                {
                                                    if ((typeof value) !== const_number && !(value instanceof Date))
                                                    {
                                                        if (!convertErrorMarked)
                                                        {
                                                            convertErrorMarked = true;
                                                            convertedArray.isConvertError = true
                                                        }
                                                        value = errorObject
                                                    }
                                                }
                                                else
                                                {
                                                    if (Convert.rD(value, refValue))
                                                    {
                                                        value = refValue.value
                                                    }
                                                    else
                                                    {
                                                        if (!convertErrorMarked)
                                                        {
                                                            convertErrorMarked = true;
                                                            convertedArray.isConvertError = true
                                                        }
                                                        value = 0
                                                    }
                                                }
                                                break;
                                            case 3:
                                                if (!convert)
                                                {
                                                    if ((typeof value) !== const_boolean)
                                                    {
                                                        if (!convertErrorMarked)
                                                        {
                                                            convertErrorMarked = true;
                                                            convertedArray.isConvertError = true
                                                        }
                                                        value = errorObject
                                                    }
                                                }
                                                else
                                                {
                                                    if (Convert.rB(value, refValue))
                                                    {
                                                        value = refValue.value
                                                    }
                                                    else
                                                    {
                                                        if (!convertErrorMarked)
                                                        {
                                                            convertErrorMarked = true;
                                                            convertedArray.isConvertError = true
                                                        }
                                                        value = false
                                                    }
                                                }
                                                break;
                                            case 2:
                                                value = value === keyword_null || value === keyword_undefined ? "" : value.toString();
                                                break
                                        }
                                        convertedRowValue.push(value)
                                    }
                                }
                            }
                        }
                        return convertedArray
                    };
                    Convert._isNaNOrInfinite = function(value)
                    {
                        return isNaN(value) || !isFinite(value)
                    };
                    Convert.I = function(value)
                    {
                        var dVal = Convert.D(value);
                        if (Math_abs(dVal) < 1E+21)
                        {
                            return parseInt(dVal, 10)
                        }
                        throw Sheets.SR.Exp_InvalidCast;
                    };
                    Convert.D = function(value)
                    {
                        var doubleValue = {value: 0};
                        if (Convert.rD(value, doubleValue))
                        {
                            return doubleValue.value
                        }
                        throw Sheets.SR.Exp_InvalidCast;
                    };
                    Convert.rD = function(value, doubleValue)
                    {
                        var result = keyword_null;
                        if (typeof value === const_undefined || value === keyword_null)
                        {
                            doubleValue.value = 0;
                            return true
                        }
                        var typestr = typeof value;
                        try
                        {
                            if (typestr === const_number)
                            {
                                result = new Number(value).valueOf();
                                if (Convert._isNaNOrInfinite(result))
                                    return false
                            }
                            else if (typestr === const_string)
                            {
                                value = value.trim();
                                if (value.length === 0)
                                {
                                    doubleValue.value = 0;
                                    return true
                                }
                                var isPercent = false;
                                if (value.charAt(value.length - 1) === '%')
                                {
                                    isPercent = true;
                                    value = value.substr(0, value.length - 1)
                                }
                                result = new Number(value).valueOf();
                                if (Convert._isNaNOrInfinite(result))
                                    return false;
                                if (isPercent)
                                {
                                    result /= 100
                                }
                            }
                            else if (typestr === const_boolean)
                                result = value ? 1 : 0;
                            else if (value instanceof Date)
                                result = new Sheets._DateTimeHelper(value).toOADate();
                            else
                                return false
                        }
                        catch(ex)
                        {
                            return false
                        }
                        doubleValue.value = result;
                        return true
                    };
                    Convert.rB = function(value, boolValue)
                    {
                        try
                        {
                            if (typeof value === const_undefined || value === keyword_null)
                            {
                                return false
                            }
                            else if (typeof value === const_boolean)
                            {}
                            else if (value instanceof Date)
                            {
                                value = Sheets._DateTimeHelper.___toOADate(value) !== 0
                            }
                            else if (Convert.num(value))
                            {
                                value = value !== 0
                            }
                            else
                            {
                                throw Sheets.SR.Exp_InvalidCast;
                            }
                        }
                        catch(ex) {}
                        boolValue.value = value;
                        return true
                    };
                    Convert.B = function(value)
                    {
                        if (typeof value === const_undefined || value === keyword_null)
                        {
                            return false
                        }
                        else if (typeof value === const_boolean)
                        {
                            return value
                        }
                        else if (value instanceof Date)
                        {
                            return new Sheets._DateTimeHelper(value).toOADate() !== 0
                        }
                        else if (Convert.num(value))
                        {
                            return value !== 0
                        }
                        else if (Convert.err(value))
                        {
                            return false
                        }
                        else
                        {
                            throw Sheets.SR.Exp_InvalidCast;
                        }
                    };
                    Convert.S = function(value)
                    {
                        try
                        {
                            if (typeof value === const_undefined || value === keyword_null)
                            {
                                return ''
                            }
                            else if (typeof value === const_boolean)
                            {
                                return value ? const_true : const_false
                            }
                            else if (typeof value === const_string)
                            {
                                return value
                            }
                            else if (value instanceof Date)
                            {
                                return new Sheets._DateTimeHelper(value).localeFormat("M/d/yyyy h:mm:ss")
                            }
                            else if (Convert.arr(value))
                            {
                                throw Sheets.SR.Exp_InvalidCast;
                            }
                            else
                            {
                                return value.toString()
                            }
                        }
                        catch(err)
                        {
                            throw Sheets.SR.Exp_InvalidCast;
                        }
                    };
                    Convert.DT = function(value)
                    {
                        var dateValue = {value: keyword_null};
                        if (Convert.rDT(value, dateValue))
                        {
                            return dateValue.value
                        }
                        throw Sheets.SR.Exp_InvalidCast;
                    };
                    Convert.rDT = function(value, dateValue)
                    {
                        if (typeof value === const_undefined || value === keyword_null)
                        {
                            dateValue.value = Sheets._DateTimeHelper.fromOADate(0)
                        }
                        else if (value instanceof Date)
                        {
                            dateValue.value = new Date(value)
                        }
                        else if (typeof value === const_string)
                        {
                            var dateTime = Sheets._DateTimeHelper.parseLocale(value);
                            if ((typeof dateTime === const_undefined || dateTime === keyword_null) && !isNaN(value))
                            {
                                dateTime = Sheets._DateTimeHelper.fromOADate(parseFloat(value))
                            }
                            if (dateTime === keyword_undefined || dateTime === keyword_null)
                            {
                                return false
                            }
                            dateValue.value = dateTime
                        }
                        else if (typeof value === const_number)
                        {
                            dateValue.value = Sheets._DateTimeHelper.fromOADate(value)
                        }
                        else
                        {
                            return false
                        }
                        return true
                    };
                    Convert.CalcConvertedError = {};
                    return Convert
                })();
            Calc.Convert = Convert;
            var _Helper = (function()
                {
                    function _Helper(){}
                    _Helper._argumentExists = function(args, index)
                    {
                        return args && index < args.length && (args[index] !== Calc.missingArgument)
                    };
                    _Helper._argumentValid = function(args, index)
                    {
                        if (!args)
                        {
                            return false
                        }
                        var arg = args[index];
                        return arg !== Calc.missingArgument && arg !== keyword_null && arg !== keyword_undefined && !arg._error
                    };
                    _Helper.getArrayValue = function(array, i, j)
                    {
                        if (typeof array === const_undefined || array === keyword_null)
                        {
                            return CalcErrorsValue
                        }
                        if (i < array.getRowCount() && j < array.getColumnCount())
                        {
                            return array.getValue(i, j)
                        }
                        if (j >= array.getColumnCount() && array.getColumnCount() === 1 && i < array.getRowCount())
                        {
                            return array.getValue(i, 0)
                        }
                        if (i >= array.getRowCount() && array.getColumnCount() === 1 && j < array.getColumnCount())
                        {
                            return array.getValue(0, j)
                        }
                        return CalcErrorsValue
                    };
                    _Helper.tryExtractToSingleValue = function(arg)
                    {
                        var success = true;
                        if ((Convert.ref(arg)) || Convert.arr(arg))
                        {
                            var array = Convert.toArr(arg, 0, false, true);
                            if (array.isError)
                            {
                                success = false
                            }
                            else if (array.rowCount === 1 && array.colCount === 1)
                            {
                                arg = array[0][0]
                            }
                            else
                            {
                                arg = array;
                                success = false
                            }
                        }
                        return {
                                value: arg, success: success
                            }
                    };
                    return _Helper
                })();
            Calc._Helper = _Helper;
            var CalcArrayHelper = (function()
                {
                    function CalcArrayHelper(){}
                    CalcArrayHelper.getLength = function(obj, rangeId)
                    {
                        if (Convert.arr(obj))
                        {
                            return obj.getRowCount() * obj.getColumnCount()
                        }
                        else if (Convert.ref(obj))
                        {
                            rangeId = rangeId ? rangeId : 0;
                            return obj.getRowCount(rangeId) * obj.getColumnCount(rangeId)
                        }
                    };
                    CalcArrayHelper.getRowCount = function(obj, rangeId)
                    {
                        if (Convert.arr(obj))
                        {
                            return obj.getRowCount()
                        }
                        else if (Convert.ref(obj))
                        {
                            rangeId = rangeId ? rangeId : 0;
                            return obj.getRowCount(rangeId)
                        }
                    };
                    CalcArrayHelper.getColumnCount = function(obj, rangeId)
                    {
                        if (Convert.arr(obj))
                        {
                            return obj.getColumnCount()
                        }
                        else if (Convert.ref(obj))
                        {
                            rangeId = rangeId ? rangeId : 0;
                            return obj.getColumnCount(rangeId)
                        }
                    };
                    CalcArrayHelper.getValueByIndex = function(obj, i, rangeId)
                    {
                        if (Convert.arr(obj))
                        {
                            return obj.getValueByIndex(i)
                        }
                        else if (Convert.ref(obj))
                        {
                            rangeId = rangeId ? rangeId : 0;
                            var cc = obj.getColumnCount(rangeId);
                            return obj.getValue(rangeId, parseInt((i / cc), 10), i % cc)
                        }
                    };
                    CalcArrayHelper.getValue = function(obj, row, column, rangeId)
                    {
                        if (Convert.arr(obj))
                        {
                            return obj.getValue(row, column)
                        }
                        else if (Convert.ref(obj))
                        {
                            rangeId = rangeId ? rangeId : 0;
                            return obj.getValue(rangeId, row, column)
                        }
                    };
                    return CalcArrayHelper
                })();
            Calc.CalcArrayHelper = CalcArrayHelper;
            function compareStringIgnoreCase(s1, s2)
            {
                if ((s1 === keyword_undefined || s1 === keyword_null) && (s2 === keyword_undefined || s2 === keyword_null))
                {
                    return true
                }
                if (((s1 === keyword_undefined || s1 === keyword_null) && (s2 !== keyword_undefined && s2 !== keyword_null)) || ((s1 !== keyword_undefined && s1 !== keyword_null) && (s2 === keyword_undefined || s2 === keyword_null)))
                {
                    return false
                }
                return s1.toLowerCase() === s2.toLowerCase()
            }
            Calc.compareStringIgnoreCase = compareStringIgnoreCase;
            (function(Operators)
            {
                var Operator = (function()
                    {
                        function Operator(name)
                        {
                            this.name = name
                        }
                        Operator.prototype.getName = function()
                        {
                            return this.name
                        };
                        Operator.prototype.compareTo = function(other)
                        {
                            return compareStringIgnoreCase(this.name, other.name)
                        };
                        Operator.prototype.toString = function()
                        {
                            return this.getName()
                        };
                        return Operator
                    })();
                Operators.Operator = Operator;
                var UnaryOperator = (function(_super)
                    {
                        __extends(UnaryOperator, _super);
                        function UnaryOperator(name)
                        {
                            _super.call(this, name)
                        }
                        UnaryOperator.prototype._evaluateSingle = function(operand, context){};
                        UnaryOperator.prototype._evaluateImp = function(operand, context)
                        {
                            var array = keyword_null;
                            if (Convert.arr(operand))
                            {
                                array = operand
                            }
                            if (Convert.ref(operand))
                            {
                                array = Convert.toArr(operand, 0, false, false)
                            }
                            if (array === keyword_undefined || array === keyword_null)
                            {
                                return this._evaluateSingle(operand, context)
                            }
                            if (array.length() < 1)
                            {
                                return CalcErrorsNumber
                            }
                            var objs = [];
                            for (var r = 0; r < array.getRowCount(); r++)
                            {
                                objs[r] = [];
                                for (var c = 0; c < array.getColumnCount(); c++)
                                {
                                    objs[r][c] = this._evaluateSingle(array.getValue(r, c), context)
                                }
                            }
                            return new _ConcreteArray(objs, array.getColumnCount())
                        };
                        UnaryOperator.prototype.evaluate = function(operand, context)
                        {
                            return this._evaluateImp(operand, context)
                        };
                        return UnaryOperator
                    })(Operator);
                Operators.UnaryOperator = UnaryOperator;
                Operators.plus = new UnaryOperator("+");
                Operators.plus._evaluateSingle = function(operand, context)
                {
                    if (operand === keyword_undefined || operand === keyword_null)
                    {
                        return 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(operand, doubleLeft))
                    {
                        if (typeof operand === "string")
                        {
                            return operand
                        }
                        return CalcErrorsValue
                    }
                    return Convert.D(doubleLeft.value)
                };
                Operators.negate = new UnaryOperator("-");
                Operators.negate._evaluateSingle = function(operand, context)
                {
                    if (operand === keyword_undefined || operand === keyword_null)
                    {
                        return 0
                    }
                    var doubleValue = {value: 0};
                    if (!Convert.rD(operand, doubleValue))
                    {
                        return CalcErrorsValue
                    }
                    return -doubleValue.value
                };
                Operators.percent = new UnaryOperator("%");
                Operators.percent._evaluateSingle = function(operand, context)
                {
                    if (operand === keyword_undefined || operand === keyword_null)
                    {
                        return 0
                    }
                    var doubleValue = {value: 0};
                    if (!Convert.rD(operand, doubleValue))
                    {
                        return CalcErrorsValue
                    }
                    return doubleValue.value / 100
                };
                function _approxEqual(x, y)
                {
                    if (x === y)
                    {
                        return true
                    }
                    return Math_abs(x - y) < Math_abs(x) / (16777216.0 * 16777216.0)
                }
                var BinaryOperator = (function(_super)
                    {
                        __extends(BinaryOperator, _super);
                        function BinaryOperator(name, acceptsReference)
                        {
                            _super.call(this, name);
                            this.acceptsReference = acceptsReference
                        }
                        BinaryOperator.prototype._evaluateSingle = function(left, right, context){};
                        BinaryOperator.prototype.evaluate = function(left, right, context)
                        {
                            var isArg0Simple = _Helper.tryExtractToSingleValue(left);
                            var isArg1Simple = _Helper.tryExtractToSingleValue(right);
                            if (isArg0Simple.success && isArg1Simple.success)
                            {
                                return this._evaluateSingle(isArg0Simple.value, isArg1Simple.value)
                            }
                            left = isArg0Simple.value;
                            right = isArg1Simple.value;
                            var rowArg0 = isArg0Simple.success ? -1 : left.rowCount;
                            var colArg0 = isArg0Simple.success ? -1 : left.colCount;
                            var rowArg1 = isArg1Simple.success ? -1 : right.rowCount;
                            var colArg1 = isArg1Simple.success ? -1 : right.colCount;
                            var row = -1,
                                col = -1;
                            if (!isArg0Simple.success && !isArg1Simple.success)
                            {
                                if (rowArg0 != 1 && rowArg1 != 1 && rowArg0 != rowArg1 || colArg0 != 1 && colArg1 != 1 && colArg0 != colArg1)
                                {
                                    return CalcErrorsNotAvailable
                                }
                                row = rowArg0 == 1 ? rowArg1 : rowArg0;
                                col = colArg0 == 1 ? colArg1 : colArg0
                            }
                            else if (!isArg0Simple.success)
                            {
                                row = rowArg0;
                                col = colArg0
                            }
                            else
                            {
                                row = rowArg1;
                                col = colArg1
                            }
                            var result = [];
                            for (var i = 0; i < row; i++)
                            {
                                result[i] = [];
                                for (var j = 0; j < col; j++)
                                {
                                    if (!isArg0Simple.success && (rowArg0 !== 1 && rowArg0 < row || colArg0 !== 1 && colArg0 < col) || !isArg1Simple.success && (rowArg1 !== 1 && rowArg1 < row || colArg1 !== 1 && colArg1 < col))
                                    {
                                        result[i][j] = CalcErrorsNotAvailable
                                    }
                                    else
                                    {
                                        result[i][j] = this._evaluateSingle(isArg0Simple.success ? left : left[rowArg0 === 1 ? 0 : i][colArg0 === 1 ? 0 : j], isArg1Simple.success ? right : right[rowArg1 == 1 ? 0 : i][colArg1 === 1 ? 0 : j])
                                    }
                                }
                            }
                            return new _ConcreteArray(result, col)
                        };
                        return BinaryOperator
                    })(Operator);
                Operators.BinaryOperator = BinaryOperator;
                Operators.add = new BinaryOperator("+", false);
                Operators.add._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(left, doubleLeft))
                    {
                        return CalcErrorsValue
                    }
                    var doubleRight = {value: 0};
                    if (!Convert.rD(right, doubleRight))
                    {
                        return CalcErrorsValue
                    }
                    return doubleLeft.value + doubleRight.value
                };
                Operators.subtract = new BinaryOperator("-", false);
                Operators.subtract._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(left, doubleLeft))
                    {
                        return CalcErrorsValue
                    }
                    var doubleRight = {value: 0};
                    if (!Convert.rD(right, doubleRight))
                    {
                        return CalcErrorsValue
                    }
                    return doubleLeft.value - doubleRight.value
                };
                Operators.multiply = new BinaryOperator("*", false);
                Operators.multiply._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(left, doubleLeft))
                    {
                        return CalcErrorsValue
                    }
                    var doubleRight = {value: 0};
                    if (!Convert.rD(right, doubleRight))
                    {
                        return CalcErrorsValue
                    }
                    return doubleLeft.value * doubleRight.value
                };
                Operators.divide = new BinaryOperator("/", false);
                Operators.divide._evaluateSingle = function(left, right, context)
                {
                    if (right === keyword_undefined || right === keyword_null || right === '' || right === 0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(left, doubleLeft))
                    {
                        return CalcErrorsValue
                    }
                    var doubleRight = {value: 0};
                    if (!Convert.rD(right, doubleRight))
                    {
                        return CalcErrorsValue
                    }
                    if (doubleRight.value === 0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    return doubleLeft.value / doubleRight.value
                };
                Operators.exponent = new BinaryOperator("^", false);
                Operators.exponent._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    var doubleLeft = {value: 0};
                    if (!Convert.rD(left, doubleLeft))
                    {
                        return CalcErrorsValue
                    }
                    left = doubleLeft.value;
                    var doubleRight = {value: 0};
                    if (!Convert.rD(right, doubleRight))
                    {
                        return CalcErrorsValue
                    }
                    right = doubleRight.value;
                    if (left === 0.0 && right < 0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    return Math_pow(left, right)
                };
                Operators.concatenate = new BinaryOperator("&", false);
                Operators.concatenate._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = ""
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = ""
                    }
                    return left.toString() + right.toString()
                };
                Operators.equal = new BinaryOperator("=", false);
                Operators.equal._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        if (typeof right === const_string)
                        {
                            left = ""
                        }
                        else
                        {
                            left = 0
                        }
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        if (typeof left === const_string)
                        {
                            right = ""
                        }
                        else
                        {
                            right = 0
                        }
                    }
                    if (typeof left === const_string || typeof right === const_string)
                    {
                        return left.toString().toUpperCase() === right.toString().toUpperCase()
                    }
                    else
                    {
                        var doubleLeft = {value: 0};
                        if (!Convert.rD(left, doubleLeft))
                        {
                            return CalcErrorsValue
                        }
                        left = doubleLeft.value;
                        var doubleRight = {value: 0};
                        if (!Convert.rD(right, doubleRight))
                        {
                            return CalcErrorsValue
                        }
                        right = doubleRight.value;
                        var x = left;
                        var y = right;
                        return _approxEqual(x, y)
                    }
                };
                Operators.notEqual = new BinaryOperator("<>", false);
                Operators.notEqual._evaluateSingle = function(left, right, context)
                {
                    var value = Operators.equal._evaluateSingle.call(this, left, right, context);
                    if (typeof value === const_boolean)
                    {
                        return !value
                    }
                    return value
                };
                Operators.lessThan = new BinaryOperator("<", false);
                Operators.lessThan._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    if (typeof left === const_string || typeof right === const_string)
                    {
                        return left.toString().toUpperCase() < right.toString().toUpperCase()
                    }
                    else
                    {
                        var doubleLeft = {value: 0};
                        if (!Convert.rD(left, doubleLeft))
                        {
                            return CalcErrorsValue
                        }
                        left = doubleLeft.value;
                        var doubleRight = {value: 0};
                        if (!Convert.rD(right, doubleRight))
                        {
                            return CalcErrorsValue
                        }
                        right = doubleRight.value;
                        var x = left;
                        var y = right;
                        return x < y && !_approxEqual(x, y)
                    }
                };
                Operators.greaterThan = new BinaryOperator(">", false);
                Operators.greaterThan._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    if (typeof left === const_string || typeof right === const_string)
                    {
                        return left.toString().toUpperCase() > right.toString().toUpperCase()
                    }
                    else
                    {
                        var doubleLeft = {value: 0};
                        if (!Convert.rD(left, doubleLeft))
                        {
                            return CalcErrorsValue
                        }
                        left = doubleLeft.value;
                        var doubleRight = {value: 0};
                        if (!Convert.rD(right, doubleRight))
                        {
                            return CalcErrorsValue
                        }
                        right = doubleRight.value;
                        var x = left;
                        var y = right;
                        return x > y && !_approxEqual(x, y)
                    }
                };
                Operators.lessThanOrEqual = new BinaryOperator("<=", false);
                Operators.lessThanOrEqual._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    if (typeof left === const_string || typeof right === const_string)
                    {
                        return left.toString().toUpperCase() <= right.toString().toUpperCase()
                    }
                    else
                    {
                        var doubleLeft = {value: 0};
                        if (!Convert.rD(left, doubleLeft))
                        {
                            return CalcErrorsValue
                        }
                        left = doubleLeft.value;
                        var doubleRight = {value: 0};
                        if (!Convert.rD(right, doubleRight))
                        {
                            return CalcErrorsValue
                        }
                        right = doubleRight.value;
                        var x = left;
                        var y = right;
                        return x < y || _approxEqual(x, y)
                    }
                };
                Operators.greaterThanOrEqual = new BinaryOperator(">=", false);
                Operators.greaterThanOrEqual._evaluateSingle = function(left, right, context)
                {
                    if (Convert.err(left))
                    {
                        return left
                    }
                    if (Convert.err(right))
                    {
                        return right
                    }
                    if (left === keyword_undefined || left === keyword_null)
                    {
                        left = 0
                    }
                    if (right === keyword_undefined || right === keyword_null)
                    {
                        right = 0
                    }
                    if (typeof left === const_string || typeof right === const_string)
                    {
                        return left.toString().toUpperCase() >= right.toString().toUpperCase()
                    }
                    else
                    {
                        var doubleLeft = {value: 0};
                        if (!Convert.rD(left, doubleLeft))
                        {
                            return CalcErrorsValue
                        }
                        left = doubleLeft.value;
                        var doubleRight = {value: 0};
                        if (!Convert.rD(right, doubleRight))
                        {
                            return CalcErrorsValue
                        }
                        right = doubleRight.value;
                        var x = left;
                        var y = right;
                        return x > y || _approxEqual(x, y)
                    }
                };
                Operators.range = new BinaryOperator(":", true);
                Operators.range.evaluate = function(left, right, context)
                {
                    if (left === keyword_undefined || left === keyword_null || right === keyword_undefined || right === keyword_null || left.getRangeCount() !== 1 || right.getRangeCount() !== 1)
                    {
                        return CalcErrorsValue
                    }
                    var leftSource = left.getSource();
                    if (!leftSource || leftSource !== right.getSource())
                    {
                        return CalcErrorsValue
                    }
                    var leftRow = left.getRow(0);
                    var leftColumn = left.getColumn(0);
                    var rightRow = right.getRow(0);
                    var rightColumn = right.getColumn(0);
                    var row = Math_min(leftRow, rightRow);
                    var column = Math_min(leftColumn, rightColumn);
                    var rowCount = Math_max(leftRow + left.getRowCount(0), rightRow + right.getRowCount(0)) - row;
                    var columnCount = Math_max(leftColumn + left.getColumnCount(0), rightColumn + right.getColumnCount(0)) - column;
                    return new SheetReference(leftSource, [{
                                row: row, col: column, rowCount: rowCount, colCount: columnCount
                            }])
                };
                Operators.union = new BinaryOperator(",", true);
                Operators.union.evaluate = function(left, right, context)
                {
                    if (left === keyword_undefined || left === keyword_null || right === keyword_undefined || right === keyword_null)
                    {
                        return CalcErrorsValue
                    }
                    var ranges = [],
                        i = 0;
                    for (i = 0; i < left.getRangeCount(); i++)
                    {
                        ranges.push({
                            row: left.getRow(i), col: left.getColumn(i), rowCount: left.getRowCount(i), colCount: left.getColumnCount(i)
                        })
                    }
                    for (i = 0; i < right.getRangeCount(); i++)
                    {
                        ranges.push({
                            row: right.getRow(i), col: right.getColumn(i), rowCount: right.getRowCount(i), colCount: right.getColumnCount(i)
                        })
                    }
                    return new SheetReference(left.getSource(), ranges)
                };
                Operators.intersection = new BinaryOperator(" ", true);
                Operators.intersection.evaluate = function(left, right, context)
                {
                    if (left === keyword_undefined || left === keyword_null || right === keyword_undefined || right === keyword_null || left.getRangeCount() !== 1 || right.getRangeCount() !== 1)
                    {
                        return CalcErrorsValue
                    }
                    var leftSource = left.getSource();
                    if (!leftSource || leftSource !== right.getSource())
                    {
                        return CalcErrorsValue
                    }
                    var leftRow = left.getRow(0);
                    var leftColumn = left.getColumn(0);
                    var rightRow = right.getRow(0);
                    var rightColumn = right.getColumn(0);
                    var row = Math_max(leftRow, rightRow);
                    var column = Math_max(leftColumn, rightColumn);
                    var rowCount = Math_min(leftRow + left.getRowCount(0), rightRow + right.getRowCount(0)) - row;
                    var columnCount = Math_min(leftColumn + left.getColumnCount(0), rightColumn + right.getColumnCount(0)) - column;
                    return new SheetReference(leftSource, [{
                                row: row, col: column, rowCount: rowCount, colCount: columnCount
                            }])
                }
            })(Calc.Operators || (Calc.Operators = {}));
            var Operators = Calc.Operators;
            (function(Functions)
            {
                (function(ArrayArgumentEvaluateMode)
                {
                    ArrayArgumentEvaluateMode[ArrayArgumentEvaluateMode["normal"] = 0] = "normal";
                    ArrayArgumentEvaluateMode[ArrayArgumentEvaluateMode["allwaysExpand"] = 1] = "allwaysExpand";
                    ArrayArgumentEvaluateMode[ArrayArgumentEvaluateMode["neverExpand"] = 2] = "neverExpand"
                })(Functions.ArrayArgumentEvaluateMode || (Functions.ArrayArgumentEvaluateMode = {}));
                var ArrayArgumentEvaluateMode = Functions.ArrayArgumentEvaluateMode;
                var Function = (function()
                    {
                        function Function(name, minArgs, maxArgs)
                        {
                            var argumentsLength = arguments.length;
                            this._init(name, argumentsLength < 2 ? 0 : minArgs, argumentsLength < 3 ? 0 : maxArgs);
                            this.typeName = ""
                        }
                        Function.prototype._init = function(name, minArgs, maxArgs)
                        {
                            var self = this;
                            self.name = name;
                            self.minArgs = minArgs;
                            self.maxArgs = maxArgs
                        };
                        Function.prototype.acceptsArray = function(argIndex)
                        {
                            return false
                        };
                        Function.prototype.acceptsReference = function(argIndex)
                        {
                            return false
                        };
                        Function.prototype.acceptsError = function(argIndex)
                        {
                            return false
                        };
                        Function.prototype.acceptsMissingArgument = function(argIndex)
                        {
                            return false
                        };
                        Function.prototype.isVolatile = function()
                        {
                            return false
                        };
                        Function.prototype.isContextSensitive = function()
                        {
                            return false
                        };
                        Function.prototype.isBranch = function()
                        {
                            return false
                        };
                        Function.prototype.findTestArgument = function()
                        {
                            return -1
                        };
                        Function.prototype.findBranchArgument = function(test)
                        {
                            return -1
                        };
                        Function.prototype.expandRows = function()
                        {
                            return true
                        };
                        Function.prototype.expandColumns = function()
                        {
                            return true
                        };
                        Function.prototype.precedentReference = function()
                        {
                            return true
                        };
                        Function.prototype.returnReference = function()
                        {
                            return false
                        };
                        Function.prototype.evaluate = function(args, context){};
                        Function.prototype.evaluateWithContext = function(args, context)
                        {
                            var self = this;
                            if (self.isContextSensitive())
                            {
                                return self.evaluate(args, context)
                            }
                            else
                            {
                                return self.evaluate(args)
                            }
                        };
                        Function.prototype.toString = function()
                        {
                            return this.name
                        };
                        Function._create = function(name, fnEvaluate, options)
                        {
                            var fn = new Functions.Function(name, 0, 255);
                            if (fnEvaluate && typeof fnEvaluate === "function")
                            {
                                fn.evaluate = fnEvaluate
                            }
                            if (options)
                            {
                                for (var prop in options)
                                {
                                    if (options.hasOwnProperty(prop) && prop !== 'override')
                                    {
                                        fn[prop] = options[prop]
                                    }
                                }
                            }
                            return fn
                        };
                        Function.prototype.toJSON = function()
                        {
                            var settings = {};
                            for (var p in this)
                            {
                                if (this.hasOwnProperty(p))
                                {
                                    settings[p] = this[p]
                                }
                            }
                            return settings
                        };
                        Function.prototype.fromJSON = function(settings)
                        {
                            if (!settings)
                            {
                                return
                            }
                            for (var p in settings)
                            {
                                if (settings[p] !== keyword_undefined)
                                {
                                    this[p] = settings[p]
                                }
                            }
                        };
                        return Function
                    })();
                Functions.Function = Function;
                var AsyncFunction = (function(_super)
                    {
                        __extends(AsyncFunction, _super);
                        function AsyncFunction(name, minArgs, maxArgs)
                        {
                            _super.call(this, name, minArgs, maxArgs)
                        }
                        AsyncFunction.prototype.isContextSensitive = function()
                        {
                            return true
                        };
                        AsyncFunction.prototype.evaluate = function(args, context)
                        {
                            return this.evaluateAsync(args, context)
                        };
                        AsyncFunction.prototype.evaluateAsync = function(args, context){};
                        AsyncFunction.prototype.defaultValue = function()
                        {
                            return 0
                        };
                        return AsyncFunction
                    })(Function);
                Functions.AsyncFunction = AsyncFunction;
                Functions._customFunctions = {};
                Functions._builtInFunctions = {};
                function defineGlobalCustomFunction(name, fnEvaluate, options)
                {
                    if (name === keyword_undefined || name === keyword_null)
                    {
                        throw Sheets.SR.Exp_InvalidFunctionName;
                    }
                    var fn;
                    name = name.toUpperCase();
                    if (Functions._builtInFunctions.hasOwnProperty(name))
                    {
                        throw Sheets.SR.Exp_InvalidOverrideFunction;
                    }
                    if (!Functions._customFunctions.hasOwnProperty(name))
                    {
                        fn = new Functions.Function(name, 0, 255);
                        Functions._customFunctions[name] = fn
                    }
                    else
                    {
                        fn = Functions._customFunctions[name];
                        if (!fn)
                        {
                            Functions._customFunctions[name] = new Functions.Function(name, 0, 255);
                            fn = Functions[name.toUpperCase()]
                        }
                        else if (!options || !options.override)
                        {
                            throw Sheets.SR.Exp_OverrideNotAllowed;
                        }
                    }
                    if (fnEvaluate && typeof fnEvaluate === "function")
                    {
                        fn.evaluate = fnEvaluate
                    }
                    if (options)
                    {
                        for (var prop in options)
                        {
                            if (options.hasOwnProperty(prop) && prop !== 'override')
                            {
                                fn[prop] = options[prop]
                            }
                        }
                    }
                    return fn
                }
                Functions.defineGlobalCustomFunction = defineGlobalCustomFunction;
                function findGlobalFunction(name)
                {
                    if (name === keyword_undefined || name === keyword_null)
                    {
                        return keyword_null
                    }
                    name = name.toUpperCase();
                    if (Functions._builtInFunctions && Functions._builtInFunctions.hasOwnProperty(name))
                    {
                        return Functions._builtInFunctions[name]
                    }
                    if (Functions._customFunctions.hasOwnProperty(name))
                    {
                        return Functions._customFunctions[name]
                    }
                    return keyword_null
                }
                Functions.findGlobalFunction = findGlobalFunction;
                $.extend({ce: {
                        createFunction: function(name, fnEvaluate, options)
                        {
                            return Functions.Function._create(name, fnEvaluate, options)
                        }, defineGlobalCustomFunction: function(name, fnEvaluate, options)
                            {
                                return Functions.defineGlobalCustomFunction(name, fnEvaluate, options)
                            }, findGlobalFunction: function(name)
                            {
                                return Functions.findGlobalFunction(name)
                            }
                    }})
            })(Calc.Functions || (Calc.Functions = {}));
            var Functions = Calc.Functions;
            var RangeType = {
                    cell: 0, row: 1, column: 2, sheet: 3
                };
            function getRangeForCellReference(baseRow, baseColumn)
            {
                var self = this;
                var myRange = {
                        row: self.row, column: self.column, rowCount: 1, columnCount: 1
                    };
                if (self.rowRelative)
                {
                    myRange.row += baseRow;
                    myRange.row = myRange.row >= Parser.maxRowCount ? myRange.row % Parser.maxRowCount : myRange.row
                }
                if (self.columnRelative)
                {
                    myRange.column += baseColumn;
                    myRange.column = myRange.column >= Parser.maxColumnCount ? myRange.column % Parser.maxColumnCount : myRange.column
                }
                return myRange
            }
            function getRangeForRangeReference(baseRow, baseColumn)
            {
                var range = {
                        row: -1, column: -1, rowCount: -1, columnCount: -1
                    },
                    startRow,
                    endRow,
                    startCol,
                    endCol,
                    self = this;
                if (self.isFullRow)
                {
                    range.column = -1;
                    range.columnCount = -1
                }
                else
                {
                    if (self.startColumnRelative)
                    {
                        startCol = self.startColumn + baseColumn;
                        startCol = startCol >= Parser.maxColumnCount ? startCol % Parser.maxColumnCount : startCol
                    }
                    else
                    {
                        startCol = self.startColumn
                    }
                    if (self.endColumnRelative)
                    {
                        endCol = self.endColumn + baseColumn;
                        endCol = endCol >= Parser.maxColumnCount ? endCol % Parser.maxColumnCount : endCol
                    }
                    else
                    {
                        endCol = self.endColumn
                    }
                    range.column = startCol <= endCol ? startCol : endCol;
                    range.columnCount = Math_abs(endCol - startCol) + 1
                }
                if (self.isFullColumn)
                {
                    range.row = -1;
                    range.rowCount = -1
                }
                else
                {
                    if (self.startRowRelative)
                    {
                        startRow = self.startRow + baseRow;
                        startRow = startRow >= Parser.maxRowCount ? startRow % Parser.maxRowCount : startRow
                    }
                    else
                    {
                        startRow = self.startRow
                    }
                    if (self.endRowRelative)
                    {
                        endRow = self.endRow + baseRow;
                        endRow = endRow >= Parser.maxRowCount ? endRow % Parser.maxRowCount : endRow
                    }
                    else
                    {
                        endRow = self.endRow
                    }
                    range.row = startRow <= endRow ? startRow : endRow;
                    range.rowCount = Math_abs(endRow - startRow) + 1
                }
                return range
            }
            (function(Expressions)
            {
                var Expression = (function()
                    {
                        function Expression(){}
                        Expression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            return this
                        };
                        return Expression
                    })();
                Expressions.Expression = Expression;
                var ParenthesesExpression = (function(_super)
                    {
                        __extends(ParenthesesExpression, _super);
                        function ParenthesesExpression(arg)
                        {
                            _super.call(this);
                            this.argument = arg;
                            this.t = 14
                        }
                        ParenthesesExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            return this.argument.offset(row, col, offsetAbsolute)
                        };
                        return ParenthesesExpression
                    })(Expression);
                Expressions.ParenthesesExpression = ParenthesesExpression;
                var FunctionExpression = (function(_super)
                    {
                        __extends(FunctionExpression, _super);
                        function FunctionExpression(fn, args)
                        {
                            _super.call(this);
                            this.fn = fn;
                            this.args = args;
                            this.t = 7
                        }
                        FunctionExpression.prototype.argCount = function()
                        {
                            return this.args ? this.args.length : 0
                        };
                        FunctionExpression.prototype.getArg = function(index)
                        {
                            return this.args ? this.args[index] : keyword_null
                        };
                        FunctionExpression.prototype.getFunctionName = function()
                        {
                            var self = this;
                            return typeof(self.fn) === const_string ? self.fn : self.fn.name
                        };
                        FunctionExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var args = this.args,
                                newArgs = [];
                            for (var i = 0; i < args.length; i++)
                            {
                                newArgs.push(args[i].offset(row, col, offsetAbsolute))
                            }
                            return new FunctionExpression(this.fn, newArgs)
                        };
                        return FunctionExpression
                    })(Expression);
                Expressions.FunctionExpression = FunctionExpression;
                var NameExpression = (function(_super)
                    {
                        __extends(NameExpression, _super);
                        function NameExpression(name)
                        {
                            _super.call(this);
                            this.name = name;
                            this.t = 8
                        }
                        return NameExpression
                    })(Expression);
                Expressions.NameExpression = NameExpression;
                var BangNameExpression = (function(_super)
                    {
                        __extends(BangNameExpression, _super);
                        function BangNameExpression(name)
                        {
                            _super.call(this, name);
                            this.t = 18
                        }
                        return BangNameExpression
                    })(NameExpression);
                Expressions.BangNameExpression = BangNameExpression;
                var ExternalNameExpression = (function(_super)
                    {
                        __extends(ExternalNameExpression, _super);
                        function ExternalNameExpression(source, name)
                        {
                            _super.call(this, name);
                            this.source = source;
                            this.t = 9
                        }
                        return ExternalNameExpression
                    })(NameExpression);
                Expressions.ExternalNameExpression = ExternalNameExpression;
                var ConstantExpression = (function(_super)
                    {
                        __extends(ConstantExpression, _super);
                        function ConstantExpression(value)
                        {
                            _super.call(this);
                            this.value = value
                        }
                        return ConstantExpression
                    })(Expression);
                Expressions.ConstantExpression = ConstantExpression;
                var BooleanExpression = (function(_super)
                    {
                        __extends(BooleanExpression, _super);
                        function BooleanExpression(value)
                        {
                            _super.call(this, value);
                            this.t = 6
                        }
                        return BooleanExpression
                    })(ConstantExpression);
                Expressions.BooleanExpression = BooleanExpression;
                var DoubleExpression = (function(_super)
                    {
                        __extends(DoubleExpression, _super);
                        function DoubleExpression(value, originalNumAsString)
                        {
                            _super.call(this, value);
                            this.originalValue = originalNumAsString;
                            this.t = 4
                        }
                        return DoubleExpression
                    })(ConstantExpression);
                Expressions.DoubleExpression = DoubleExpression;
                var StringExpression = (function(_super)
                    {
                        __extends(StringExpression, _super);
                        function StringExpression(value)
                        {
                            _super.call(this, value);
                            this.t = 5
                        }
                        return StringExpression
                    })(ConstantExpression);
                Expressions.StringExpression = StringExpression;
                var ErrorExpression = (function(_super)
                    {
                        __extends(ErrorExpression, _super);
                        function ErrorExpression(value)
                        {
                            _super.call(this, value);
                            this.t = 12
                        }
                        return ErrorExpression
                    })(ConstantExpression);
                Expressions.ErrorExpression = ErrorExpression;
                var ExternalErrorExpression = (function(_super)
                    {
                        __extends(ExternalErrorExpression, _super);
                        function ExternalErrorExpression(source, value)
                        {
                            _super.call(this, value);
                            this.source = source;
                            this.t = 13
                        }
                        return ExternalErrorExpression
                    })(ErrorExpression);
                Expressions.ExternalErrorExpression = ExternalErrorExpression;
                var SheetRangeErrorExpression = (function(_super)
                    {
                        __extends(SheetRangeErrorExpression, _super);
                        function SheetRangeErrorExpression(startSource, endSource, value)
                        {
                            _super.call(this, value);
                            this.startSource = startSource;
                            this.endSource = endSource;
                            this.t = 19
                        }
                        return SheetRangeErrorExpression
                    })(ErrorExpression);
                Expressions.SheetRangeErrorExpression = SheetRangeErrorExpression;
                var BangErrorExpression = (function(_super)
                    {
                        __extends(BangErrorExpression, _super);
                        function BangErrorExpression(value)
                        {
                            _super.call(this, value);
                            this.t = 20
                        }
                        return BangErrorExpression
                    })(ErrorExpression);
                Expressions.BangErrorExpression = BangErrorExpression;
                var ArrayExpression = (function(_super)
                    {
                        __extends(ArrayExpression, _super);
                        function ArrayExpression(value)
                        {
                            _super.call(this, new _ConcreteArray(value));
                            this.t = 15
                        }
                        return ArrayExpression
                    })(ConstantExpression);
                Expressions.ArrayExpression = ArrayExpression;
                var MissingArgumentExpression = (function(_super)
                    {
                        __extends(MissingArgumentExpression, _super);
                        function MissingArgumentExpression()
                        {
                            _super.call(this, Calc.missingArgument);
                            this.t = 21
                        }
                        return MissingArgumentExpression
                    })(ConstantExpression);
                Expressions.MissingArgumentExpression = MissingArgumentExpression;
                var OperatorExpression = (function(_super)
                    {
                        __extends(OperatorExpression, _super);
                        function OperatorExpression(operator)
                        {
                            _super.call(this);
                            this.operator = operator
                        }
                        return OperatorExpression
                    })(Expression);
                Expressions.OperatorExpression = OperatorExpression;
                var UnaryOperatorExpression = (function(_super)
                    {
                        __extends(UnaryOperatorExpression, _super);
                        function UnaryOperatorExpression(operator, operand)
                        {
                            _super.call(this, operator);
                            this.operand = operand;
                            this.t = 11
                        }
                        UnaryOperatorExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            return new UnaryOperatorExpression(this.operator, this.operand.offset(row, col, offsetAbsolute))
                        };
                        return UnaryOperatorExpression
                    })(OperatorExpression);
                Expressions.UnaryOperatorExpression = UnaryOperatorExpression;
                var BinaryOperatorExpression = (function(_super)
                    {
                        __extends(BinaryOperatorExpression, _super);
                        function BinaryOperatorExpression(operator, left, right)
                        {
                            _super.call(this, operator);
                            this.left = left;
                            this.right = right;
                            this.t = 10
                        }
                        BinaryOperatorExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            return new BinaryOperatorExpression(this.operator, this.left.offset(row, col, offsetAbsolute), this.right.offset(row, col, offsetAbsolute))
                        };
                        return BinaryOperatorExpression
                    })(OperatorExpression);
                Expressions.BinaryOperatorExpression = BinaryOperatorExpression;
                var ReferenceExpression = (function(_super)
                    {
                        __extends(ReferenceExpression, _super);
                        function ReferenceExpression()
                        {
                            _super.call(this)
                        }
                        ReferenceExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return keyword_null
                        };
                        return ReferenceExpression
                    })(Expression);
                Expressions.ReferenceExpression = ReferenceExpression;
                var ExternalReferenceExpression = (function(_super)
                    {
                        __extends(ExternalReferenceExpression, _super);
                        function ExternalReferenceExpression(source)
                        {
                            _super.call(this);
                            this.source = source
                        }
                        return ExternalReferenceExpression
                    })(ReferenceExpression);
                Expressions.ExternalReferenceExpression = ExternalReferenceExpression;
                var CellExpression = (function(_super)
                    {
                        __extends(CellExpression, _super);
                        function CellExpression(row, column, rowRelative, columnRelative)
                        {
                            _super.call(this);
                            var self = this;
                            self.row = row;
                            self.column = column;
                            self.rowRelative = rowRelative;
                            self.columnRelative = columnRelative;
                            this.t = 0
                        }
                        CellExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return getRangeForCellReference.call(this, baseRow, baseColumn)
                        };
                        CellExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            return new CellExpression(self.row + ((self.rowRelative || offsetAbsolute) ? row : 0), self.column + ((self.columnRelative || offsetAbsolute) ? col : 0), self.rowRelative, self.columnRelative)
                        };
                        return CellExpression
                    })(ReferenceExpression);
                Expressions.CellExpression = CellExpression;
                var BangCellExpression = (function(_super)
                    {
                        __extends(BangCellExpression, _super);
                        function BangCellExpression(row, column, rowRelative, columnRelative)
                        {
                            _super.call(this, row, column, rowRelative, columnRelative);
                            this.t = 22
                        }
                        BangCellExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            return new BangCellExpression(self.row + ((self.rowRelative || offsetAbsolute) ? row : 0), self.column + ((self.columnRelative || offsetAbsolute) ? col : 0), self.rowRelative, self.columnRelative)
                        };
                        return BangCellExpression
                    })(CellExpression);
                Expressions.BangCellExpression = BangCellExpression;
                var ExternalCellExpression = (function(_super)
                    {
                        __extends(ExternalCellExpression, _super);
                        function ExternalCellExpression(source, row, column, rowRelative, columnRelative)
                        {
                            _super.call(this, source);
                            var self = this;
                            self.row = row;
                            self.column = column;
                            self.rowRelative = rowRelative;
                            self.columnRelative = columnRelative;
                            this.t = 1
                        }
                        ExternalCellExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return getRangeForCellReference.call(this, baseRow, baseColumn)
                        };
                        ExternalCellExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            return new ExternalCellExpression(self.source, self.row + ((self.rowRelative || offsetAbsolute) ? row : 0), self.column + ((self.columnRelative || offsetAbsolute) ? col : 0), self.rowRelative, self.columnRelative)
                        };
                        return ExternalCellExpression
                    })(ExternalReferenceExpression);
                Expressions.ExternalCellExpression = ExternalCellExpression;
                var RangeExpression = (function(_super)
                    {
                        __extends(RangeExpression, _super);
                        function RangeExpression(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            _super.call(this);
                            if (arguments.length === 0)
                            {
                                this._initDefault()
                            }
                            else
                            {
                                this.init(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                            }
                            this.t = 2
                        }
                        RangeExpression.prototype._initDefault = function()
                        {
                            var bandIndex = Parser.BAND_INDEX_CONST;
                            var self = this;
                            self.init(bandIndex, bandIndex, bandIndex, bandIndex, false, false, false, false);
                            self.isFullRow = true;
                            self.isFullColumn = true
                        };
                        RangeExpression.prototype.init = function(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            var self = this;
                            if (startRowRelative === endRowRelative && startRow > endRow)
                            {
                                self.startRow = endRow;
                                self.endRow = startRow;
                                self.startRowRelative = endRowRelative;
                                self.endRowRelative = startRowRelative
                            }
                            else
                            {
                                self.startRow = startRow;
                                self.endRow = endRow;
                                self.startRowRelative = startRowRelative;
                                self.endRowRelative = endRowRelative
                            }
                            if (startColumnRelative === endColumnRelative && startColumn > endColumn)
                            {
                                self.startColumn = endColumn;
                                self.endColumn = startColumn;
                                self.startColumnRelative = endColumnRelative;
                                self.endColumnRelative = startColumnRelative
                            }
                            else
                            {
                                self.startColumn = startColumn;
                                self.endColumn = endColumn;
                                self.startColumnRelative = startColumnRelative;
                                self.endColumnRelative = endColumnRelative
                            }
                            self.isFullRow = false;
                            self.isFullColumn = false
                        };
                        RangeExpression.prototype.initBand = function(startBandIndex, endBandIndex, startBandRelative, endBandRelative, isRowBand)
                        {
                            if (startBandIndex > endBandIndex)
                            {
                                var tmpIndex = startBandIndex;
                                startBandIndex = endBandIndex;
                                endBandIndex = tmpIndex;
                                var tmpRelative = startBandRelative;
                                startBandRelative = endBandRelative;
                                endBandRelative = tmpRelative
                            }
                            var self = this;
                            if (isRowBand)
                            {
                                self.startRow = startBandIndex;
                                self.startColumn = Parser.BAND_INDEX_CONST;
                                self.endRow = endBandIndex;
                                self.endColumn = Parser.BAND_INDEX_CONST;
                                self.startRowRelative = startBandRelative;
                                self.startColumnRelative = false;
                                self.endRowRelative = endBandRelative;
                                self.endColumnRelative = false;
                                self.isFullRow = true;
                                self.isFullColumn = false
                            }
                            else
                            {
                                self.startRow = Parser.BAND_INDEX_CONST;
                                self.startColumn = startBandIndex;
                                self.endRow = Parser.BAND_INDEX_CONST;
                                self.endColumn = endBandIndex;
                                self.startRowRelative = false;
                                self.startColumnRelative = startBandRelative;
                                self.endRowRelative = false;
                                self.endColumnRelative = endBandRelative;
                                self.isFullRow = false;
                                self.isFullColumn = true
                            }
                        };
                        RangeExpression.prototype._getRangeType = function()
                        {
                            var self = this;
                            if (self.isFullRow && self.isFullColumn)
                            {
                                return RangeType.sheet
                            }
                            else if (self.isFullRow)
                            {
                                return RangeType.row
                            }
                            else if (self.isFullColumn)
                            {
                                return RangeType.column
                            }
                            else
                            {
                                return RangeType.cell
                            }
                        };
                        RangeExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return getRangeForRangeReference.call(this, baseRow, baseColumn)
                        };
                        RangeExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            var newExpr = new Expressions.RangeExpression(self.startRow + (!self.isFullColumn && (self.startRowRelative || offsetAbsolute) ? row : 0), self.startColumn + (!self.isFullRow && (self.startColumnRelative || offsetAbsolute) ? col : 0), self.endRow + (!self.isFullColumn && (self.endRowRelative || offsetAbsolute) ? row : 0), self.endColumn + (!self.isFullRow && (self.endColumnRelative || offsetAbsolute) ? col : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        RangeExpression.prototype.offset2 = function(row, col, endRow, endCol)
                        {
                            var self = this;
                            var newExpr = new Expressions.RangeExpression(self.startRow + (!self.isFullColumn ? row : 0), self.startColumn + (!self.isFullRow ? col : 0), self.endRow + (!self.isFullColumn ? endRow : 0), self.endColumn + (!self.isFullRow ? endCol : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        return RangeExpression
                    })(ReferenceExpression);
                Expressions.RangeExpression = RangeExpression;
                var BangRangeExpression = (function(_super)
                    {
                        __extends(BangRangeExpression, _super);
                        function BangRangeExpression(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            _super.call(this, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative);
                            this.t = 23
                        }
                        BangRangeExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            var newExpr = new Expressions.BangRangeExpression(self.startRow + (!self.isFullColumn && (self.startRowRelative || offsetAbsolute) ? row : 0), self.startColumn + (!self.isFullRow && (self.startColumnRelative || offsetAbsolute) ? col : 0), self.endRow + (!self.isFullColumn && (self.endRowRelative || offsetAbsolute) ? row : 0), self.endColumn + (!self.isFullRow && (self.endColumnRelative || offsetAbsolute) ? col : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        return BangRangeExpression
                    })(RangeExpression);
                Expressions.BangRangeExpression = BangRangeExpression;
                var ExternalRangeExpression = (function(_super)
                    {
                        __extends(ExternalRangeExpression, _super);
                        function ExternalRangeExpression(source, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            _super.call(this, keyword_null);
                            if (arguments.length === 1)
                            {
                                this._initDefault(source)
                            }
                            else
                            {
                                this.init(source, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                            }
                            this.t = 3
                        }
                        ExternalRangeExpression.prototype._initDefault = function(source)
                        {
                            var bandIndex = Parser.BAND_INDEX_CONST;
                            var self = this;
                            self.init(source, bandIndex, bandIndex, bandIndex, bandIndex, false, false, false, false);
                            self.isFullRow = true;
                            self.isFullColumn = true
                        };
                        ExternalRangeExpression.prototype.init = function(source, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            var self = this;
                            self.source = source;
                            if (startRowRelative === endRowRelative && startRow > endRow)
                            {
                                self.startRow = endRow;
                                self.endRow = startRow;
                                self.startRowRelative = endRowRelative;
                                self.endRowRelative = startRowRelative
                            }
                            else
                            {
                                self.startRow = startRow;
                                self.endRow = endRow;
                                self.startRowRelative = startRowRelative;
                                self.endRowRelative = endRowRelative
                            }
                            if (startColumnRelative === endColumnRelative && startColumn > endColumn)
                            {
                                self.startColumn = endColumn;
                                self.endColumn = startColumn;
                                self.startColumnRelative = endColumnRelative;
                                self.endColumnRelative = startColumnRelative
                            }
                            else
                            {
                                self.startColumn = startColumn;
                                self.endColumn = endColumn;
                                self.startColumnRelative = startColumnRelative;
                                self.endColumnRelative = endColumnRelative
                            }
                        };
                        ExternalRangeExpression.prototype.initBand = function(source, startBandIndex, endBandIndex, startBandRelative, endBandRelative, isRowBand)
                        {
                            var self = this;
                            self.source = source;
                            if (startBandIndex > endBandIndex)
                            {
                                var tmpIndex = startBandIndex;
                                startBandIndex = endBandIndex;
                                endBandIndex = tmpIndex;
                                var tmpRelative = startBandRelative;
                                startBandRelative = endBandRelative;
                                endBandRelative = tmpRelative
                            }
                            if (isRowBand)
                            {
                                self.startRow = startBandIndex;
                                self.startColumn = Parser.BAND_INDEX_CONST;
                                self.endRow = endBandIndex;
                                self.endColumn = Parser.BAND_INDEX_CONST;
                                self.startRowRelative = startBandRelative;
                                self.startColumnRelative = false;
                                self.endRowRelative = endBandRelative;
                                self.endColumnRelative = false;
                                self.isFullRow = true
                            }
                            else
                            {
                                self.startRow = Parser.BAND_INDEX_CONST;
                                self.startColumn = startBandIndex;
                                self.endRow = Parser.BAND_INDEX_CONST;
                                self.endColumn = endBandIndex;
                                self.startRowRelative = false;
                                self.startColumnRelative = startBandRelative;
                                self.endRowRelative = false;
                                self.endColumnRelative = endBandRelative;
                                self.isFullColumn = true
                            }
                        };
                        ExternalRangeExpression.prototype._getRangeType = function()
                        {
                            var self = this;
                            if (self.isFullRow && self.isFullColumn)
                            {
                                return RangeType.sheet
                            }
                            else if (self.isFullRow)
                            {
                                return RangeType.row
                            }
                            else if (self.isFullColumn)
                            {
                                return RangeType.column
                            }
                            else
                            {
                                return RangeType.cell
                            }
                        };
                        ExternalRangeExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return getRangeForRangeReference.call(this, baseRow, baseColumn)
                        };
                        ExternalRangeExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            var newExpr = new Expressions.ExternalRangeExpression(self.source, self.startRow + (!self.isFullColumn && (self.startRowRelative || offsetAbsolute) ? row : 0), self.startColumn + (!self.isFullRow && (self.startColumnRelative || offsetAbsolute) ? col : 0), self.endRow + (!self.isFullColumn && (self.endRowRelative || offsetAbsolute) ? row : 0), self.endColumn + (!self.isFullRow && (self.endColumnRelative || offsetAbsolute) ? col : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        ExternalRangeExpression.prototype.offset2 = function(row, col, endRow, endCol)
                        {
                            var self = this;
                            var newExpr = new Expressions.ExternalRangeExpression(self.source, self.startRow + (!self.isFullColumn ? row : 0), self.startColumn + (!self.isFullRow ? col : 0), self.endRow + (!self.isFullColumn ? endRow : 0), self.endColumn + (!self.isFullRow ? endCol : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        return ExternalRangeExpression
                    })(ExternalReferenceExpression);
                Expressions.ExternalRangeExpression = ExternalRangeExpression;
                var SheetRangeExpression = (function(_super)
                    {
                        __extends(SheetRangeExpression, _super);
                        function SheetRangeExpression(startSource, endSource, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            _super.call(this);
                            this.init(startSource, endSource, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative);
                            this.t = 16
                        }
                        SheetRangeExpression.prototype.init = function(startSource, endSource, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                        {
                            var self = this;
                            self.startSource = startSource;
                            self.endSource = endSource;
                            if (startRowRelative === endRowRelative && startRow > endRow)
                            {
                                self.startRow = endRow;
                                self.endRow = startRow;
                                self.startRowRelative = endRowRelative;
                                self.endRowRelative = startRowRelative
                            }
                            else
                            {
                                self.startRow = startRow;
                                self.endRow = endRow;
                                self.startRowRelative = startRowRelative;
                                self.endRowRelative = endRowRelative
                            }
                            if (startColumnRelative === endColumnRelative && startColumn > endColumn)
                            {
                                self.startColumn = endColumn;
                                self.endColumn = startColumn;
                                self.startColumnRelative = endColumnRelative;
                                self.endColumnRelative = startColumnRelative
                            }
                            else
                            {
                                self.startColumn = startColumn;
                                self.endColumn = endColumn;
                                self.startColumnRelative = startColumnRelative;
                                self.endColumnRelative = endColumnRelative
                            }
                        };
                        SheetRangeExpression.prototype.initBand = function(startSource, endSource, startBandIndex, endBandIndex, startBandRelative, endBandRelative, isRowBand)
                        {
                            var self = this;
                            self.startSource = startSource;
                            self.endSource = endSource;
                            if (startBandIndex > endBandIndex)
                            {
                                var tmpIndex = startBandIndex;
                                startBandIndex = endBandIndex;
                                endBandIndex = tmpIndex;
                                var tmpRelative = startBandRelative;
                                startBandRelative = endBandRelative;
                                endBandRelative = tmpRelative
                            }
                            if (isRowBand)
                            {
                                self.startRow = startBandIndex;
                                self.startColumn = Parser.BAND_INDEX_CONST;
                                self.endRow = endBandIndex;
                                self.endColumn = Parser.BAND_INDEX_CONST;
                                self.startRowRelative = startBandRelative;
                                self.startColumnRelative = false;
                                self.endRowRelative = endBandRelative;
                                self.endColumnRelative = false;
                                self.isFullRow = true
                            }
                            else
                            {
                                self.startRow = Parser.BAND_INDEX_CONST;
                                self.startColumn = startBandIndex;
                                self.endRow = Parser.BAND_INDEX_CONST;
                                self.endColumn = endBandIndex;
                                self.startRowRelative = false;
                                self.startColumnRelative = startBandRelative;
                                self.endRowRelative = false;
                                self.endColumnRelative = endBandRelative;
                                self.isFullColumn = true
                            }
                        };
                        SheetRangeExpression.prototype.getRange = function(baseRow, baseColumn)
                        {
                            return getRangeForRangeReference.call(this, baseRow, baseColumn)
                        };
                        SheetRangeExpression.prototype._getRangeType = function()
                        {
                            var self = this;
                            if (self.isFullRow && self.isFullColumn)
                            {
                                return RangeType.sheet
                            }
                            else if (self.isFullRow)
                            {
                                return RangeType.row
                            }
                            else if (self.isFullColumn)
                            {
                                return RangeType.column
                            }
                            else
                            {
                                return RangeType.cell
                            }
                        };
                        SheetRangeExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            var newExpr = new Expressions.SheetRangeExpression(self.startSource, self.endSource, self.startRow + (!self.isFullColumn && (self.startRowRelative || offsetAbsolute) ? row : 0), self.startColumn + (!self.isFullRow && (self.startColumnRelative || offsetAbsolute) ? col : 0), self.endRow + (!self.isFullColumn && (self.endRowRelative || offsetAbsolute) ? row : 0), self.endColumn + (!self.isFullRow && (self.endColumnRelative || offsetAbsolute) ? col : 0), self.startRowRelative, self.startColumnRelative, self.endRowRelative, self.endColumnRelative);
                            newExpr.isFullRow = self.isFullRow;
                            newExpr.isFullColumn = self.isFullColumn;
                            return newExpr
                        };
                        return SheetRangeExpression
                    })(ReferenceExpression);
                Expressions.SheetRangeExpression = SheetRangeExpression;
                var StructReferenceExpression = (function(_super)
                    {
                        __extends(StructReferenceExpression, _super);
                        function StructReferenceExpression(structRef, context)
                        {
                            _super.call(this);
                            if (context !== keyword_null && structRef)
                            {
                                this._parseStructReferenceString(context, structRef)
                            }
                            this.t = 17
                        }
                        StructReferenceExpression.create = function(table, referencePortions, referenceColumnSpecifier, columnReferenceStartInTable, columnReferenceEndInTable)
                        {
                            if (typeof referencePortions === "undefined")
                            {
                                referencePortions = 16
                            }
                            if (typeof referenceColumnSpecifier === "undefined")
                            {
                                referenceColumnSpecifier = 1
                            }
                            if (typeof columnReferenceStartInTable === "undefined")
                            {
                                columnReferenceStartInTable = 0
                            }
                            if (typeof columnReferenceEndInTable === "undefined")
                            {
                                columnReferenceEndInTable = table.endColumn() - table.startColumn()
                            }
                            var expr = new StructReferenceExpression(keyword_null, keyword_null);
                            expr._baseTable = table;
                            expr._referencePortions = referencePortions;
                            expr._columnReferenceStartInTable = columnReferenceStartInTable;
                            expr._columnReferenceEndInTable = columnReferenceEndInTable;
                            expr._referenceColumnSpecifier = referenceColumnSpecifier;
                            return expr
                        };
                        StructReferenceExpression.prototype.tableName = function()
                        {
                            return this._baseTable.tableName()
                        };
                        StructReferenceExpression.prototype._updateCatch = function()
                        {
                            this._catchedTableStartColumn = this._baseTable.startColumn()
                        };
                        StructReferenceExpression.prototype.columnReferenceStart = function()
                        {
                            return this._columnReferenceStartInTable + this._baseTable.startColumn()
                        };
                        StructReferenceExpression.prototype.columnReferenceEnd = function()
                        {
                            return this._columnReferenceEndInTable + this._baseTable.startColumn()
                        };
                        StructReferenceExpression.prototype.referencePortions = function()
                        {
                            return this._referencePortions
                        };
                        StructReferenceExpression.prototype.referenceColumnSpecifier = function()
                        {
                            return this._referenceColumnSpecifier
                        };
                        StructReferenceExpression.prototype.source = function()
                        {
                            return this._baseTable.source()
                        };
                        StructReferenceExpression.prototype.getRange = function(baseRow, baseColumn, getReference)
                        {
                            var self = this;
                            self._updateCatch();
                            var startRow,
                                startColumn,
                                endRow,
                                endColumn,
                                rowCount,
                                columnCount;
                            var tableStartRow = self._baseTable.startRow();
                            var tableEndRow = self._baseTable.endRow();
                            var tableHasTotalRow = self._baseTable.hasTotalsRow();
                            var tableHasHeadersRow = self._baseTable.hasHeadersRow();
                            switch (self._referencePortions)
                            {
                                case 3:
                                case 16:
                                    startRow = tableHasHeadersRow ? tableStartRow + 1 : tableStartRow;
                                    endRow = tableHasTotalRow ? tableEndRow - 1 : tableEndRow;
                                    break;
                                case 2:
                                    if (!tableHasHeadersRow)
                                    {
                                        if (getReference)
                                        {
                                            startRow = tableStartRow - 1;
                                            endRow = tableStartRow - 1
                                        }
                                        else
                                        {
                                            return keyword_null
                                        }
                                    }
                                    else
                                    {
                                        startRow = tableStartRow;
                                        endRow = tableStartRow
                                    }
                                    break;
                                case 8:
                                    if (!tableHasTotalRow)
                                    {
                                        if (getReference)
                                        {
                                            startRow = tableEndRow + 1;
                                            endRow = tableEndRow + 1
                                        }
                                        else
                                        {
                                            return keyword_null
                                        }
                                    }
                                    else
                                    {
                                        startRow = tableEndRow;
                                        endRow = tableEndRow
                                    }
                                    break;
                                case 1:
                                    startRow = baseRow;
                                    endRow = baseRow;
                                    break;
                                case 6:
                                    startRow = tableStartRow + (getReference && !tableHasHeadersRow ? -1 : 0);
                                    endRow = tableHasTotalRow ? tableEndRow - 1 : tableEndRow;
                                    break;
                                case 12:
                                    startRow = tableHasHeadersRow ? tableStartRow + 1 : tableStartRow;
                                    endRow = tableEndRow + (getReference && !tableHasTotalRow ? 1 : 0);
                                    ;
                                    break;
                                case 14:
                                default:
                                    startRow = tableStartRow + (getReference && !tableHasHeadersRow ? -1 : 0);
                                    endRow = tableEndRow + (getReference && !tableHasTotalRow ? 1 : 0);
                                    ;
                                    break
                            }
                            startColumn = self.columnReferenceStart();
                            endColumn = self.columnReferenceEnd();
                            if (endRow < startRow || !getReference && startRow < tableStartRow || !getReference && endRow > tableEndRow)
                            {
                                return keyword_null
                            }
                            rowCount = endRow - startRow + 1;
                            columnCount = endColumn - startColumn + 1;
                            var range = {
                                    row: startRow, column: startColumn, rowCount: rowCount, columnCount: columnCount
                                };
                            return range
                        };
                        StructReferenceExpression.prototype._parseStructReferenceString = function(context, structReference)
                        {
                            var selfClass = StructReferenceExpression;
                            var self = this;
                            structReference = structReference.trim();
                            var charIndex = 0;
                            var currentChar = structReference.charAt(charIndex);
                            var rs = selfClass._parseTableObject(context, structReference, charIndex, currentChar);
                            if (rs.table === keyword_null)
                            {
                                selfClass._throwError()
                            }
                            var table = rs.table;
                            self._baseTable = table;
                            charIndex = rs.charIndex;
                            currentChar = rs.currentChar;
                            charIndex++;
                            currentChar = structReference.charAt(charIndex);
                            while (currentChar === ' ')
                            {
                                charIndex++;
                                currentChar = structReference.charAt(charIndex)
                            }
                            var lbracketLever = 1;
                            var hasPortion = false;
                            var hasColumn = false;
                            var structLen = structReference.length;
                            while (lbracketLever !== 0 && charIndex < structLen)
                            {
                                if (currentChar === '[')
                                {
                                    lbracketLever++;
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex)
                                }
                                if (currentChar === '#')
                                {
                                    if (hasPortion && lbracketLever <= 1)
                                    {
                                        selfClass._throwError()
                                    }
                                    rs = selfClass._parsePortion(structReference, charIndex, currentChar, lbracketLever);
                                    var portion = rs.portion;
                                    charIndex = rs.charIndex;
                                    currentChar = rs.currentChar;
                                    lbracketLever = rs.lbracketLever;
                                    if (hasPortion)
                                    {
                                        if (self._referencePortions === 2 && portion === 3 || portion === 2 && self._referencePortions === 3)
                                        {
                                            self._referencePortions = 6
                                        }
                                        else if (self._referencePortions === 3 && portion === 8 || portion === 3 && self._referencePortions === 8)
                                        {
                                            self._referencePortions = 12
                                        }
                                        else
                                        {
                                            selfClass._throwError()
                                        }
                                    }
                                    else
                                    {
                                        self._referencePortions = portion
                                    }
                                    hasPortion = true
                                }
                                else if (currentChar === '@')
                                {
                                    if (lbracketLever > 1 || hasPortion)
                                    {
                                        selfClass._throwError()
                                    }
                                    hasPortion = true;
                                    self._referencePortions = 1;
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex);
                                    while (currentChar === ' ')
                                    {
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                    if (currentChar === ',')
                                    {
                                        selfClass._throwError()
                                    }
                                }
                                else
                                {
                                    var columnsStartIndex = charIndex;
                                    var lastIsComma = false;
                                    while (currentChar !== ']' && currentChar !== '[')
                                    {
                                        if (currentChar === '\'')
                                        {
                                            charIndex++
                                        }
                                        if (currentChar === ',')
                                        {
                                            charIndex++;
                                            currentChar = structReference.charAt(charIndex);
                                            var commaIndex = charIndex;
                                            while (currentChar === ' ')
                                            {
                                                charIndex++;
                                                currentChar = structReference.charAt(charIndex)
                                            }
                                            if (currentChar === '[')
                                            {
                                                charIndex = commaIndex;
                                                currentChar = ',';
                                                break
                                            }
                                        }
                                        else
                                        {
                                            charIndex++;
                                            currentChar = structReference.charAt(charIndex)
                                        }
                                    }
                                    if (charIndex > columnsStartIndex)
                                    {
                                        if (hasColumn || currentChar === '[' && lbracketLever > 1)
                                        {
                                            selfClass._throwError()
                                        }
                                        rs = self._parseColumnRange(structReference, charIndex, currentChar, lbracketLever, columnsStartIndex);
                                        charIndex = rs.charIndex;
                                        currentChar = rs.currentChar;
                                        lbracketLever = rs.lbracketLever;
                                        hasColumn = true
                                    }
                                    if (currentChar === ']')
                                    {
                                        lbracketLever--;
                                        if (lbracketLever === 0)
                                        {
                                            break
                                        }
                                        else if (charIndex >= structReference.length)
                                        {
                                            selfClass._throwError()
                                        }
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                    if (currentChar === ',')
                                    {
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                }
                            }
                            if (!hasPortion)
                            {
                                self._referencePortions = 16
                            }
                            if (!hasColumn)
                            {
                                self._columnReferenceStartInTable = 0;
                                self._columnReferenceEndInTable = self._baseTable.endColumn() - self._baseTable.startColumn();
                                self._referenceColumnSpecifier = 1
                            }
                        };
                        StructReferenceExpression.prototype._parseColumnRange = function(structReference, charIndex, currentChar, lbracketLever, columnsStartIndex)
                        {
                            var self = this;
                            var selfClass = StructReferenceExpression;
                            var columnStartString = "";
                            var columnEndString = "";
                            var istartStringWithBracket = false;
                            var isEndStringWithBracket = false;
                            if (lbracketLever > 1)
                            {
                                istartStringWithBracket = true;
                                lbracketLever--;
                                columnStartString = structReference.substring(columnsStartIndex, charIndex);
                                charIndex++;
                                currentChar = structReference.charAt(charIndex);
                                if (currentChar === ':')
                                {
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex);
                                    isEndStringWithBracket = currentChar === '[';
                                    var rs = selfClass._getColumnEndString(structReference, charIndex, currentChar, lbracketLever);
                                    columnEndString = rs.columnEndString;
                                    charIndex = rs.charIndex;
                                    currentChar = rs.currentChar;
                                    lbracketLever = rs.lbracketLever
                                }
                            }
                            else if (currentChar === '[')
                            {
                                isEndStringWithBracket = true;
                                var colonIndex = charIndex - 1;
                                currentChar = structReference[colonIndex];
                                while (currentChar === ' ')
                                {
                                    colonIndex--;
                                    currentChar = structReference[colonIndex]
                                }
                                if (currentChar !== ':')
                                {
                                    selfClass._throwError()
                                }
                                columnStartString = structReference.substring(columnsStartIndex, colonIndex);
                                if (!istartStringWithBracket)
                                {
                                    columnStartString = selfClass._trimStart(columnStartString)
                                }
                                currentChar = structReference.charAt(charIndex);
                                var rs = selfClass._getColumnEndString(structReference, charIndex, currentChar, lbracketLever);
                                columnEndString = rs.columnEndString;
                                charIndex = rs.charIndex;
                                currentChar = rs.currentChar;
                                lbracketLever = rs.lbracketLever
                            }
                            else
                            {
                                if (self._referencePortions === keyword_undefined || self._referencePortions === 16)
                                {
                                    istartStringWithBracket = true
                                }
                                var columnStrings = structReference.substring(columnsStartIndex, charIndex);
                                var colonIndex = columnStrings.indexOf(':');
                                if (colonIndex > 0)
                                {
                                    columnStartString = columnStrings.substring(0, colonIndex);
                                    columnStartString = columnStartString;
                                    columnEndString = columnStrings.substring(colonIndex + 1);
                                    if (columnEndString.charAt(0) !== '[')
                                    {
                                        selfClass._throwError()
                                    }
                                }
                                else
                                {
                                    columnStartString = columnStrings
                                }
                            }
                            var startIndex = self._getColumnIndex(columnStartString, istartStringWithBracket);
                            var endIndex;
                            if (columnEndString)
                            {
                                endIndex = self._getColumnIndex(columnEndString, isEndStringWithBracket);
                                self._referenceColumnSpecifier = 4
                            }
                            else
                            {
                                endIndex = startIndex;
                                self._referenceColumnSpecifier = 2
                            }
                            if (startIndex > endIndex)
                            {
                                var tmp = startIndex;
                                startIndex = endIndex;
                                endIndex = tmp
                            }
                            self._columnReferenceStartInTable = startIndex;
                            self._columnReferenceEndInTable = endIndex;
                            charIndex++;
                            if (charIndex < structReference.length)
                            {
                                currentChar = structReference.charAt(charIndex);
                                while (currentChar === ' ')
                                {
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex)
                                }
                            }
                            return {
                                    charIndex: charIndex, currentChar: currentChar, lbracketLever: lbracketLever
                                }
                        };
                        StructReferenceExpression._trimStart = function(s)
                        {
                            var i = s.length - 1;
                            while (i >= 0 && s[i] === ' ')
                            {
                                i--
                            }
                            while (i >= 0 && s[i] !== ' ')
                            {
                                i--
                            }
                            if (i >= 0)
                            {
                                return s.substr(i + 1, s.length - i - 1)
                            }
                            return s
                        };
                        StructReferenceExpression._trimEnd = function(s)
                        {
                            var i = 0,
                                length = s.length,
                                start = 0;
                            while (i < length && s[i] === ' ')
                            {
                                i++
                            }
                            start = i;
                            i = length - 1;
                            while (i > start && s[i] === ' ')
                            {
                                i++
                            }
                            if (i >= start)
                            {
                                return s.substring(start, i + 1)
                            }
                            return s
                        };
                        StructReferenceExpression.prototype._getColumnIndex = function(columnString, containsSpecial)
                        {
                            if (columnString && StructReferenceExpression._validateColumnString(columnString, containsSpecial))
                            {
                                var sb = "";
                                for (var i = 0, columnStringLength = columnString.length; i < columnStringLength; i++)
                                {
                                    if (columnString[i] === '\'' && i < columnStringLength - 1 && columnString.charAt(i + 1) !== '\'')
                                    {}
                                    else
                                    {
                                        sb += columnString.charAt(i)
                                    }
                                }
                                columnString = sb;
                                var index = this._baseTable.getColumnIndexInTable(columnString);
                                if (index < 0)
                                {
                                    StructReferenceExpression._throwError()
                                }
                                return index
                            }
                            return -1
                        };
                        StructReferenceExpression._validateColumnString = function(columnStartString, containsSpecial, throwOnError)
                        {
                            if (containsSpecial)
                            {
                                return true
                            }
                            if (arguments.length === 2)
                            {
                                throwOnError = true
                            }
                            var currentChar = "";
                            currentChar = columnStartString[0];
                            var previousChar = currentChar;
                            if (currentChar === '#' || currentChar === ' ' || currentChar === '@' || currentChar === ' ' || currentChar === ',' || currentChar === ':' || currentChar === '[' || currentChar === ']')
                            {
                                return false
                            }
                            for (var index = 1; index < columnStartString.length; index++)
                            {
                                currentChar = columnStartString[index];
                                if (currentChar === ' ' || currentChar === ',' || currentChar === ':' || currentChar === '[' && previousChar !== '\'' || currentChar === ']' && previousChar !== '\'' || currentChar === '@' && previousChar !== '\'' || currentChar === '#' && previousChar !== '\'')
                                {
                                    return false
                                }
                                previousChar = currentChar
                            }
                            return true
                        };
                        StructReferenceExpression._getValidaColumnString = function(columnStartString)
                        {
                            var currentChar = "";
                            var validaString = "";
                            currentChar = columnStartString.charAt(0);
                            for (var index = 0; index < columnStartString.length; index++)
                            {
                                currentChar = columnStartString.charAt(index);
                                if (currentChar === '[' || currentChar === ']' || currentChar === '@' || currentChar === '#')
                                {
                                    validaString += "'"
                                }
                                validaString += currentChar
                            }
                            return validaString
                        };
                        StructReferenceExpression._containsInvalidateColumnString = function(columnStartString)
                        {
                            var currentChar = "";
                            currentChar = columnStartString.charAt(0);
                            if (currentChar === '#' || currentChar === ' ' || currentChar === '@' || currentChar === ' ' || currentChar === ',' || currentChar === ':' || currentChar === '[' || currentChar === ']')
                            {
                                return true
                            }
                            for (var index = 1; index < columnStartString.length; index++)
                            {
                                currentChar = columnStartString.charAt(index);
                                if (currentChar === ' ' || currentChar === ',' || currentChar === ':' || currentChar === '[' || currentChar === ']' || currentChar === '@' || currentChar === '#')
                                {
                                    return true
                                }
                            }
                            return false
                        };
                        StructReferenceExpression._getColumnEndString = function(structReference, charIndex, currentChar, lbracketLever)
                        {
                            var inBracket = false;
                            if (currentChar === '[')
                            {
                                inBracket = true;
                                lbracketLever++;
                                charIndex++;
                                currentChar = structReference.charAt(charIndex);
                                while (currentChar === ' ')
                                {
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex)
                                }
                            }
                            var columnEndIndex = charIndex;
                            while (currentChar !== ']' && (currentChar !== ',' || lbracketLever > 1))
                            {
                                if (currentChar === '\'')
                                {
                                    charIndex++
                                }
                                charIndex++;
                                currentChar = structReference.charAt(charIndex)
                            }
                            if (charIndex <= columnEndIndex)
                            {
                                StructReferenceExpression._throwError()
                            }
                            var endString = structReference.substring(columnEndIndex, charIndex);
                            if (lbracketLever > 1)
                            {
                                lbracketLever--
                            }
                            if (!inBracket)
                            {
                                endString = StructReferenceExpression._trimEnd(endString)
                            }
                            return {
                                    columnEndString: endString, charIndex: charIndex, currentChar: currentChar, lbracketLever: lbracketLever
                                }
                        };
                        StructReferenceExpression._parsePortion = function(structReference, charIndex, currentChar, lbracketLever)
                        {
                            var selfClass = StructReferenceExpression;
                            var portion = 14;
                            var portionStartIndex = charIndex;
                            while (currentChar !== ']')
                            {
                                if (currentChar === '\'')
                                {
                                    charIndex++
                                }
                                charIndex++;
                                currentChar = structReference.charAt(charIndex)
                            }
                            var portionString = structReference.substring(portionStartIndex, charIndex).toLowerCase().trim();
                            var isPortionCorrect = false;
                            for (var i = 0; i < selfClass._structReferenceKeywordsLlowercase.length; i++)
                            {
                                var keyword = selfClass._structReferenceKeywordsLlowercase[i];
                                if (portionString === keyword)
                                {
                                    portion = selfClass._getPortion(portionString);
                                    isPortionCorrect = true;
                                    break
                                }
                            }
                            if (!isPortionCorrect)
                            {
                                selfClass._throwError()
                            }
                            charIndex++;
                            if (charIndex >= structReference.length)
                            {
                                lbracketLever--
                            }
                            else
                            {
                                currentChar = structReference.charAt(charIndex);
                                while (currentChar === ' ')
                                {
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex)
                                }
                                if (currentChar === ',')
                                {
                                    if (lbracketLever <= 1)
                                    {
                                        selfClass._throwError()
                                    }
                                    charIndex++;
                                    currentChar = structReference.charAt(charIndex);
                                    while (currentChar === ' ')
                                    {
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                    if (currentChar === '[')
                                    {
                                        lbracketLever++;
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                    while (currentChar === ' ')
                                    {
                                        charIndex++;
                                        currentChar = structReference.charAt(charIndex)
                                    }
                                }
                                if (lbracketLever > 1)
                                {
                                    lbracketLever--
                                }
                            }
                            return {
                                    portion: portion, charIndex: charIndex, currentChar: currentChar, lbracketLever: lbracketLever
                                }
                        };
                        StructReferenceExpression._getPortion = function(portionString)
                        {
                            switch (portionString)
                            {
                                case"#all":
                                    return 14;
                                case"#data":
                                    return 3;
                                case"#headers":
                                    return 2;
                                case"#totals":
                                    return 8;
                                case"#this row":
                                    return 1;
                                default:
                                    break
                            }
                            return 14
                        };
                        StructReferenceExpression._parseTableObject = function(context, structReference, charIndex, currentChar)
                        {
                            var table = keyword_null;
                            var lbracketIndex = 0;
                            var len = structReference.length;
                            while (currentChar !== '[' && charIndex < len)
                            {
                                charIndex++;
                                currentChar = structReference.charAt(charIndex)
                            }
                            lbracketIndex = charIndex;
                            if (lbracketIndex > 0)
                            {
                                var tableName = structReference.substring(0, lbracketIndex);
                                table = context.getTableByName(tableName)
                            }
                            else
                            {
                                table = context.getTableByIndex(context.row, context.column)
                            }
                            return {
                                    table: table, charIndex: charIndex, currentChar: currentChar
                                }
                        };
                        StructReferenceExpression._throwError = function()
                        {
                            throw"";
                        };
                        StructReferenceExpression.prototype.unParse = function(context, formula)
                        {
                            var self = this;
                            if (self._referencePortions === 16 && self._referenceColumnSpecifier === 1)
                            {
                                formula.content += self._baseTable.tableName();
                                return
                            }
                            var selfClass = StructReferenceExpression;
                            var inTable = context.source === self._baseTable.source() && context.row >= self._baseTable.startRow() && context.column >= self._baseTable.startColumn() && context.row <= self._baseTable.endRow() && context.column <= self._baseTable.endColumn();
                            if (!inTable || context.toStandard)
                            {
                                formula.content += self._baseTable.tableName()
                            }
                            formula.content += '[';
                            if (self._referencePortions !== 16)
                            {
                                var portionsString = selfClass._getPortionsString(self._referencePortions, self._referenceColumnSpecifier !== 1, context.toStandard);
                                formula.content += portionsString
                            }
                            if (self._referenceColumnSpecifier !== 1)
                            {
                                if (self._referencePortions === 1 && !context.toStandard || self._referencePortions === 16)
                                {}
                                else
                                {
                                    formula.content += ", "
                                }
                                var startColumnName = self._baseTable.getColumnName(self._columnReferenceStartInTable);
                                startColumnName = selfClass._getValidaColumnString(startColumnName);
                                if (self._referenceColumnSpecifier === 4)
                                {
                                    var endColumnName = self._baseTable.getColumnName(self._columnReferenceEndInTable);
                                    endColumnName = selfClass._getValidaColumnString(endColumnName);
                                    formula.content += '[' + startColumnName + "]:[" + endColumnName + ']'
                                }
                                else if (self._referencePortions === 1 && !context.toStandard && !selfClass._containsInvalidateColumnString(startColumnName) || self._referencePortions === 16)
                                {
                                    formula.content += startColumnName
                                }
                                else
                                {
                                    formula.content += '[' + startColumnName + ']'
                                }
                            }
                            formula.content += ']'
                        };
                        StructReferenceExpression._getPortionsString = function(portion, hasColumnSpecifier, toStandard)
                        {
                            switch (portion)
                            {
                                case 1:
                                    return toStandard ? "[#This Row]" : "@";
                                case 2:
                                    return hasColumnSpecifier ? "[#Headers]" : "#Headers";
                                case 3:
                                    return hasColumnSpecifier ? "[#Data]" : "#Data";
                                case 8:
                                    return hasColumnSpecifier ? "[#Totals]" : "#Totals";
                                case 6:
                                    return "[#Headers], [#Data]";
                                case 12:
                                    return "[#Data], [#Totals]";
                                case 14:
                                case 16:
                                    break;
                                default:
                                    break
                            }
                            return hasColumnSpecifier ? "[#All]" : "#All"
                        };
                        StructReferenceExpression.prototype.offsetWhenInsertRemoveColumn = function(index, count, isInsert)
                        {
                            var self = this;
                            var startColumn = self._catchedTableStartColumn;
                            if (index < startColumn || index === startColumn && isInsert || index > self._columnReferenceEndInTable + startColumn)
                            {
                                return self
                            }
                            count = isInsert ? count : -count;
                            var minStartColumn = index - startColumn;
                            var newExpr = new StructReferenceExpression(keyword_null, keyword_null);
                            newExpr._baseTable = self._baseTable;
                            newExpr._columnReferenceEndInTable = self._columnReferenceEndInTable + count;
                            newExpr._columnReferenceStartInTable = self._columnReferenceStartInTable;
                            if (index <= startColumn + self._columnReferenceStartInTable)
                            {
                                newExpr._columnReferenceStartInTable += count;
                                if (newExpr._columnReferenceStartInTable < minStartColumn)
                                {
                                    newExpr._columnReferenceStartInTable = minStartColumn
                                }
                            }
                            newExpr._referenceColumnSpecifier = self._referenceColumnSpecifier;
                            newExpr._referencePortions = self._referencePortions;
                            if (newExpr._columnReferenceEndInTable < newExpr._columnReferenceStartInTable)
                            {
                                return new ErrorExpression(CalcErrorsReference)
                            }
                            return newExpr
                        };
                        StructReferenceExpression.prototype.offsetWhenCopy = function(offsetRow, offsetColumn)
                        {
                            var self = this;
                            var newExpr = new StructReferenceExpression(keyword_null, keyword_null);
                            newExpr._baseTable = self._baseTable;
                            newExpr._columnReferenceEndInTable = self._columnReferenceEndInTable;
                            newExpr._columnReferenceStartInTable = self._columnReferenceStartInTable;
                            if (self._referenceColumnSpecifier === 2 && offsetColumn && offsetColumn > 0)
                            {
                                var columnCount = self._baseTable.endColumn() - self._baseTable.startColumn() + 1;
                                offsetColumn %= columnCount;
                                newExpr._columnReferenceStartInTable += offsetColumn;
                                if (newExpr._columnReferenceStartInTable < 0)
                                {
                                    newExpr._columnReferenceStartInTable += columnCount
                                }
                                newExpr._columnReferenceEndInTable = newExpr._columnReferenceStartInTable
                            }
                            newExpr._referenceColumnSpecifier = self._referenceColumnSpecifier;
                            newExpr._referencePortions = self._referencePortions;
                            return newExpr
                        };
                        StructReferenceExpression.prototype.offset = function(row, col, offsetAbsolute)
                        {
                            var self = this;
                            var expr = new StructReferenceExpression(keyword_null, keyword_null);
                            expr._baseTable = self._baseTable;
                            expr._referencePortions = self._referencePortions;
                            expr._columnReferenceStartInTable = self._columnReferenceStartInTable;
                            expr._columnReferenceEndInTable = self._columnReferenceEndInTable;
                            expr._referenceColumnSpecifier = self._referenceColumnSpecifier;
                            return expr
                        };
                        StructReferenceExpression._structReferenceKeywordsLlowercase = ["#all", "#data", "#headers", "#totals", "#this row"];
                        return StructReferenceExpression
                    })(ReferenceExpression);
                Expressions.StructReferenceExpression = StructReferenceExpression;
                var ExpandExpression = (function(_super)
                    {
                        __extends(ExpandExpression, _super);
                        function ExpandExpression(expr, needExpendIndexs)
                        {
                            _super.call(this);
                            this.expr = expr;
                            this.needExpendIndexs = needExpendIndexs;
                            this.t = 24
                        }
                        return ExpandExpression
                    })(Expression);
                Expressions.ExpandExpression = ExpandExpression;
                var _parser;
                function _mappingArray(context, expr, isArrayFormula, offsetRow, offsetCol)
                {
                    var baseRow = context.row,
                        baseColumn = context.column,
                        stack = [],
                        stackIndex = 0;
                    stack[stackIndex] = {
                        expr: expr, acceptsArray: false, acceptsRef: false, index: -1
                    };
                    var expendCount = 0;
                    var nameCount = 0;
                    var _currentIndexneedExpend = false;
                    var _rowOffset = offsetRow;
                    var _colOffset = offsetCol;
                    var _doNotExpend = false;
                    var changed = false;
                    var currentNode,
                        acceptsArray,
                        acceptsReference,
                        newExpr,
                        argExpr;
                    while (stackIndex >= 0)
                    {
                        currentNode = stack[stackIndex--];
                        acceptsArray = currentNode.acceptsArray;
                        acceptsReference = currentNode.acceptsRef;
                        expr = currentNode.expr;
                        newExpr = keyword_null;
                        if (!expr)
                        {}
                        else if (expr.t === 7)
                        {
                            var funcExpr = expr;
                            var func;
                            var argCount = funcExpr.argCount();
                            if (typeof(funcExpr.fn) === const_string)
                            {
                                if (!context)
                                {
                                    newExpr = new ErrorExpression(CalcErrorsName)
                                }
                                else
                                {
                                    func = context.getFunction(funcExpr.fn);
                                    if (!func)
                                    {
                                        newExpr = new ErrorExpression(CalcErrorsName);
                                        continue
                                    }
                                    else if (argCount < func.minArgs || argCount > func.maxArgs)
                                    {
                                        newExpr = new ErrorExpression(CalcErrorsValue);
                                        continue
                                    }
                                    else
                                    {
                                        funcExpr.fn = func
                                    }
                                }
                            }
                            func = funcExpr.fn;
                            var argIndex = currentNode.index;
                            var neeedExpendindexs = currentNode.neeedExpendindexs;
                            if (argIndex < 0)
                            {
                                currentNode.noExpendCatchValue = _doNotExpend;
                                currentNode.arrayFormulaCatchValue = isArrayFormula;
                                if (func.arrayArgumentEvaluateMode === 2)
                                {
                                    _doNotExpend = true
                                }
                                if (func.arrayArgumentEvaluateMode === 1)
                                {
                                    isArrayFormula = true
                                }
                                currentNode.args = []
                            }
                            else
                            {
                                if (func.acceptsArray(argIndex))
                                {
                                    expendCount--
                                }
                                else if (_currentIndexneedExpend)
                                {
                                    if (!neeedExpendindexs)
                                    {
                                        neeedExpendindexs = [];
                                        currentNode.neeedExpendindexs = neeedExpendindexs
                                    }
                                    if (funcExpr.getArg(argIndex) != argExpr)
                                    {}
                                    neeedExpendindexs.push(argIndex)
                                }
                                currentNode.args.push(argExpr)
                            }
                            if (argIndex == argCount - 1)
                            {
                                _doNotExpend = currentNode.noExpendCatchValue;
                                isArrayFormula = currentNode.arrayFormulaCatchValue;
                                var args = currentNode.args;
                                var argsChanged = false;
                                if (args && args.length > 0)
                                {
                                    for (var argI = 0; argI < args.length; argI++)
                                    {
                                        if (args[argI] !== funcExpr.getArg(argI))
                                        {
                                            argsChanged = true;
                                            break
                                        }
                                    }
                                }
                                if (argsChanged)
                                {
                                    newExpr = new FunctionExpression(funcExpr.fn, args)
                                }
                                else
                                {
                                    newExpr = expr
                                }
                                if (neeedExpendindexs && neeedExpendindexs.length > 0)
                                {
                                    newExpr = new ExpandExpression(newExpr, neeedExpendindexs);
                                    _currentIndexneedExpend = true
                                }
                            }
                            else
                            {
                                _currentIndexneedExpend = false;
                                argIndex++;
                                currentNode.index = argIndex;
                                if (func.acceptsArray(argIndex))
                                {
                                    expendCount++
                                }
                                stack[++stackIndex] = currentNode;
                                stack[++stackIndex] = {
                                    expr: funcExpr.getArg(argIndex), acceptsArray: func.acceptsArray(argIndex), acceptsRef: func.acceptsReference(argIndex), index: -1
                                }
                            }
                        }
                        else if (expr.t === 0 || expr.t === 1)
                        {
                            var cellExpr = expr;
                            if (nameCount && (cellExpr.rowRelative || cellExpr.columnRelative))
                            {
                                var source = expr.source || context.source;
                                var maxRowCount = source.getRowCount(),
                                    maxColCount = source.getColumnCount();
                                var row = cellExpr.rowRelative ? (cellExpr.row + context.activeRow) % Parser.maxRowCount % maxRowCount : cellExpr.row;
                                var col = cellExpr.columnRelative ? (cellExpr.column + context.activeColumn) % Parser.maxColumnCount % maxColCount : cellExpr.column;
                                row = row < 0 ? row + maxRowCount : row;
                                col = col < 0 ? col + maxColCount : col;
                                if (expr.t === 1)
                                {
                                    expr = new ExternalCellExpression(source, row, col, false, false)
                                }
                                else
                                {
                                    expr = new CellExpression(row, col, false, false)
                                }
                            }
                        }
                        else if (expr.t === 2 || expr.t === 3 || expr.t === 16)
                        {
                            var rangeExpr = expr;
                            if (nameCount)
                            {
                                if (rangeExpr.startRowRelative || rangeExpr.startColumnRelative || rangeExpr.endRowRelative || rangeExpr.endColumnRelative)
                                {
                                    var source = expr.source || expr.startSource || context.source;
                                    var maxRowCount = source.getRowCount(),
                                        maxColCount = source.getColumnCount();
                                    var startRow = rangeExpr.startRowRelative ? (rangeExpr.startRow + context.activeRow) % maxRowCount : rangeExpr.startRow;
                                    var startCol = rangeExpr.startColumnRelative ? (rangeExpr.startColumn + context.activeColumn) % maxColCount : rangeExpr.startColumn;
                                    var endRow = rangeExpr.endRowRelative ? (rangeExpr.endRow + context.activeRow) % maxRowCount : rangeExpr.endRow;
                                    var endCol = rangeExpr.endColumnRelative ? (rangeExpr.endColumn + context.activeColumn) % maxColCount : rangeExpr.endColumn;
                                    startRow = startRow < 0 ? startRow + maxRowCount : startRow;
                                    startCol = startCol < 0 ? startCol + maxColCount : startCol;
                                    endRow = endRow < 0 ? endRow + maxRowCount : endRow;
                                    endCol = endCol < 0 ? endCol + maxColCount : endCol;
                                    if (startRow > endRow)
                                    {
                                        var tmp = startRow;
                                        startRow = endRow;
                                        endRow = tmp
                                    }
                                    if (startCol > endCol)
                                    {
                                        var tmp = startCol;
                                        startCol = endCol;
                                        endCol = tmp
                                    }
                                    if (expr.t === 2)
                                    {
                                        expr = new RangeExpression(startRow, startCol, endRow, endCol, false, false, false, false)
                                    }
                                    else if (expr.t === 3)
                                    {
                                        expr = new ExternalRangeExpression(source, startRow, startCol, endRow, endCol, false, false, false, false)
                                    }
                                    else
                                    {
                                        expr = new SheetRangeExpression(source, expr.endSource, startRow, startCol, endRow, endCol, false, false, false, false)
                                    }
                                }
                            }
                            if (acceptsReference && (acceptsArray || !isArrayFormula))
                            {}
                            else
                            {
                                if (expendCount > 0 && !isArrayFormula || expendCount === 0 || _doNotExpend)
                                {
                                    var range = rangeExpr.getRange(baseRow, baseColumn);
                                    if (isArrayFormula)
                                    {
                                        if (!rangeExpr.isFullColumn && range.rowCount != 1 && _rowOffset >= range.rowCount || !rangeExpr.isFullRow && range.columnCount != 1 && _colOffset >= range.columnCount)
                                        {
                                            newExpr = new ErrorExpression(CalcErrorsNotAvailable)
                                        }
                                        else
                                        {
                                            var row = (rangeExpr.isFullColumn ? 0 : range.row) + (range.rowCount == 1 ? 0 : _rowOffset);
                                            var col = (rangeExpr.isFullRow ? 0 : range.column) + (range.columnCount == 1 ? 0 : _colOffset);
                                            if (expr.t === 16)
                                            {
                                                newExpr = new SheetRangeExpression(expr.startSource, expr.endSource, row, col, row, col, false, false, false, false)
                                            }
                                            else if (expr.t === 3)
                                            {
                                                newExpr = new ExternalCellExpression(expr.source, row, col, false, false)
                                            }
                                            else
                                            {
                                                newExpr = new CellExpression(row, col, false, false)
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (range.rowCount > 1 && range.columnCount > 1 || range.rowCount > 1 && !rangeExpr.isFullColumn && (baseRow < range.row || baseRow >= range.row + range.rowCount) || range.columnCount > 1 && !rangeExpr.isFullRow && (baseColumn < range.column || baseColumn >= range.column + range.columnCount))
                                        {
                                            newExpr = new ErrorExpression(CalcErrorsValue)
                                        }
                                        else
                                        {
                                            var row = (rangeExpr.isFullColumn || range.rowCount > 1) ? baseRow : range.row;
                                            var col = (rangeExpr.isFullRow || range.columnCount > 1) ? baseColumn : range.column;
                                            if (expr.t === 16)
                                            {
                                                newExpr = new SheetRangeExpression(expr.startSource, expr.endSource, row, col, row, col, false, false, false, false)
                                            }
                                            else if (expr.t === 3)
                                            {
                                                newExpr = new ExternalCellExpression(expr.source, row, col, false, false)
                                            }
                                            else
                                            {
                                                newExpr = new CellExpression(row, col, false, false)
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    _currentIndexneedExpend = true
                                }
                            }
                        }
                        else if (expr.t === 11)
                        {
                            var uOperExpr = expr;
                            if (currentNode.index === -1)
                            {
                                currentNode.index = 0;
                                stack[++stackIndex] = currentNode;
                                stack[++stackIndex] = {
                                    expr: uOperExpr.operand, acceptsArray: false, acceptsRef: false, index: -1
                                }
                            }
                            else
                            {
                                if (argExpr != uOperExpr.operand)
                                {
                                    newExpr = new UnaryOperatorExpression(uOperExpr.operator, argExpr)
                                }
                                else
                                {
                                    newExpr = expr
                                }
                                if (_currentIndexneedExpend)
                                {
                                    var neeedExpendindexs = [];
                                    neeedExpendindexs.push(0);
                                    newExpr = new ExpandExpression(newExpr, neeedExpendindexs)
                                }
                            }
                        }
                        else if (expr.t === 10)
                        {
                            var bOperExpr = expr;
                            var acceptsRef = bOperExpr.operator.acceptsReference;
                            if (currentNode.index === -1)
                            {
                                currentNode.index = 0;
                                stack[++stackIndex] = currentNode;
                                stack[++stackIndex] = {
                                    expr: bOperExpr.left, acceptsArray: false, acceptsRef: acceptsRef, index: -1
                                }
                            }
                            else if (currentNode.index == 0)
                            {
                                if (argExpr != bOperExpr.left)
                                {
                                    newExpr = new BinaryOperatorExpression(bOperExpr.operator, argExpr, bOperExpr.right);
                                    currentNode.expr = newExpr
                                }
                                if (_currentIndexneedExpend)
                                {
                                    var neeedExpendindexs = [];
                                    neeedExpendindexs.push(0);
                                    currentNode.neeedExpendindexs = neeedExpendindexs;
                                    _currentIndexneedExpend = false
                                }
                                currentNode.index = 1;
                                stack[++stackIndex] = currentNode;
                                stack[++stackIndex] = {
                                    expr: bOperExpr.right, acceptsArray: false, acceptsRef: acceptsRef, index: -1
                                }
                            }
                            else
                            {
                                if (argExpr != bOperExpr.right)
                                {
                                    newExpr = new BinaryOperatorExpression(bOperExpr.operator, bOperExpr.left, argExpr)
                                }
                                else
                                {
                                    newExpr = bOperExpr
                                }
                                var neeedExpendindexs = currentNode.neeedExpendindexs;
                                if (_currentIndexneedExpend)
                                {
                                    if (!neeedExpendindexs)
                                    {
                                        neeedExpendindexs = []
                                    }
                                    neeedExpendindexs.push(1)
                                }
                                if (neeedExpendindexs)
                                {
                                    newExpr = new ExpandExpression(newExpr, neeedExpendindexs);
                                    _currentIndexneedExpend = true
                                }
                            }
                        }
                        else if (expr.t === 14)
                        {
                            var parenExpr = expr;
                            if (currentNode.index === -1)
                            {
                                currentNode.index = 0;
                                stack[++stackIndex] = currentNode;
                                stack[++stackIndex] = {
                                    expr: parenExpr.argument, acceptsArray: acceptsArray, acceptsRef: acceptsRef, index: -1
                                }
                            }
                            else
                            {
                                if (parenExpr.argument !== argExpr)
                                {
                                    newExpr = new ParenthesesExpression(argExpr)
                                }
                            }
                        }
                        else if ((expr.t === 8) || (expr.t === 9))
                        {
                            var nameExpr = expr;
                            if (currentNode.index == 1)
                            {
                                nameCount--;
                                newExpr = argExpr
                            }
                            else
                            {
                                nameCount++;
                                stack[++stackIndex] = {
                                    expr: expr, acceptsArray: true, acceptsRef: true, index: 1
                                };
                                var rExpr;
                                if (expr.t === 9)
                                {
                                    rExpr = expr.source.getCustomName(nameExpr.name)
                                }
                                else
                                {
                                    rExpr = context.getName(nameExpr.name)
                                }
                                if (!rExpr)
                                {
                                    rExpr = new Expressions.ErrorExpression(CalcErrorsName)
                                }
                                stack[++stackIndex] = {
                                    expr: rExpr, acceptsArray: true, acceptsRef: true, index: -1
                                }
                            }
                        }
                        else if (expr.t === 15)
                        {
                            var arrayExpression = expr;
                            if (!acceptsArray && (expendCount > 0 || isArrayFormula))
                            {
                                _currentIndexneedExpend = true
                            }
                            else if (!acceptsArray && expendCount == 0)
                            {
                                if ((_rowOffset >= arrayExpression.value.RowCount && arrayExpression.value.RowCount > 1) || (_colOffset >= arrayExpression.value.ColumnCount && arrayExpression.value.ColumnCount > 1))
                                {
                                    newExpr = new ErrorExpression(CalcErrorsNotAvailable)
                                }
                                else
                                {
                                    try
                                    {
                                        if (arrayExpression.value.RowCount == 1)
                                        {
                                            _rowOffset = 0
                                        }
                                        if (arrayExpression.value.ColumnCount == 1)
                                        {
                                            _colOffset = 0
                                        }
                                        var cValue = arrayExpression.value.getValue(_rowOffset, _colOffset);
                                        if (typeof cValue === "string")
                                        {
                                            newExpr = new StringExpression(cValue)
                                        }
                                        else if (typeof cValue === "number")
                                        {
                                            newExpr = new DoubleExpression(cValue)
                                        }
                                        if (!_parser)
                                        {
                                            _parser = new Calc.Parser
                                        }
                                        newExpr = _parser.parse(arrayExpression.value.getValue(_rowOffset, _colOffset).toString(), keyword_null)
                                    }
                                    catch(ex)
                                    {
                                        newExpr = new ErrorExpression(CalcErrorsNotAvailable)
                                    }
                                }
                            }
                        }
                        if (newExpr === keyword_null)
                        {
                            newExpr = expr
                        }
                        else if (newExpr != expr)
                        {
                            changed = true
                        }
                        argExpr = newExpr
                    }
                    return newExpr
                }
                Expressions._mappingArray = _mappingArray
            })(Calc.Expressions || (Calc.Expressions = {}));
            var Expressions = Calc.Expressions;
            (function(StructReferencePortions)
            {
                StructReferencePortions[StructReferencePortions["ThisRow"] = 1] = "ThisRow";
                StructReferencePortions[StructReferencePortions["Headers"] = 2] = "Headers";
                StructReferencePortions[StructReferencePortions["Data"] = 3] = "Data";
                StructReferencePortions[StructReferencePortions["Totals"] = 8] = "Totals";
                StructReferencePortions[StructReferencePortions["HeadersAndData"] = 6] = "HeadersAndData";
                StructReferencePortions[StructReferencePortions["DataAndTotals"] = 12] = "DataAndTotals";
                StructReferencePortions[StructReferencePortions["All"] = 14] = "All";
                StructReferencePortions[StructReferencePortions["NotSpecific"] = 16] = "NotSpecific"
            })(Calc.StructReferencePortions || (Calc.StructReferencePortions = {}));
            var StructReferencePortions = Calc.StructReferencePortions;
            ;
            (function(StructReferenceColumnSpecifier)
            {
                StructReferenceColumnSpecifier[StructReferenceColumnSpecifier["All"] = 1] = "All";
                StructReferenceColumnSpecifier[StructReferenceColumnSpecifier["NotSpecific"] = 1] = "NotSpecific";
                StructReferenceColumnSpecifier[StructReferenceColumnSpecifier["SingleColumn"] = 2] = "SingleColumn";
                StructReferenceColumnSpecifier[StructReferenceColumnSpecifier["ColumnRange"] = 4] = "ColumnRange"
            })(Calc.StructReferenceColumnSpecifier || (Calc.StructReferenceColumnSpecifier = {}));
            var StructReferenceColumnSpecifier = Calc.StructReferenceColumnSpecifier;
            ;
            var NumberState = {
                    None: 0, Sign: 1, Int: 2, Dot: 3, Decimal: 4, Exponent: 5, SignExponent: 6, ScientificNotation: 7, Number: 8
                };
            var LatinUnicodeCategory = {
                    UppercaseLetter: 0x00, LowercaseLetter: 0x01, DecimalDigitNumber: 0x08, OtherNumber: 0x0a, SpaceSeparator: 0x0b, Control: 0x0e, ConnectorPunctuation: 0x12, DashPunctuation: 0x13, OpenPunctuation: 0x14, ClosePunctuation: 0x15, InitialQuotePunctuation: 0x16, FinalQuotePunctuation: 0x17, OtherPunctuation: 0x18, MathSymbol: 0x19, currencySymbol: 0x1a, ModifierSymbol: 0x1b, OtherSymbol: 0x1c
                };
            var categoryForLatin1 = [0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xb, 0x18, 0x18, 0x18, 0x1a, 0x18, 0x18, 0x18, 0x14, 0x15, 0x18, 0x19, 0x18, 0x13, 0x18, 0x18, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x18, 0x18, 0x19, 0x19, 0x19, 0x18, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x18, 0x15, 0x1b, 0x12, 0x1b, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x14, 0x19, 0x15, 0x19, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xb, 0x18, 0x1a, 0x1a, 0x1a, 0x1a, 0x1c, 0x1c, 0x1b, 0x1c, 0x1, 0x16, 0x19, 0x13, 0x1c, 0x1b, 0x1c, 0x19, 0xa, 0xa, 0x1b, 0x1, 0x1c, 0x18, 0x1b, 0xa, 0x1, 0x17, 0xa, 0xa, 0xa, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x19, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1];
            function isLatin1(cc)
            {
                return cc <= 0x00ff
            }
            function isAscii(cc)
            {
                return cc <= 0x007f
            }
            function isDigit(c)
            {
                var cc = c.charCodeAt(0);
                return cc >= 48 && cc <= 57
            }
            function isLetter(c)
            {
                var cc = c.charCodeAt(0);
                if (!isLatin1(cc))
                {
                    return true
                }
                if (!isAscii(cc))
                {
                    return categoryForLatin1[cc] === LatinUnicodeCategory.UppercaseLetter || categoryForLatin1[cc] === LatinUnicodeCategory.LowercaseLetter
                }
                cc |= 0x20;
                return (cc >= 96 && cc <= 122)
            }
            function isLetterOrDigit(c)
            {
                var cc = c.charCodeAt(0);
                if (!isLatin1(cc))
                {
                    return true
                }
                if (!isAscii(cc))
                {
                    return categoryForLatin1[cc] === LatinUnicodeCategory.UppercaseLetter || categoryForLatin1[cc] === LatinUnicodeCategory.LowercaseLetter
                }
                if (cc <= 57)
                {
                    return cc >= 48
                }
                cc |= 0x20;
                return (cc >= 96 && cc <= 122)
            }
            function isSymbol(c)
            {
                var cc = c.charCodeAt(0);
                if (!isLatin1(cc))
                {
                    return false
                }
                return categoryForLatin1[cc] === LatinUnicodeCategory.MathSymbol || categoryForLatin1[cc] === LatinUnicodeCategory.currencySymbol || categoryForLatin1[cc] === LatinUnicodeCategory.ModifierSymbol || categoryForLatin1[cc] === LatinUnicodeCategory.OtherSymbol
            }
            function isNumber(c)
            {
                var cc = c.charCodeAt(0);
                if (!isAscii(cc))
                {
                    return categoryForLatin1[cc] === LatinUnicodeCategory.DecimalDigitNumber || categoryForLatin1[cc] === LatinUnicodeCategory.OtherNumber
                }
                return cc >= 48 && cc <= 57
            }
            function isNumber2(str, startIndex, numberDecimalSeparator)
            {
                var len = str.length;
                var state = NumberState.None;
                for (var i = startIndex; i < len; i++)
                {
                    var currentChar = str.charAt(i);
                    if (isDigit(currentChar))
                    {
                        if (state === NumberState.None)
                        {
                            state = NumberState.Int
                        }
                        else if (state === NumberState.Dot)
                        {
                            state = NumberState.Decimal
                        }
                        else if (state === NumberState.Sign)
                        {
                            state = NumberState.Int
                        }
                        else if (state === NumberState.Exponent || state === NumberState.SignExponent)
                        {
                            state = NumberState.ScientificNotation
                        }
                    }
                    else if (currentChar === numberDecimalSeparator)
                    {
                        if (state === NumberState.Int)
                        {
                            state = NumberState.Decimal
                        }
                        else if (state === NumberState.None || state === NumberState.Sign)
                        {
                            state = NumberState.Dot
                        }
                        else
                        {
                            return {result: false}
                        }
                    }
                    else if (currentChar === '+' || currentChar === '-')
                    {
                        if (state === NumberState.None)
                        {
                            state = NumberState.Sign
                        }
                        else if (state === NumberState.Exponent)
                        {
                            state = NumberState.SignExponent
                        }
                        else
                        {
                            return {
                                    result: true, endIndex: i - 1
                                }
                        }
                    }
                    else if (currentChar === 'E' || currentChar === 'e')
                    {
                        if (state === NumberState.Int || state === NumberState.Decimal)
                        {
                            state = NumberState.Exponent
                        }
                        else
                        {
                            return {result: false}
                        }
                    }
                    else if (state === NumberState.Int || state === NumberState.Decimal || state === NumberState.ScientificNotation)
                    {
                        return {
                                result: true, endIndex: i - 1
                            }
                    }
                }
                if (state === NumberState.Int || state === NumberState.Decimal || state === NumberState.ScientificNotation)
                {
                    return {
                            result: true, endIndex: len - 1
                        }
                }
                return {result: false}
            }
            (function(ExcelFormulaTokenType)
            {
                ExcelFormulaTokenType[ExcelFormulaTokenType["Operand"] = 0] = "Operand";
                ExcelFormulaTokenType[ExcelFormulaTokenType["Function"] = 1] = "Function";
                ExcelFormulaTokenType[ExcelFormulaTokenType["Subexpression"] = 2] = "Subexpression";
                ExcelFormulaTokenType[ExcelFormulaTokenType["Argument"] = 3] = "Argument";
                ExcelFormulaTokenType[ExcelFormulaTokenType["OperatorPrefix"] = 4] = "OperatorPrefix";
                ExcelFormulaTokenType[ExcelFormulaTokenType["OperatorInfix"] = 5] = "OperatorInfix";
                ExcelFormulaTokenType[ExcelFormulaTokenType["OperatorPostfix"] = 6] = "OperatorPostfix";
                ExcelFormulaTokenType[ExcelFormulaTokenType["Whitespace"] = 7] = "Whitespace";
                ExcelFormulaTokenType[ExcelFormulaTokenType["Unknown"] = 8] = "Unknown"
            })(Calc.ExcelFormulaTokenType || (Calc.ExcelFormulaTokenType = {}));
            var ExcelFormulaTokenType = Calc.ExcelFormulaTokenType;
            ;
            (function(ExcelFormulaTokenSubtype)
            {
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Nothing"] = 0] = "Nothing";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Start"] = 1] = "Start";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Stop"] = 2] = "Stop";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Text"] = 3] = "Text";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Number"] = 4] = "Number";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Logical"] = 5] = "Logical";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Error"] = 6] = "Error";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["RangeOrName"] = 7] = "RangeOrName";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Concatenation"] = 8] = "Concatenation";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Intersection"] = 9] = "Intersection";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["Union"] = 10] = "Union";
                ExcelFormulaTokenSubtype[ExcelFormulaTokenSubtype["RangeOp"] = 11] = "RangeOp"
            })(Calc.ExcelFormulaTokenSubtype || (Calc.ExcelFormulaTokenSubtype = {}));
            var ExcelFormulaTokenSubtype = Calc.ExcelFormulaTokenSubtype;
            ;
            var FormulaToken = (function()
                {
                    function FormulaToken(value, type, index, subType)
                    {
                        if (subType === keyword_undefined || subType === keyword_null)
                        {
                            subType = 0
                        }
                        var self = this;
                        self.value = value;
                        self.type = type;
                        self.index = index;
                        self.subType = subType;
                        self.children = []
                    }
                    return FormulaToken
                })();
            function readString(formula, startIndex, startSign, endSign, throwError)
            {
                var len = formula.length;
                var startSignCount = (startSign === endSign) ? 0 : 1;
                var text = "";
                for (var index = startIndex + 1; index < len; index++)
                {
                    var currentChar = formula.charAt(index);
                    if (currentChar === startSign)
                    {
                        startSignCount++
                    }
                    if (currentChar === endSign)
                    {
                        startSignCount--;
                        if (startSign === endSign && index + 2 < len && formula.charAt(index + 1) === startSign)
                        {
                            text += startSign;
                            index++
                        }
                        else if (startSignCount !== 0)
                        {
                            text += currentChar
                        }
                        else
                        {
                            return {
                                    result: text, endIndex: index
                                }
                        }
                    }
                    else
                    {
                        text += currentChar
                    }
                }
                if (throwError)
                {
                    throw Sheets.SR.Exp_NoSyntax + endSign + Sheets.SR.Exp_MatchSyntax + startSign + Sheets.SR.SingleQuotesFullStop;
                }
            }
            function readString2(formula, startIndex, startSign, endSign, escapeSign, throwError)
            {
                var len = formula.length;
                var startSignCount = 0;
                var text = "";
                for (var index = startIndex; index < len; index++)
                {
                    var currentChar = formula.charAt(index);
                    if (currentChar === escapeSign)
                    {
                        text += currentChar;
                        index++;
                        currentChar = formula.charAt(index)
                    }
                    if (currentChar === startSign)
                    {
                        text += currentChar;
                        startSignCount++
                    }
                    else if (currentChar === endSign)
                    {
                        startSignCount--;
                        if (startSignCount != 0)
                        {
                            text += currentChar
                        }
                        else
                        {
                            return {
                                    result: text, endIndex: index
                                }
                        }
                    }
                    else
                    {
                        text += currentChar
                    }
                }
                if (throwError)
                {
                    throw Sheets.SR.Exp_NoSyntax + endSign + Sheets.SR.Exp_MatchSyntax + startSign + Sheets.SR.SingleQuotesFullStop;
                }
            }
            function readError(formula, startIndex, throwError)
            {
                var len = formula.length;
                var surplusLen = len - startIndex;
                for (var i = 0; i < ErrorList.length; i++)
                {
                    var err = ErrorList[i],
                        errLength = err.length;
                    if (startIndex + errLength > len)
                    {
                        continue
                    }
                    var errStr = formula.slice(startIndex, startIndex + errLength);
                    if (errLength <= surplusLen && (err === errStr || err === errStr.toUpperCase()))
                    {
                        return {
                                result: err, endIndex: startIndex + errLength - 1
                            }
                    }
                }
                if (throwError)
                {
                    throw Sheets.SR.SingleQuote + formula.slice(startIndex) + Sheets.SR.Exp_IsValid;
                }
            }
            function getOpeatorPriority(op)
            {
                if (op === "^" || op === ":")
                {
                    return 1
                }
                else if (op === "*" || op === "/" || op === " ")
                {
                    return 2
                }
                else if (op === "+" || op === "-" || op === ",")
                {
                    return 3
                }
                else if (op === "&")
                {
                    return 4
                }
                else
                {
                    return 5
                }
            }
            function getBinaryOperator(token)
            {
                if (token.subType === 11)
                {
                    return Operators.range
                }
                else if (token.subType === 10)
                {
                    return Operators.union
                }
                else if (token.subType === 9)
                {
                    return Operators.intersection
                }
                var value = token.value;
                if (value === "^")
                {
                    return Operators.exponent
                }
                else if (value === "*")
                {
                    return Operators.multiply
                }
                else if (value === "/")
                {
                    return Operators.divide
                }
                else if (value === "+")
                {
                    return Operators.add
                }
                else if (value === "-")
                {
                    return Operators.subtract
                }
                else if (value === "&")
                {
                    return Operators.concatenate
                }
                else if (value === "<")
                {
                    return Operators.lessThan
                }
                else if (value === "=")
                {
                    return Operators.equal
                }
                else if (value === ">")
                {
                    return Operators.greaterThan
                }
                else if (value === ">=")
                {
                    return Operators.greaterThanOrEqual
                }
                else if (value === "<=")
                {
                    return Operators.lessThanOrEqual
                }
                else if (value === "<>")
                {
                    return Operators.notEqual
                }
                else if (value === ":" || value === "!")
                {
                    return Operators.range
                }
                else if (value === " " || value === ",")
                {
                    return Operators.intersection
                }
                return Operators.add
            }
            function getProperty(obj, name, fallback)
            {
                return (obj && obj.hasOwnProperty(name)) ? obj[name] : fallback
            }
            function normalizeIndex(index, maxIndex)
            {
                var firstInvalidIndex = maxIndex + 1;
                if (index < 0)
                {
                    return index % firstInvalidIndex + firstInvalidIndex
                }
                if (index > maxIndex)
                {
                    return index % firstInvalidIndex
                }
                return index
            }
            var ParserContext = (function()
                {
                    function ParserContext(source, useR1C1, baseRow, baseColumn, option)
                    {
                        this.toStandard = false;
                        this.ignoreError = false;
                        this.source = keyword_null;
                        var self = this;
                        self.useR1C1 = useR1C1;
                        self.row = baseRow;
                        self.column = baseColumn;
                        self.option = option;
                        this.source = source
                    }
                    ParserContext.prototype.getExternalSource = function(bookName, sheetName)
                    {
                        var service = this.source.service;
                        var models = service.getAllSouceModels();
                        for (var i = 0; i < models.length; i++)
                        {
                            if (Calc.compareStringIgnoreCase(models[i].source.getName(), sheetName))
                            {
                                return models[i].source
                            }
                        }
                        return keyword_null
                    };
                    ParserContext.prototype.getExternalSourceToken = function(source)
                    {
                        return source.getName()
                    };
                    ParserContext.prototype.getTableByName = function(name)
                    {
                        return keyword_null
                    };
                    ParserContext.prototype.getTableByIndex = function(rowIndex, columnIndex)
                    {
                        return keyword_null
                    };
                    ParserContext.prototype.setSource = function(source)
                    {
                        this.source = source
                    };
                    return ParserContext
                })();
            Calc.ParserContext = ParserContext;
            var Parser = (function()
                {
                    function Parser(option)
                    {
                        if ((typeof(option) === const_undefined || option === keyword_null))
                        {
                            return
                        }
                        Parser.setParserOption(option)
                    }
                    Parser.setParserOption = function(option)
                    {
                        Parser.listSeparator = getProperty(option, 'listSeparator', ',');
                        Parser.numberDecimalSeparator = getProperty(option, 'numberDecimalSeparator', '.');
                        Parser.arrayGroupSeparator = getProperty(option, 'arrayGroupSeparator', ';');
                        Parser._arrayArgumentSepatator = (Parser.listSeparator === Parser.arrayGroupSeparator) ? '\\' : Parser.listSeparator;
                        Parser._operatorInfix = '\\+-*/^&=><: ' + Parser.listSeparator
                    };
                    Parser.getParserOption = function()
                    {
                        var option = {
                                numberDecimalSeparator: Parser.numberDecimalSeparator, listSeparator: Parser.listSeparator, arrayGroupSeparator: Parser.arrayGroupSeparator
                            };
                        return option
                    };
                    Parser.prototype.parse = function(formula, context)
                    {
                        var self = this;
                        if (!context)
                        {
                            context = new ParserContext(keyword_null, false, 0, 0)
                        }
                        if (context.option)
                        {
                            Parser.setParserOption(context.option)
                        }
                        var tokens = self._parseToToken(formula);
                        return self._buildExpressionTree(context, tokens)
                    };
                    Parser.prototype.unparse = function(expr, context)
                    {
                        Parser.unparseWithoutCulture = false;
                        if (!expr)
                        {
                            return ''
                        }
                        if (!context)
                        {
                            context = new ParserContext(keyword_null, false, 0, 0)
                        }
                        if (context.option)
                        {
                            Parser.setParserOption(context.option)
                        }
                        var formula = {content: ""};
                        this._unparseExpression(expr, context, formula);
                        return formula.content
                    };
                    Parser.prototype.unparseWithoutCulture = function(expr, context)
                    {
                        Parser.unparseWithoutCulture = true;
                        if (!expr)
                        {
                            return ''
                        }
                        if (!context)
                        {
                            context = new ParserContext(keyword_null, false, 0, 0)
                        }
                        if (context.option)
                        {
                            Parser.setParserOption(context.option)
                        }
                        var formula = {content: ""};
                        this._unparseExpression(expr, context, formula);
                        Parser.unparseWithoutCulture = false;
                        return formula.content
                    };
                    Parser.prototype.a1ToR1C1 = function(context, formula)
                    {
                        var index = 0,
                            len = formula.length,
                            currentChar,
                            inReference,
                            inName,
                            charCode,
                            lowCaseCode,
                            categoryForLatinCache = categoryForLatin1,
                            LatinUnicodeCategoryType = LatinUnicodeCategory,
                            tokenStartIndex = -1,
                            tokenEndIndex = -1,
                            numberStartIndex = -1,
                            endWithNumber = false,
                            columnRef,
                            rowRef,
                            r1c1Formula = "",
                            rowRelative = true,
                            colRelative = true,
                            rowIndex,
                            colIndex,
                            colChars;
                        while (index < len && formula.charAt(index) === ' ')
                        {
                            index++
                        }
                        if (formula.charAt(index) === '=')
                        {
                            index++
                        }
                        for (var index = 0; index <= len; index++)
                        {
                            if (index !== len)
                            {
                                currentChar = formula[index];
                                charCode = currentChar.charCodeAt(0);
                                lowCaseCode = charCode | 0x20
                            }
                            else
                            {
                                currentChar = "\0";
                                charCode = lowCaseCode = 0
                            }
                            if (currentChar === '$')
                            {
                                if (inName)
                                {}
                                else if (endWithNumber)
                                {
                                    inName = true;
                                    inReference = endWithNumber = false
                                }
                                else if (inReference)
                                {
                                    endWithNumber = true;
                                    rowRelative = false
                                }
                            }
                            else if (charCode < 0x007f && lowCaseCode >= 96 && lowCaseCode <= 122)
                            {
                                if (inName)
                                {}
                                else if (endWithNumber)
                                {
                                    inName = true;
                                    inReference = endWithNumber = false
                                }
                                else if (!inReference)
                                {
                                    if (index > 0 && formula.charAt(index - 1) === '$')
                                    {
                                        tokenStartIndex = index - 1;
                                        colRelative = false
                                    }
                                    else
                                    {
                                        tokenStartIndex = index
                                    }
                                    inReference = true;
                                    colChars = [lowCaseCode]
                                }
                                else
                                {
                                    colChars.push(lowCaseCode)
                                }
                            }
                            else if (charCode < 0x007f && charCode >= 48 && charCode <= 57 || charCode >= 0x007f && (categoryForLatinCache[charCode] === LatinUnicodeCategoryType.DecimalDigitNumber || categoryForLatinCache[charCode] === LatinUnicodeCategoryType.OtherNumber))
                            {
                                if (inName)
                                {}
                                else
                                {
                                    endWithNumber = true;
                                    if (!inReference && tokenStartIndex < 0)
                                    {
                                        if (index > 0 && formula.charAt(index - 1) === '$')
                                        {
                                            tokenStartIndex = index - 1;
                                            rowRelative = false
                                        }
                                        else
                                        {
                                            tokenStartIndex = index
                                        }
                                    }
                                    if (numberStartIndex < 0)
                                    {
                                        numberStartIndex = index
                                    }
                                }
                            }
                            else if (currentChar === "'" || currentChar === '"' || currentChar === '[')
                            {
                                inName = inReference = endWithNumber = false;
                                tokenStartIndex = numberStartIndex = -1;
                                rowRelative = colRelative = true;
                                var rs;
                                if (currentChar === '[')
                                {
                                    rs = readString2(formula, index, '[', ']', "'", false)
                                }
                                else
                                {
                                    rs = readString(formula, index, currentChar, currentChar, false)
                                }
                                if (rs)
                                {
                                    index = rs.endIndex
                                }
                                else
                                {
                                    index = len - 1
                                }
                            }
                            else if (currentChar === '_' || currentChar === '\\' || currentChar === '?' || currentChar === '.')
                            {
                                inName = true;
                                inReference = endWithNumber = false
                            }
                            else if (inName || inReference || endWithNumber)
                            {
                                if ((inReference || endWithNumber) && currentChar !== '!')
                                {
                                    rowRef = "";
                                    if (inReference && endWithNumber)
                                    {
                                        rowRef = formula.substring(numberStartIndex, index)
                                    }
                                    else
                                    {
                                        var tmpIndex = tokenStartIndex - 1;
                                        while (tmpIndex >= 0 && formula.charAt(tmpIndex) === ' ')
                                        {
                                            tmpIndex--
                                        }
                                        if (tmpIndex <= 0 || formula.charAt(tmpIndex) !== ':')
                                        {
                                            tmpIndex = index;
                                            while (tmpIndex < len && formula.charAt(tmpIndex) === ' ')
                                            {
                                                tmpIndex++
                                            }
                                        }
                                        if (tmpIndex > 0 && tmpIndex < len && formula.charAt(tmpIndex) === ':')
                                        {
                                            if (endWithNumber)
                                            {
                                                rowRef = formula.substr(numberStartIndex, index - 1)
                                            }
                                        }
                                        else
                                        {
                                            inReference = endWithNumber = false
                                        }
                                    }
                                    if (endWithNumber)
                                    {
                                        rowIndex = parseInt(rowRef, 10);
                                        if (rowIndex > Parser.maxRowCount)
                                        {
                                            endWithNumber = inReference = false
                                        }
                                    }
                                    if (inReference)
                                    {
                                        colIndex = 0;
                                        var lastColChars = colChars.length - 1;
                                        for (var i = lastColChars; i >= 0; i--)
                                        {
                                            colIndex = colIndex + (colChars[i] - 96) * Math.pow(26, (lastColChars - i))
                                        }
                                        if (colIndex > Parser.maxColumnCount)
                                        {
                                            endWithNumber = inReference = false
                                        }
                                    }
                                    if (inReference || endWithNumber)
                                    {
                                        if (tokenStartIndex > tokenEndIndex + 1)
                                        {
                                            r1c1Formula += formula.substring(tokenEndIndex + 1, tokenStartIndex)
                                        }
                                        tokenEndIndex = index - 1
                                    }
                                    if (endWithNumber)
                                    {
                                        r1c1Formula += "R";
                                        if (rowRelative)
                                        {
                                            r1c1Formula += "[";
                                            rowIndex -= (context.row + 1)
                                        }
                                        r1c1Formula += rowIndex.toString();
                                        if (rowRelative)
                                        {
                                            r1c1Formula += "]"
                                        }
                                    }
                                    if (inReference)
                                    {
                                        r1c1Formula += "C";
                                        if (colRelative)
                                        {
                                            r1c1Formula += "[";
                                            colIndex -= (context.column + 1)
                                        }
                                        r1c1Formula += colIndex.toString();
                                        if (colRelative)
                                        {
                                            r1c1Formula += "]"
                                        }
                                    }
                                }
                                inName = inReference = endWithNumber = false;
                                tokenStartIndex = numberStartIndex = -1;
                                rowRelative = colRelative = true
                            }
                        }
                        if (len > tokenEndIndex + 1)
                        {
                            r1c1Formula += formula.substring(tokenEndIndex + 1, len)
                        }
                        return r1c1Formula
                    };
                    Parser.prototype._unparseExpression = function(expr, context, formula)
                    {
                        var self = this;
                        if (expr instanceof Expressions.ConstantExpression)
                        {
                            self._unparseConstantExpression(expr, context, formula)
                        }
                        else if (expr instanceof Expressions.OperatorExpression)
                        {
                            self._unParseOperatorExpressions(expr, context, formula)
                        }
                        else if (expr instanceof Expressions.ReferenceExpression)
                        {
                            self._unParseRefenceExpressions(expr, context, formula)
                        }
                        else if (expr.t === 18)
                        {
                            formula.content += '!';
                            formula.content += expr.name
                        }
                        else if (expr.t === 9)
                        {
                            var source = expr.source;
                            self._unparseSource(source, context, formula);
                            formula.content += '!';
                            var name = expr.name;
                            formula.content += name
                        }
                        else if (expr.t === 8)
                        {
                            var name = expr.name;
                            formula.content += name
                        }
                        else if (expr.t === 14)
                        {
                            formula.content += "(";
                            self._unparseExpression(expr.argument, context, formula);
                            formula.content += ")"
                        }
                        else if (expr.t === 7)
                        {
                            formula.content += expr.getFunctionName();
                            formula.content += "(";
                            for (var i = 0; i < expr.argCount(); i++)
                            {
                                if (i !== 0)
                                {
                                    if (Parser.unparseWithoutCulture)
                                    {
                                        formula.content += ','
                                    }
                                    else
                                    {
                                        formula.content += GcSpread.Sheets.CR.listSeparator
                                    }
                                }
                                self._unparseExpression(expr.getArg(i), context, formula)
                            }
                            formula.content += ")"
                        }
                        else
                        {
                            throw Sheets.SR.Exp_NotSupport;
                        }
                    };
                    Parser.prototype._unparseSource = function(source, context, formula)
                    {
                        if (context.getExternalSourceToken)
                        {
                            formula.content += this._getValidSource(context, context.getExternalSourceToken(source), context.useR1C1)
                        }
                    };
                    Parser.prototype._unparseSource2 = function(startSource, endSource, context, formula)
                    {
                        var self = this;
                        var start = {content: ''};
                        self._unparseSource(startSource, context, start);
                        var containsSpecial = self._removeApostrophe(start);
                        var workBookNameResult = self._removeWorkbook(start);
                        var containsWorkbook = workBookNameResult.success;
                        var workBookName = workBookNameResult.workBookName;
                        var end = {content: ''};
                        self._unparseSource(endSource, context, end);
                        containsSpecial |= self._removeApostrophe(end);
                        workBookName = self._removeWorkbook(end).workBookName;
                        if (containsSpecial)
                        {
                            formula.content += "'";
                            if (containsWorkbook)
                            {
                                formula.content += workBookName
                            }
                            formula.content += start.content;
                            formula.content += ':';
                            formula.content += end.content;
                            formula.content += "'"
                        }
                        else
                        {
                            if (containsWorkbook)
                            {
                                formula.content += workBookName
                            }
                            formula.content += start.content;
                            formula.content += ':';
                            formula.content += end.content
                        }
                    };
                    Parser.prototype._getValidSource = function(context, value, isR1C1)
                    {
                        if (value === keyword_undefined || value === keyword_null || value === '')
                        {
                            return ''
                        }
                        var sheetRef = this._readSheetReference(context, value, isR1C1, true),
                            valueLength = value.length;
                        if (sheetRef.success)
                        {
                            if (value.charAt(0) === "'" && value.charAt(valueLength - 1) === "'")
                            {
                                value = value.substr(1, valueLength - 2);
                                value = value.replace("'", "''");
                                value = "'" + value + "'"
                            }
                            return value
                        }
                        sheetRef = this._readSheetReference(context, "'" + value + "'", isR1C1, true);
                        if (sheetRef.success)
                        {
                            value = value.replace("'", "''");
                            value = "'" + value + "'";
                            return value
                        }
                        return ''
                    };
                    Parser.prototype._unParseRefenceExpressions = function(expr, context, formula)
                    {
                        var self = this;
                        var baseRow = context.row,
                            baseColumn = context.column;
                        if (expr.t === 22)
                        {
                            formula.content += '!';
                            var expr1 = expr;
                            self._unParseCell(context.useR1C1, baseRow, baseColumn, expr1.row, expr1.column, expr1.rowRelative, expr1.columnRelative, formula)
                        }
                        else if (expr.t === 0)
                        {
                            var expr2 = expr;
                            self._unParseCell(context.useR1C1, baseRow, baseColumn, expr2.row, expr2.column, expr2.rowRelative, expr2.columnRelative, formula)
                        }
                        else if (expr.t === 1)
                        {
                            var expr3 = expr;
                            self._unparseSource(expr3.source, context, formula);
                            formula.content += '!';
                            self._unParseCell(context.useR1C1, baseRow, baseColumn, expr3.row, expr3.column, expr3.rowRelative, expr3.columnRelative, formula)
                        }
                        else if (expr.t === 23)
                        {
                            formula.content += '!';
                            var expr4 = expr;
                            self._unParseRange(context.useR1C1, baseRow, baseColumn, expr4.startRow, expr4.startColumn, expr4.endRow, expr4.endColumn, expr4.startRowRelative, expr4.startColumnRelative, expr4.endRowRelative, expr4.endColumnRelative, formula, expr4._getRangeType())
                        }
                        else if (expr.t === 2)
                        {
                            var expr5 = expr;
                            self._unParseRange(context.useR1C1, baseRow, baseColumn, expr5.startRow, expr5.startColumn, expr5.endRow, expr5.endColumn, expr5.startRowRelative, expr5.startColumnRelative, expr5.endRowRelative, expr5.endColumnRelative, formula, expr5._getRangeType())
                        }
                        else if (expr.t === 3)
                        {
                            var expr6 = expr;
                            self._unparseSource(expr6.source, context, formula);
                            formula.content += '!';
                            self._unParseRange(context.useR1C1, baseRow, baseColumn, expr6.startRow, expr6.startColumn, expr6.endRow, expr6.endColumn, expr6.startRowRelative, expr6.startColumnRelative, expr6.endRowRelative, expr6.endColumnRelative, formula, expr6._getRangeType())
                        }
                        else if (expr.t === 16)
                        {
                            var expr7 = expr;
                            self._unparseSource2(expr7.startSource, expr7.endSource, context, formula);
                            formula.content += '!';
                            self._unParseRange(context.useR1C1, baseRow, baseColumn, expr7.startRow, expr7.startColumn, expr7.endRow, expr7.endColumn, expr7.startRowRelative, expr7.startColumnRelative, expr7.endRowRelative, expr7.endColumnRelative, formula, expr7._getRangeType())
                        }
                        else if (expr.t === 17)
                        {
                            expr.unParse(context, formula)
                        }
                        else
                        {
                            throw Sheets.SR.Exp_NotSupport;
                        }
                    };
                    Parser.prototype._removeApostrophe = function(formula)
                    {
                        var formulaContent = formula.content,
                            length = formulaContent.length;
                        if (formulaContent.charAt(length - 1) === "'")
                        {
                            formula.content = formulaContent.substr(1, length - 2);
                            return true
                        }
                        return false
                    };
                    Parser.prototype._removeWorkbook = function(formula)
                    {
                        if (formula.content.charAt(0) !== '[')
                        {
                            return {
                                    success: false, workBookName: ''
                                }
                        }
                        var index = formula.content.indexOf(']');
                        var workBookName = formula.content.substr(0, index + 1);
                        formula.content = formula.content.substr(index);
                        return {
                                success: true, workBookName: workBookName
                            }
                    };
                    Parser.prototype._unParseCell = function(useR1C1, baseRow, baseColumn, row, column, rowRelative, columnRelative, formula, rangeType)
                    {
                        if (rangeType === keyword_undefined || rangeType === keyword_null)
                        {
                            rangeType = RangeType.cell
                        }
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var maxRowIndex = Parser.maxRowCount - 1;
                        if ((rangeType === RangeType.cell || rangeType === RangeType.row) && row !== bandIndex && row > (-maxRowIndex) && row <= 2 * maxRowIndex)
                        {
                            row += (rowRelative ? baseRow : 0);
                            row = normalizeIndex(row, maxRowIndex)
                        }
                        var maxColumnIndex = Parser.maxColumnCount - 1;
                        if ((rangeType === RangeType.cell || rangeType === RangeType.column) && column !== bandIndex && column > -maxColumnIndex && column <= 2 * maxColumnIndex)
                        {
                            column += (columnRelative ? baseColumn : 0);
                            column = normalizeIndex(column, maxColumnIndex)
                        }
                        if (this._isCellIndexsError(baseRow, baseColumn, row, column, rowRelative, columnRelative, rangeType))
                        {
                            formula.content += CalcErrorsReference.toString();
                            return
                        }
                        var rowStr = "",
                            colStr = '';
                        if (useR1C1)
                        {
                            rowStr = 'R';
                            if (row >= 0 && (baseRow !== row || !rowRelative))
                            {
                                if (rowRelative)
                                {
                                    rowStr = rowStr + '[' + (row - baseRow) + ']'
                                }
                                else
                                {
                                    row++;
                                    rowStr = rowStr + row
                                }
                            }
                            if (column < 0)
                            {
                                formula.content += rowStr;
                                return
                            }
                            colStr = 'C';
                            if (baseColumn !== column || !columnRelative)
                            {
                                if (columnRelative)
                                {
                                    colStr = colStr + '[' + (column - baseColumn) + ']'
                                }
                                else
                                {
                                    column++;
                                    colStr = colStr + column
                                }
                            }
                            if ((rowRelative && row < 0) || (!rowRelative && row <= 0))
                            {
                                formula.content += colStr;
                                return
                            }
                            formula.content += rowStr;
                            formula.content += colStr
                        }
                        else
                        {
                            row++;
                            rowStr = "" + row;
                            if (!rowRelative)
                            {
                                rowStr = '$' + row
                            }
                            if (column < 0)
                            {
                                formula.content += rowStr;
                                return
                            }
                            var remainder = column;
                            for (var i = 1, LetterPowsLength = LetterPows.length; i < LetterPowsLength; i++)
                            {
                                var pow = LetterPows[LetterPowsLength - i];
                                column = parseInt((remainder / pow), 10);
                                remainder = remainder % pow;
                                if (column !== 0)
                                {
                                    colStr = colStr + String.fromCharCode(column + 65 - 1)
                                }
                            }
                            colStr = colStr + String.fromCharCode(remainder + 65);
                            if (!columnRelative)
                            {
                                colStr = '$' + colStr
                            }
                            if (row <= 0)
                            {
                                formula.content += colStr;
                                return
                            }
                            formula.content += colStr;
                            formula.content += rowStr
                        }
                    };
                    Parser.prototype._isCellIndexsError = function(baseRow, baseColumn, row, column, rowRelative, columnRelative, rangeType)
                    {
                        var hasError = false;
                        switch (rangeType)
                        {
                            case RangeType.sheet:
                                break;
                            case RangeType.cell:
                                hasError |= (row < 0);
                                hasError |= (column < 0);
                                break;
                            case RangeType.row:
                                hasError |= (row < 0);
                                break;
                            case RangeType.column:
                                hasError |= (column < 0);
                                break
                        }
                        return hasError
                    };
                    Parser.prototype._unParseRange = function(useR1C1, baseRow, baseColumn, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative, formula, rangeType)
                    {
                        if (rangeType === keyword_undefined || rangeType === keyword_null)
                        {
                            rangeType = RangeType.cell
                        }
                        this._unParseCell(useR1C1, baseRow, baseColumn, startRow, startColumn, startRowRelative, startColumnRelative, formula, rangeType);
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        if (useR1C1 && startRow === endRow && startColumn === endColumn && (endRow === bandIndex || endColumn === bandIndex))
                        {
                            return
                        }
                        if (endRow !== bandIndex || endColumn !== bandIndex)
                        {
                            formula.content += ':';
                            this._unParseCell(useR1C1, baseRow, baseColumn, endRow, endColumn, endRowRelative, endColumnRelative, formula, rangeType)
                        }
                    };
                    Parser.prototype._unParseOperatorExpressions = function(expr, context, formula)
                    {
                        var self = this;
                        if (expr.t === 11)
                        {
                            var op = expr.operator;
                            if (op === Operators.percent)
                            {
                                self._unparseExpression(expr.operand, context, formula);
                                formula.content += op.name
                            }
                            else
                            {
                                formula.content += op.name;
                                self._unparseExpression(expr.operand, context, formula)
                            }
                        }
                        else if (expr.t === 10)
                        {
                            var leftPart = {content: ""};
                            var rightPart = {content: ""};
                            self._unparseExpression(expr.right, context, rightPart);
                            var leftIsBin = expr.left.t === 10;
                            var rightIsBin = expr.right.t === 10;
                            var priority = getOpeatorPriority(expr.operator.name);
                            if (leftIsBin && getOpeatorPriority(expr.left.operator.name) > priority)
                            {
                                leftPart.content += '(';
                                self._unparseExpression(expr.left, context, leftPart);
                                leftPart.content += ')'
                            }
                            else
                            {
                                self._unparseExpression(expr.left, context, leftPart)
                            }
                            if (rightIsBin && getOpeatorPriority(expr.right.operator.name) > priority)
                            {
                                rightPart.content += '(';
                                self._unparseExpression(expr.right, context, rightPart);
                                rightPart.content += '('
                            }
                            formula.content += leftPart.content;
                            formula.content += expr.operator.t === 11 ? Parser.listSeparator : expr.operator.name;
                            formula.content += rightPart.content
                        }
                        else
                        {
                            throw Sheets.SR.Exp_NotSupport;
                        }
                    };
                    Parser.prototype._unparseConstantExpression = function(expr, context, formula)
                    {
                        var self = this;
                        var errMsg = Sheets.SR.Exp_InvalidArray;
                        if (expr.t === 5)
                        {
                            formula.content += '"';
                            formula.content += expr.value;
                            formula.content += '"'
                        }
                        else if (expr.t === 4)
                        {
                            var value = expr.originalValue;
                            if (!Parser.unparseWithoutCulture)
                            {
                                value = Sheets._NumberHelper.replaceNormalToCultureSymble(value.toString())
                            }
                            formula.content += value
                        }
                        else if (expr.t === 6)
                        {
                            formula.content += expr.value ? const_true : const_false
                        }
                        else if (expr.t === 15)
                        {
                            formula.content += '{';
                            var array = expr.value;
                            if (array.getRowCount() <= 0)
                            {
                                throw errMsg;
                            }
                            var bandIndex = Parser.BAND_INDEX_CONST;
                            var colCount = bandIndex;
                            for (var rowIndex = 0; rowIndex < array.getRowCount(); rowIndex++)
                            {
                                if (rowIndex >= 1)
                                {
                                    if (Parser.unparseWithoutCulture)
                                    {
                                        formula.content += ';'
                                    }
                                    else
                                    {
                                        formula.content += GcSpread.Sheets.CR.arrayGroupSeparator
                                    }
                                }
                                for (var columnIndex = 0; columnIndex < array.getColumnCount(); columnIndex++)
                                {
                                    if (colCount !== bandIndex && (colCount !== array.getColumnCount() || array.getColumnCount() === 0))
                                    {
                                        throw errMsg;
                                    }
                                    if (columnIndex !== 0)
                                    {
                                        var arrayArgumentSepatator;
                                        if (Parser.unparseWithoutCulture)
                                        {
                                            arrayArgumentSepatator = ','
                                        }
                                        else
                                        {
                                            arrayArgumentSepatator = (GcSpread.Sheets.CR.listSeparator === GcSpread.Sheets.CR.arrayGroupSeparator) ? '\\' : GcSpread.Sheets.CR.listSeparator
                                        }
                                        formula.content += arrayArgumentSepatator
                                    }
                                    var v = array.getValue(rowIndex, columnIndex);
                                    if (v === keyword_undefined || v === keyword_null)
                                    {
                                        throw errMsg;
                                    }
                                    if (v instanceof Expressions.Expression)
                                    {
                                        self._unparseExpression(v, context, formula)
                                    }
                                    else
                                    {
                                        if (typeof v === const_string)
                                        {
                                            formula.content += '"';
                                            formula.content += v;
                                            formula.content += '"'
                                        }
                                        else if (typeof v === const_boolean)
                                        {
                                            formula.content += v ? const_true : const_false
                                        }
                                        else if (!Parser.unparseWithoutCulture && typeof v === const_number)
                                        {
                                            formula.content += Sheets._NumberHelper.replaceNormalToCultureSymble(v.toString())
                                        }
                                        else
                                        {
                                            formula.content += v.toString()
                                        }
                                    }
                                }
                            }
                            formula.content += '}'
                        }
                        else if (expr.t === 13)
                        {
                            self._unparseSource(expr.source, context, formula);
                            formula.content += '!';
                            formula.content += expr.value.toString()
                        }
                        else if (expr.t === 19)
                        {
                            self._unparseSource2(expr.startSource, expr.endSource, context, formula);
                            formula.content += '!';
                            formula.content += expr.value.toString()
                        }
                        else if (expr.t === 20)
                        {
                            formula.content += '!';
                            formula.content += expr.value.toString()
                        }
                        else if (expr.t === 12)
                        {
                            formula.content += expr.value.toString()
                        }
                        else if (expr.t === 21)
                        {}
                        else
                        {
                            throw Sheets.SR.Exp_NotSupport;
                        }
                    };
                    Parser.prototype._parseToToken = function(formula, throwError)
                    {
                        if (typeof throwError === "undefined")
                        {
                            throwError = true
                        }
                        var self = this;
                        var len = formula.length;
                        var tokens1 = [];
                        var stack = [];
                        var stackEnd = -1;
                        var value = "";
                        var const_atIndexOn = Sheets.SR.AtIndexOn;
                        var currentToken;
                        var tokenStartIndex = 0;
                        var startIndex = 0;
                        var stackToken;
                        while (startIndex < len && formula.charAt(startIndex) === ' ')
                        {
                            startIndex++
                        }
                        if (formula.charAt(startIndex) === '=')
                        {
                            startIndex++
                        }
                        tokenStartIndex = startIndex;
                        for (var index = startIndex; index < len; index++)
                        {
                            var currentChar = formula.charAt(index);
                            var rs;
                            if (currentChar === '"')
                            {
                                rs = readString(formula, index, '"', '"', throwError);
                                if (rs)
                                {
                                    tokens1.push(new FormulaToken(rs.result, 0, index + 1, 3));
                                    index = rs.endIndex;
                                    tokenStartIndex = index + 1
                                }
                                else
                                {
                                    value += formula.substring(index, len);
                                    index = len - 1
                                }
                            }
                            else if (currentChar === "'")
                            {
                                rs = readString(formula, index, "'", "'", throwError);
                                if (rs)
                                {
                                    value += "'";
                                    value += rs.result;
                                    value += "'";
                                    index = rs.endIndex
                                }
                                else
                                {
                                    value += "'";
                                    index = index + 1
                                }
                            }
                            else if (currentChar === '[')
                            {
                                rs = readString2(formula, index, '[', ']', "'", throwError);
                                if (rs)
                                {
                                    value += rs.result;
                                    value += ']';
                                    index = rs.endIndex
                                }
                                else
                                {
                                    if (value === 'R' || value === 'r' || value === 'C' || value === 'c')
                                    {
                                        continue
                                    }
                                    value += formula.substring(index, len);
                                    index = len - 1
                                }
                            }
                            else if (currentChar === '\r' || currentChar === '\n')
                            {
                                continue
                            }
                            else if (currentChar === "#")
                            {
                                var re = readError(formula, index);
                                if (re)
                                {
                                    var nextChar = index < len ? formula.charAt(index + 1) : '\0';
                                    if (index > 0 && formula.charAt(index - 1) === '!')
                                    {
                                        value += re.result
                                    }
                                    else if (const_ref === re.result.toUpperCase() && index < len && (isLetterOrDigit(nextChar) || nextChar === '$'))
                                    {
                                        value += re.result
                                    }
                                    else
                                    {
                                        tokens1.push(new FormulaToken(re.result, 0, index, 6));
                                        tokenStartIndex = index + 1
                                    }
                                    index = re.endIndex
                                }
                                else
                                {
                                    value += currentChar
                                }
                            }
                            else if (currentChar === '+' || currentChar === '-')
                            {
                                var previous = tokens1.length === 0 ? null : tokens1[tokens1.length - 1];
                                if (value.length !== 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    tokens1.push(new FormulaToken(currentChar, 5, index));
                                    value = "";
                                    tokenStartIndex = index + 1
                                }
                                else
                                {
                                    if (previous && previous.type === 7)
                                    {
                                        tokens1.pop();
                                        var previous = tokens1[tokens1.length - 1]
                                    }
                                    if (previous && ((previous.type === 1 && previous.subType === 2) || (previous.type === 2 && previous.subType === 2) || (previous.type === 6) || (previous.type === 0)))
                                    {
                                        tokens1.push(new FormulaToken(currentChar, 5, index));
                                        tokenStartIndex = index + 1
                                    }
                                    else
                                    {
                                        tokens1.push(new FormulaToken(currentChar, 4, index));
                                        tokenStartIndex = index + 1
                                    }
                                }
                            }
                            else if (currentChar === Parser.numberDecimalSeparator || isDigit(currentChar))
                            {
                                var isNum;
                                if (value.length > 0)
                                {
                                    value += currentChar
                                }
                                else if ((isNum = isNumber2(formula, index, Parser.numberDecimalSeparator)).result)
                                {
                                    var endIndex = isNum.endIndex;
                                    var num = formula.slice(index, endIndex + 1);
                                    if (Parser.numberDecimalSeparator !== '.')
                                    {
                                        num = Sheets._NumberHelper.replaceCultureSymbolToNormal(num)
                                    }
                                    while (endIndex <= len - 2 && formula.charAt(endIndex + 1) === ' ')
                                    {
                                        endIndex++
                                    }
                                    if (endIndex <= len - 2 && formula.charAt(endIndex + 1) === ':')
                                    {
                                        value += num;
                                        value += ':';
                                        endIndex++;
                                        tokenStartIndex = index
                                    }
                                    else
                                    {
                                        tokens1.push(new FormulaToken(num, 0, index, 4));
                                        tokenStartIndex = index + 1
                                    }
                                    index = endIndex
                                }
                                else
                                {
                                    value += currentChar
                                }
                            }
                            else if (currentChar === '{')
                            {
                                if (value.length > 0 && throwError)
                                {
                                    throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + "{" + const_atIndexOn + index + Sheets.SR.FullStop;
                                }
                                currentToken = new FormulaToken(const_array, 1, index, 1);
                                tokens1.push(currentToken);
                                stack[++stackEnd] = currentToken;
                                currentToken = new FormulaToken(const_arrayRow, 1, index, 1);
                                tokens1.push(currentToken);
                                stack[++stackEnd] = currentToken;
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === Parser.arrayGroupSeparator && stackEnd >= 0 && (stack[stackEnd].value === const_array || stack[stackEnd].value === const_arrayRow))
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                if (stackEnd < 0 && throwError)
                                {
                                    throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + currentChar + const_atIndexOn + index + Sheets.SR.FullStop;
                                }
                                stackToken = stack[stackEnd--];
                                stackToken = new FormulaToken(currentChar, stackToken.type, index, 2);
                                tokens1.push(stackToken);
                                tokens1.push(new FormulaToken(Parser.listSeparator, 3, index));
                                currentToken = new FormulaToken(const_arrayRow, 1, index + 1, 1);
                                tokens1.push(currentToken);
                                stack[++stackEnd] = currentToken;
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === '}')
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                if (endIndex < 0 && throwError)
                                {
                                    throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + currentChar + const_atIndexOn + index + Sheets.SR.FullStop;
                                }
                                stackToken = stack[stackEnd--];
                                stackToken = new FormulaToken(currentChar, stackToken.type, index, 2);
                                tokens1.push(stackToken);
                                stackToken = stack[stackEnd--];
                                stackToken = new FormulaToken(currentChar, stackToken.type, index, 2);
                                tokens1.push(stackToken);
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === ' ')
                            {
                                var sIndex = index;
                                index++;
                                while ((index < len) && value.charAt(value.length - 1) === ' ')
                                {
                                    index++
                                }
                                if (value.length > 0 && value.charAt(value.length - 1) !== ':' && index < len && formula.charAt(index) !== ':')
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = "";
                                    tokens1.push(new FormulaToken("", 7, sIndex))
                                }
                                tokenStartIndex = index;
                                index--
                            }
                            else if ((index + 2) <= len && currentChar === '<' && formula.charAt(index + 1) === '=' || currentChar === '>' && formula.charAt(index + 1) === '=' || currentChar === '<' && formula.charAt(index + 1) === '>')
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                tokens1.push(new FormulaToken(formula.slice(index, index + 2), 5, index, 5));
                                index++;
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === '%')
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                tokens1.push(new FormulaToken(formula.charAt(index), 6, index));
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === '+' || currentChar === '-' || currentChar === '*' || currentChar === '/' || currentChar === '=' || currentChar === '>' || currentChar === '<' || currentChar === '&' || currentChar === '^')
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                tokens1.push(new FormulaToken(currentChar, 5, index));
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === '(')
                            {
                                if (value.length > 0)
                                {
                                    var lastChar = value.charAt(value.length - 1);
                                    if (lastChar === ':' || lastChar === Parser.listSeparator || lastChar === ' ')
                                    {
                                        value = value.slice(0, value.length - 1);
                                        tokens1.push(new FormulaToken(value, 0, tokenStartIndex, 7));
                                        tokens1.push(new FormulaToken(lastChar, 5, index - 1, 0));
                                        currentToken = new FormulaToken("", 2, index, 1);
                                        tokens1.push(currentToken);
                                        stack[++stackEnd] = currentToken
                                    }
                                    else
                                    {
                                        var refOpIndex = value.indexOf(':');
                                        var refOpToken = ':';
                                        if (refOpIndex === -1)
                                        {
                                            refOpIndex = value.indexOf(Parser.listSeparator);
                                            refOpToken = Parser.listSeparator
                                        }
                                        if (refOpIndex === -1)
                                        {
                                            refOpIndex = value.indexOf(' ');
                                            refOpToken = ' '
                                        }
                                        if (refOpIndex !== -1 && refOpIndex > 0)
                                        {
                                            tokens1.push(new FormulaToken(value.substr(0, refOpIndex), 0, tokenStartIndex, 7));
                                            tokens1.push(new FormulaToken(refOpToken, 5, tokenStartIndex + refOpIndex, 0));
                                            value = value.slice(refOpIndex + 1);
                                            currentToken = new FormulaToken(value.toUpperCase(), 1, tokenStartIndex + refOpIndex + 1, 1);
                                            tokens1.push(currentToken);
                                            stack[++stackEnd] = currentToken
                                        }
                                        else
                                        {
                                            currentToken = new FormulaToken(value.toUpperCase(), 1, index - value.length, 1);
                                            tokens1.push(currentToken);
                                            stack[++stackEnd] = currentToken
                                        }
                                    }
                                    value = ""
                                }
                                else
                                {
                                    currentToken = new FormulaToken("", 2, index, 1);
                                    tokens1.push(currentToken);
                                    stack[++stackEnd] = currentToken
                                }
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === Parser.listSeparator || currentChar === Parser._arrayArgumentSepatator || currentChar === Parser.arrayGroupSeparator)
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                if (stackEnd < 0 || stack[stackEnd].type !== 1)
                                {
                                    tokens1.push(new FormulaToken(Parser.listSeparator, 5, index, 10))
                                }
                                else
                                {
                                    tokens1.push(new FormulaToken(Parser._arrayArgumentSepatator, 3, index))
                                }
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === ')')
                            {
                                if (value.length > 0)
                                {
                                    tokens1.push(new FormulaToken(value, 0, tokenStartIndex));
                                    value = ""
                                }
                                if (stackEnd < 0 && throwError)
                                {
                                    throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + currentChar + const_atIndexOn + index + Sheets.SR.FullStop;
                                }
                                stackToken = stack[stackEnd--];
                                stackToken = new FormulaToken(currentChar, stackToken.type, index, 2);
                                tokens1.push(stackToken);
                                tokenStartIndex = index + 1
                            }
                            else if (currentChar === ':')
                            {
                                if (value.length === 0 && tokens1[tokens1.length - 1].subType === 2)
                                {
                                    tokens1.push(new FormulaToken(":", 5, index, 11));
                                    tokenStartIndex = index + 1
                                }
                                else
                                {
                                    value += ':'
                                }
                            }
                            else
                            {
                                value += currentChar
                            }
                        }
                        if (value.length > 0)
                        {
                            tokens1.push(new FormulaToken(value, 0, tokenStartIndex))
                        }
                        return self._processTokens(tokens1, throwError)
                    };
                    Parser.prototype._processTokens = function(tokens1, throwError)
                    {
                        var tokens2 = this._removeWhiteSpace(tokens1);
                        var stack = [];
                        var rootToken = new FormulaToken("", 8, 0, 1);
                        stack.push(rootToken);
                        var parent;
                        var length = tokens2.length;
                        for (var i = 0; i < length; i++)
                        {
                            var currentToken = tokens2[i];
                            if (!currentToken)
                            {
                                continue
                            }
                            var previous = i === 0 ? keyword_null : tokens2[i - 1];
                            var next = i === length - 1 ? keyword_null : tokens2[i + 1];
                            if (currentToken.type === 0 && currentToken.subType === 0)
                            {
                                var value = currentToken.value.toUpperCase();
                                if (value === const_true || value === const_false)
                                {
                                    currentToken.subType = 5;
                                    currentToken.value = value
                                }
                                else
                                {
                                    currentToken.subType = 7
                                }
                            }
                            else if (currentToken.type === 1)
                            {
                                if (currentToken.value.length > 0)
                                {
                                    if (currentToken.value.charAt(0) === '@')
                                    {
                                        currentToken.value = currentToken.value.substr(1)
                                    }
                                }
                            }
                            if (stack.length === 0 && throwError)
                            {
                                throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                            }
                            parent = stack[stack.length - 1];
                            if (parent.value === const_arrayRow)
                            {
                                if (throwError && (currentToken.type !== 3 && currentToken.subType !== 6 && currentToken.subType !== 2 && currentToken.subType !== 5 && currentToken.subType !== 4 && currentToken.subType !== 3 && currentToken.type !== 4))
                                {
                                    throw Sheets.SR.Exp_InvalidArrayAt + currentToken.index + Sheets.SR.FullStop;
                                }
                            }
                            switch (currentToken.type)
                            {
                                case 0:
                                    if (throwError && (previous && (previous.type === 0 || previous.type === 6 || previous.type === 1 && previous.subType === 2 || previous.type === 2 && previous.subType === 2)))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    break;
                                case 1:
                                case 2:
                                    if (currentToken.value === const_array && currentToken.type === 1 && currentToken.subType === 1 && !previous)
                                    {
                                        break
                                    }
                                    else if (throwError && (currentToken.subType === 2 && (!previous || previous.type === 4 || previous.type === 5) || currentToken.subType === 1 && previous && (!next || previous.type === 6 || previous.subType === 2)))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    if (throwError && (currentToken.subType === 2 && currentToken.type === 2 && previous.subType === 1))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    if (throwError && (currentToken.subType === 2 && currentToken.type === 1 && previous.type === 2 && previous.subType === 1))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    if (throwError && currentToken.subType === 1 && previous && (previous.type === 1 && previous.subType === 2 || previous.type === 0 || previous.type === 6))
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    break;
                                case 3:
                                    if (throwError && (!next || !previous || previous.type === 5 || previous.type === 4))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    break;
                                case 4:
                                    if (throwError && (!next || previous && (previous.type === 6)))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    break;
                                case 5:
                                    if (throwError && (!next || !previous || previous.type === 5 || previous.type === 4 || previous.type === 3 || previous.type === 1 && previous.subType === 1 || previous.type === 2 && previous.subType === 1))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    break;
                                case 6:
                                    if (throwError && (!previous || previous.type === 4 || previous.type === 5 || previous.type === 1 && previous.subType === 1 || previous.type === 2 && previous.subType === 1))
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                                    break;
                                default:
                                    if (throwError)
                                    {
                                        throw Sheets.SR.Exp_InvalidTokenAt + currentToken.index + Sheets.SR.FullStop;
                                    }
                            }
                            if (throwError)
                            {
                                if (currentToken.subType === 1)
                                {
                                    stack.push(currentToken);
                                    parent.children.push(currentToken)
                                }
                                else if (currentToken.subType === 2)
                                {
                                    if (stack.length === 0)
                                    {
                                        var currentChar;
                                        if (currentToken.value === const_array || currentToken.value === const_arrayRow)
                                        {
                                            currentChar = '}'
                                        }
                                        else
                                        {
                                            currentChar = ')'
                                        }
                                        if (throwError)
                                        {
                                            throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + currentChar + Sheets.SR.SingleQuoteAt + currentToken.index + Sheets.SR.FullStop;
                                        }
                                    }
                                    stack.pop()
                                }
                                else
                                {
                                    parent.children.push(currentToken)
                                }
                            }
                        }
                        if (throwError)
                        {
                            return rootToken.children
                        }
                        else
                        {
                            return tokens2
                        }
                    };
                    Parser.prototype._removeWhiteSpace = function(tokens1)
                    {
                        var tokens2 = [];
                        var length = tokens1.length;
                        for (var i = 0; i < length; i++)
                        {
                            var token = tokens1[i];
                            if (!token)
                            {
                                continue
                            }
                            if (token.type !== 7)
                            {
                                tokens2.push(token);
                                continue
                            }
                            var previous = i == 0 ? keyword_null : tokens1[i - 1];
                            var next = i == length - 1 ? keyword_null : tokens1[i + 1];
                            if (!previous || !next)
                            {
                                continue
                            }
                            if ((((previous.type === 1) && (previous.subType === 2)) || ((previous.type === 2) && (previous.subType === 2)) || (previous.type === 0)) && (((next.type === 1) && (next.subType === 1)) || ((next.type === 2) && (next.subType === 1)) || (next.type === 0)))
                            {
                                tokens2.push(new FormulaToken(" ", 5, token.index, 9))
                            }
                        }
                        return tokens2
                    };
                    Parser.prototype._buildExpressionNode = function(context, token)
                    {
                        var self = this;
                        var currentExpression;
                        if (token.type === 1)
                        {
                            if (token.value === const_array)
                            {
                                currentExpression = self._buildArraryExpression(context, token)
                            }
                            else
                            {
                                currentExpression = self._buildFunctionExpression(context, token)
                            }
                        }
                        else if (token.type === 2)
                        {
                            currentExpression = self._buildSubExpression(context, token)
                        }
                        else if (token.type === 0)
                        {
                            if (token.subType === 4)
                            {
                                currentExpression = new Expressions.DoubleExpression(parseFloat(token.value), token.value)
                            }
                            else if (token.subType === 6)
                            {
                                currentExpression = new Expressions.ErrorExpression(CalcError.parse(token.value))
                            }
                            else if (token.subType === 5)
                            {
                                if (compareStringIgnoreCase(token.value, const_true))
                                {
                                    currentExpression = new Expressions.BooleanExpression(true)
                                }
                                else if (compareStringIgnoreCase(token.value, const_false))
                                {
                                    currentExpression = new Expressions.BooleanExpression(false)
                                }
                            }
                            else if (token.subType === 7)
                            {
                                currentExpression = self._buildCellReferenceOrNameExpressions(context, token.value, token.index)
                            }
                            else
                            {
                                currentExpression = new Expressions.StringExpression(token.value)
                            }
                        }
                        return currentExpression
                    };
                    Parser.prototype._buildExpressionTree = function(context, tokens)
                    {
                        var results = this._parseToBinaryOperatorList(context, tokens);
                        var currentExpression,
                            lastExpression,
                            nextExpression,
                            index;
                        for (index = 3; index < results.length; )
                        {
                            var nextToken = results[index];
                            var currentToken = results[index - 2];
                            if (nextToken && nextToken.type === 5)
                            {
                                while (index >= 3 && getOpeatorPriority(nextToken.value) >= getOpeatorPriority(currentToken.value))
                                {
                                    lastExpression = results[index - 3];
                                    nextExpression = results[index - 1];
                                    currentExpression = new Expressions.BinaryOperatorExpression(getBinaryOperator(currentToken), lastExpression, nextExpression);
                                    results.splice(index - 3, 3);
                                    results.splice(index - 3, 0, currentExpression);
                                    index -= 2;
                                    if (index >= 3)
                                    {
                                        currentToken = results[index - 2]
                                    }
                                }
                                index += 2
                            }
                            else
                            {
                                index++
                            }
                        }
                        if (results.length === 1)
                        {
                            return results[0]
                        }
                        else
                        {
                            for (index = results.length - 2; index > 0; index -= 2)
                            {
                                lastExpression = results[index - 1];
                                nextExpression = results[index + 1];
                                currentExpression = new Expressions.BinaryOperatorExpression(getBinaryOperator(results[index]), lastExpression, nextExpression);
                                results.splice(index - 1, 3);
                                results.push(currentExpression)
                            }
                            return currentExpression
                        }
                    };
                    Parser.prototype._parseToBinaryOperatorList = function(context, tokens)
                    {
                        var results = [];
                        var currentExpression;
                        for (var i = 0; i < tokens.length; i++)
                        {
                            var currentToken = tokens[i];
                            if (currentToken.type === 4)
                            {
                                var opStack = [];
                                while (currentToken.type === 4)
                                {
                                    opStack.push(currentToken.value === '+' ? Operators.plus : Operators.negate);
                                    i++;
                                    currentToken = tokens[i]
                                }
                                var nextToken = tokens[i];
                                currentExpression = new Expressions.UnaryOperatorExpression(opStack.pop(), this._buildExpressionNode(context, nextToken));
                                while (opStack.length > 0)
                                {
                                    currentExpression = new Expressions.UnaryOperatorExpression(opStack.pop(), currentExpression)
                                }
                                results.push(currentExpression)
                            }
                            else if (currentToken.type === 6)
                            {
                                var lastExpression = results[results.length - 1];
                                currentExpression = new Expressions.UnaryOperatorExpression(Operators.percent, lastExpression);
                                results.pop();
                                results.push(currentExpression)
                            }
                            else if (currentToken.type === 5)
                            {
                                results.push(currentToken)
                            }
                            else
                            {
                                currentExpression = this._buildExpressionNode(context, currentToken);
                                results.push(currentExpression)
                            }
                        }
                        return results
                    };
                    Parser.prototype._buildFunctionExpression = function(context, rootToken)
                    {
                        var args = [];
                        var subTokens = [];
                        for (var i = 0; i < rootToken.children.length; i++)
                        {
                            var token = rootToken.children[i];
                            if (token.type !== 3)
                            {
                                subTokens.push(token)
                            }
                            else
                            {
                                if (subTokens.length === 0)
                                {
                                    args.push(new Expressions.MissingArgumentExpression)
                                }
                                else
                                {
                                    args.push(this._buildExpressionTree(context, subTokens));
                                    subTokens = []
                                }
                            }
                        }
                        if (subTokens.length !== 0)
                        {
                            args.push(this._buildExpressionTree(context, subTokens))
                        }
                        else if (rootToken.children.length !== 0)
                        {
                            args.push(new Expressions.MissingArgumentExpression)
                        }
                        var fn = Functions.findGlobalFunction(rootToken.value);
                        if (fn)
                        {
                            var argsLength = args.length;
                            if (argsLength < fn.minArgs || argsLength > fn.maxArgs)
                            {
                                throw Sheets.SR.Exp_InvalidParameters + rootToken.index + Sheets.SR.FullStop;
                            }
                            return new Expressions.FunctionExpression(fn, args)
                        }
                        else
                        {
                            return new Expressions.FunctionExpression(rootToken.value, args)
                        }
                    };
                    Parser.prototype._buildSubExpression = function(context, rootToken)
                    {
                        return new Expressions.ParenthesesExpression(this._buildExpressionTree(context, rootToken.children))
                    };
                    Parser.prototype._buildArraryExpression = function(context, rootToken)
                    {
                        var args = [];
                        var colCount = -1;
                        var arrayRowToken,
                            rootTokenChildren = rootToken.children,
                            rootTokenChildrenLength = rootTokenChildren.length;
                        for (var i = 0; i < rootTokenChildrenLength; i++)
                        {
                            arrayRowToken = rootTokenChildren[i];
                            var previous = (i === 0 ? keyword_null : rootTokenChildren[i - 1]);
                            if (arrayRowToken.type === 3)
                            {
                                if (!previous || previous.type === 3 || i === rootTokenChildrenLength - 1)
                                {
                                    throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index + Sheets.SR.FullStop;
                                }
                                continue
                            }
                            else if (previous && previous.type !== 3)
                            {
                                throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index + Sheets.SR.FullStop;
                            }
                            else if (arrayRowToken.type !== 1 || arrayRowToken.value !== const_arrayRow)
                            {
                                throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index + Sheets.SR.FullStop;
                            }
                            else if (colCount !== -1 && arrayRowToken.children.length !== colCount)
                            {
                                throw Sheets.SR.Exp_InvalidArrayColumns + arrayRowToken.index + Sheets.SR.FullStop;
                            }
                            else
                            {
                                colCount = arrayRowToken.children.length
                            }
                            var row = [];
                            args.push(row);
                            var arrayRowTokenChildren = arrayRowToken.children,
                                length = arrayRowTokenChildren.length;
                            var lastToken = keyword_null;
                            for (var index = 0; index < length; index++)
                            {
                                var token = arrayRowTokenChildren[index];
                                if (token.type === 3)
                                {
                                    if (!lastToken || lastToken.type === 3 || index === length - 1)
                                    {
                                        row.push(Calc.missingArgument)
                                    }
                                }
                                else if (lastToken && lastToken.type !== 3)
                                {
                                    throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index;
                                }
                                else
                                {
                                    var nextToken;
                                    if (token.type === 4)
                                    {
                                        if (index + 1 >= length)
                                        {
                                            throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index;
                                        }
                                        nextToken = arrayRowTokenChildren[index + 1];
                                        nextToken.value = "" + token.value + nextToken.value;
                                        token = nextToken;
                                        index++
                                    }
                                    else if (index + 1 < length && arrayRowTokenChildren[index + 1].type === 6)
                                    {
                                        nextToken = arrayRowTokenChildren[index + 1];
                                        token.value = "" + token.value + nextToken.value;
                                        index++
                                    }
                                    var expr = this._buildExpressionNode(context, token);
                                    if (expr)
                                    {
                                        row.push(expr.value)
                                    }
                                }
                                lastToken = token
                            }
                        }
                        if (args.length === 0 || args[0] === keyword_undefined || args[0] === keyword_null || args[0].length === 0)
                        {
                            throw Sheets.SR.Exp_InvalidArrayAt + arrayRowToken.index;
                        }
                        return new Expressions.ArrayExpression(args)
                    };
                    Parser.prototype._buildCellReferenceOrNameExpressions = function(context, value, index)
                    {
                        var result = this._buildCellReferenceOrNameExpressions2(context, value, index);
                        var endIndex = result.endIndex;
                        var expression = result.expression;
                        var valueLength = value.length;
                        if (!expression)
                        {
                            throw Sheets.SR.Exp_InvalidCellReference + index + Sheets.SR.FullStop;
                        }
                        if (endIndex <= 0 || endIndex >= valueLength)
                        {
                            return expression
                        }
                        if (value.charAt(endIndex) !== ':')
                        {
                            throw Sheets.SR.Exp_InvalidCellReference + index + Sheets.SR.FullStop;
                        }
                        endIndex++;
                        var expressions = [];
                        expressions.push(expression);
                        while (endIndex > 0 && endIndex < valueLength)
                        {
                            var startIndex = endIndex;
                            result = this._buildCellReferenceOrNameExpressions2(context, value.substr(endIndex), index);
                            endIndex = result.endIndex;
                            expression = result.expression;
                            if (!expression)
                            {
                                throw Sheets.SR.Exp_InvalidCellReference + index + Sheets.SR.FullStop;
                            }
                            expressions.push(expression);
                            endIndex += startIndex;
                            if (endIndex < valueLength && value.charAt(endIndex) !== ':')
                            {
                                throw Sheets.SR.Exp_InvalidCellReference + index + Sheets.SR.FullStop;
                            }
                            endIndex++
                        }
                        expression = expressions[0];
                        for (var i = 1; i < expressions.length; i++)
                        {
                            expression = new Expressions.BinaryOperatorExpression(Operators.range, expression, expressions[i])
                        }
                        return expression
                    };
                    Parser.prototype._buildCellReferenceOrNameExpressions2 = function(context, value, index)
                    {
                        var self = this;
                        if (value === keyword_undefined || value === keyword_null || value === '')
                        {
                            return {
                                    endIndex: 0, expression: keyword_null
                                }
                        }
                        var length = value.length;
                        if (value.length >= 5 && value.substr(0, 5) === '#REF!')
                        {
                            return {
                                    endIndex: length, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                        }
                        var isBang = value.charAt(0) === '!';
                        var startIndex = isBang ? 1 : 0;
                        if (length < 1)
                        {
                            return {
                                    endIndex: 0, expression: keyword_null
                                }
                        }
                        var cellOrNameStartIndex = -1;
                        var sheetRefStr = "";
                        var endIndex = 0;
                        if (isBang)
                        {
                            cellOrNameStartIndex = startIndex
                        }
                        else if (value.charAt(0) === "'")
                        {
                            cellOrNameStartIndex = value.indexOf('!') + 1;
                            sheetRefStr = value.substr(0, cellOrNameStartIndex - 1)
                        }
                        else
                        {
                            var excalmatoryIndex = value.indexOf('!');
                            var rangeIndex = value.indexOf(':');
                            if (excalmatoryIndex !== -1)
                            {
                                var startString = value.substr(startIndex, excalmatoryIndex - startIndex);
                                if (rangeIndex < 0 || excalmatoryIndex < rangeIndex)
                                {
                                    if (excalmatoryIndex < length - 1)
                                    {
                                        sheetRefStr = startString;
                                        cellOrNameStartIndex = excalmatoryIndex + 1
                                    }
                                }
                                else
                                {
                                    var expr = self._parseToCellReference(context, startString, isBang);
                                    if (expr.expression)
                                    {
                                        return expr
                                    }
                                    else
                                    {
                                        if (excalmatoryIndex < length - 1)
                                        {
                                            sheetRefStr = startString;
                                            cellOrNameStartIndex = excalmatoryIndex + 1
                                        }
                                    }
                                    endIndex = expr.endIndex
                                }
                            }
                        }
                        var workBookName = "";
                        var startSheetName = "";
                        var endSheetName = "";
                        if (cellOrNameStartIndex !== -1 && sheetRefStr && sheetRefStr !== "")
                        {
                            var result = self._readSheetReference(context, sheetRefStr, context.useR1C1, false);
                            if (!result.success)
                            {
                                return {
                                        endIndex: endIndex, expression: keyword_null
                                    }
                            }
                            workBookName = result.workBookName;
                            startSheetName = result.startSheetName;
                            endSheetName = result.endSheetName
                        }
                        else
                        {
                            cellOrNameStartIndex = startIndex
                        }
                        var src,
                            startSource,
                            endSource;
                        var isExternalExpression = false;
                        if ((workBookName && workBookName !== '') || (startSheetName && startSheetName !== ''))
                        {
                            isExternalExpression = true;
                            if (context.getExternalSource)
                            {
                                startSource = context.getExternalSource(workBookName, startSheetName);
                                if (!startSource)
                                {
                                    return {
                                            endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                        }
                                }
                            }
                        }
                        if (endSheetName && endSheetName !== '')
                        {
                            isExternalExpression = true;
                            if (context.getExternalSource)
                            {
                                endSource = context.getExternalSource(workBookName, endSheetName);
                                if (!endSource)
                                {
                                    return {
                                            endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                        }
                                }
                            }
                        }
                        var cellOrNameStr = value.substr(cellOrNameStartIndex);
                        var exprResult = self._parseToCellReference(context, cellOrNameStr, isBang, startSource, endSource);
                        var expr2 = exprResult.expression;
                        endIndex = exprResult.endIndex;
                        if (!expr2)
                        {
                            var currentChar;
                            var rangeIndex = -1;
                            for (var i = 0; i < value.length; i++)
                            {
                                currentChar = value[i];
                                if (currentChar === '[')
                                {
                                    var rs = readString2(value, i, '[', ']', '\'');
                                    if (rs)
                                    {
                                        i = rs.endIndex
                                    }
                                }
                                else if (currentChar === ':')
                                {
                                    rangeIndex = i;
                                    break
                                }
                            }
                            if (isBang)
                            {
                                expr2 = new Expressions.BangNameExpression(cellOrNameStr)
                            }
                            else if (startSheetName && startSheetName !== '')
                            {
                                if (endSheetName && endSheetName !== '')
                                {
                                    return {
                                            endIndex: endIndex, expression: keyword_null
                                        }
                                }
                                if (!context.getExternalSource)
                                {
                                    return {
                                            endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                        }
                                }
                                src = context.getExternalSource(workBookName, startSheetName);
                                if (!src)
                                {
                                    return {
                                            endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                        }
                                }
                                expr2 = new Expressions.ExternalNameExpression(src, cellOrNameStr)
                            }
                            else
                            {
                                if (rangeIndex > 0)
                                {
                                    var nameString = value.substr(0, rangeIndex);
                                    if (!context.ignoreError && !self._validateName(nameString))
                                    {
                                        expr2 = keyword_null
                                    }
                                    else
                                    {
                                        expr2 = new Calc.Expressions.BinaryOperatorExpression(Calc.Operators.range, new Calc.Expressions.NameExpression(nameString), self._buildCellReferenceOrNameExpressions(context, value.substr(rangeIndex + 1), index + rangeIndex + 1))
                                    }
                                }
                                else
                                {
                                    expr2 = new Expressions.NameExpression(cellOrNameStr)
                                }
                            }
                            endIndex = length
                        }
                        else if (isExternalExpression && !(expr2.t === 16) && !(expr2 instanceof Expressions.ExternalReferenceExpression) && !(expr2.t === 13) && !(expr2.t === 19) && !(expr2.t === 9))
                        {
                            return {
                                    endIndex: length, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                }
                        }
                        else if (endIndex < cellOrNameStr.length - 1)
                        {
                            endIndex = length - (cellOrNameStr.length - endIndex);
                            if (value.charAt(endIndex) !== ':')
                            {
                                if (startSheetName && startSheetName !== '')
                                {
                                    if (endSheetName && endSheetName !== '')
                                    {
                                        return {
                                                endIndex: endIndex, expression: keyword_null
                                            }
                                    }
                                    if (!context.getExternalSource)
                                    {
                                        return {
                                                endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                            }
                                    }
                                    src = context.getExternalSource(workBookName, startSheetName);
                                    if (!src)
                                    {
                                        return {
                                                endIndex: endIndex, expression: new Expressions.ErrorExpression(CalcErrorsReference)
                                            }
                                    }
                                    expr2 = new Expressions.ExternalNameExpression(src, cellOrNameStr)
                                }
                                else
                                {
                                    expr2 = new Expressions.NameExpression(cellOrNameStr)
                                }
                                endIndex = length
                            }
                        }
                        else
                        {
                            endIndex = length
                        }
                        if (expr2 && (expr2.t === 9 || expr2.t === 8))
                        {
                            var structExpr = self._createStructExpression(context, cellOrNameStr, index);
                            if (structExpr)
                            {
                                expr2 = structExpr
                            }
                            else if (!context.ignoreError && !self._validateName(cellOrNameStr))
                            {
                                return {
                                        endIndex: endIndex, expression: keyword_null
                                    }
                            }
                        }
                        return {
                                endIndex: endIndex, expression: expr2
                            }
                    };
                    Parser.prototype._parseToCellReference = function(context, value, isBang, startSource, endSource)
                    {
                        var self = this;
                        var endIndex = 0;
                        if (value.charAt(0) === '#')
                        {
                            var rs = readError(value, 0);
                            endIndex = rs.endIndex + 1;
                            var err = CalcError.parse(rs.result);
                            if (err)
                            {
                                return {
                                        endIndex: endIndex, expression: self._createExternalErrorExpression(err, isBang, startSource, endSource)
                                    }
                            }
                        }
                        var result = context.useR1C1 ? self._isR1C1CellReferance(value, context.row, context.column) : self._isA1CellReferance(value);
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        if (result.success && context.useR1C1 && result.startRow !== bandIndex && result.startColumn === bandIndex && result.endRow === bandIndex && result.endColumn === bandIndex)
                        {
                            result.endRow = result.startRow;
                            result.endRowRelative = result.startRowRelative
                        }
                        else if (result.success && context.useR1C1 && result.startColumn !== bandIndex && result.startRow === bandIndex && result.endRow === bandIndex && result.endColumn === bandIndex)
                        {
                            result.endColumn = result.startColumn;
                            result.endColumnRelative = result.startColumnRelative
                        }
                        else if (!result.success || (result.startRow === bandIndex && (result.startColumn === bandIndex || result.endColumn === bandIndex)) || (result.startColumn === bandIndex && result.endRow === bandIndex))
                        {
                            return {
                                    endIndex: result.endIndex, expression: keyword_null
                                }
                        }
                        var cellExpr = self._createCellReferenceExpression(context, context.row, context.column, result.startRow, result.startColumn, result.endRow, result.endColumn, result.startRowRelative, result.startColumnRelative, result.endRowRelative, result.endColumnRelative, isBang, startSource, endSource);
                        return {
                                endIndex: result.endIndex, expression: cellExpr
                            }
                    };
                    Parser.prototype._createExternalErrorExpression = function(err, isBang, startSource, endSource)
                    {
                        if (isBang)
                        {
                            return new Expressions.BangErrorExpression(err)
                        }
                        else if (startSource && endSource)
                        {
                            return new Expressions.SheetRangeErrorExpression(startSource, endSource, err)
                        }
                        else if (startSource)
                        {
                            return new Expressions.ExternalErrorExpression(startSource, err)
                        }
                        else
                        {
                            return new Expressions.ErrorExpression(err)
                        }
                    };
                    Parser.prototype._createCellReferenceExpression = function(context, baseRowIndex, baseColIndex, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative, isBang, startSource, endSource)
                    {
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var expr;
                        if (startRow !== bandIndex && endRow != bandIndex && startRow > endRow)
                        {
                            var t1 = startRow;
                            startRow = endRow;
                            endRow = t1;
                            var t2 = startRowRelative;
                            startRowRelative = endRowRelative;
                            endRowRelative = t2
                        }
                        if (startColumn !== bandIndex && endColumn != bandIndex && startColumn > endColumn)
                        {
                            var t1 = startColumn;
                            startColumn = endColumn;
                            endColumn = t1;
                            var t2 = startColumnRelative;
                            startColumnRelative = endColumnRelative;
                            endColumnRelative = t2
                        }
                        startRow -= startRow !== bandIndex && startRowRelative ? baseRowIndex : 0;
                        startColumn -= startColumn != bandIndex && startColumnRelative ? baseColIndex : 0;
                        endRow -= endRow !== bandIndex && endRowRelative ? baseRowIndex : 0;
                        endColumn -= endColumn !== bandIndex && endColumnRelative ? baseColIndex : 0;
                        if (startSource && endSource)
                        {
                            expr = new Expressions.SheetRangeExpression(startSource, endSource);
                            if (startRow === bandIndex)
                            {
                                expr.initBand(startSource, endSource, startColumn, endColumn, startColumnRelative, endColumnRelative, false)
                            }
                            else if (startColumn === bandIndex)
                            {
                                expr.initBand(startSource, endSource, startRow, endRow, startRowRelative, endRowRelative, true)
                            }
                            else
                            {
                                expr.init(startSource, endSource, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                            }
                            return expr
                        }
                        else if (endRow === bandIndex && endColumn === bandIndex)
                        {
                            if (isBang)
                            {
                                if (startSource || endSource)
                                {
                                    return keyword_null
                                }
                                return new Expressions.BangCellExpression(startRow, startColumn, startRowRelative, startColumnRelative)
                            }
                            else if (startSource)
                            {
                                return new Expressions.ExternalCellExpression(startSource, startRow, startColumn, startRowRelative, startColumnRelative)
                            }
                            else
                            {
                                return new Expressions.CellExpression(startRow, startColumn, startRowRelative, startColumnRelative)
                            }
                        }
                        else
                        {
                            if (isBang)
                            {
                                if (startSource && endSource)
                                {
                                    return keyword_null
                                }
                                expr = new Expressions.BangRangeExpression;
                                if (startRow === bandIndex)
                                {
                                    expr.initBand(startColumn, endColumn, startColumnRelative, endColumnRelative, false)
                                }
                                else if (startColumn === bandIndex)
                                {
                                    expr.initBand(startRow, endRow, startRowRelative, endRowRelative, true)
                                }
                                else
                                {
                                    expr.init(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                                }
                                return expr
                            }
                            else if (startSource)
                            {
                                expr = new Expressions.ExternalRangeExpression;
                                if (startRow === bandIndex)
                                {
                                    expr.initBand(startSource, startColumn, endColumn, startColumnRelative, endColumnRelative, false)
                                }
                                else if (startColumn === bandIndex)
                                {
                                    expr.initBand(startSource, startRow, endRow, startRowRelative, endRowRelative, true)
                                }
                                else
                                {
                                    expr.init(startSource, startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                                }
                                return expr
                            }
                            else
                            {
                                expr = new Expressions.RangeExpression;
                                if (startRow === bandIndex)
                                {
                                    expr.initBand(startColumn, endColumn, startColumnRelative, endColumnRelative, false)
                                }
                                else if (startColumn === bandIndex)
                                {
                                    expr.initBand(startRow, endRow, startRowRelative, endRowRelative, true)
                                }
                                else
                                {
                                    expr.init(startRow, startColumn, endRow, endColumn, startRowRelative, startColumnRelative, endRowRelative, endColumnRelative)
                                }
                                return expr
                            }
                        }
                    };
                    Parser.prototype._readSheetReference = function(context, value, isR1C1, isUnparse)
                    {
                        var result = {
                                success: false, startSheetName: "", endSheetName: "", workBookName: ""
                            };
                        var containsSpecial = false,
                            valueLength = value.length;
                        if (value.charAt(0) === "'" && value.charAt(valueLength - 1) === "'")
                        {
                            containsSpecial = true;
                            value = value.substr(1, valueLength - 2)
                        }
                        var workBookIndex = value.indexOf('[');
                        if (workBookIndex !== -1)
                        {
                            if (workBookIndex !== 0)
                            {
                                result.workBookName = value.substr(0, workBookIndex);
                                if (result.workBookName.charAt(workBookIndex - 1) !== '\\')
                                {
                                    result.workBookName = result.workBookName + '\\'
                                }
                            }
                            var rs = readString(value, workBookIndex, '[', ']');
                            result.workBookName = result.workBookName + rs.result;
                            value = value.substr(rs.endIndex + 1)
                        }
                        var colonIndex = value.indexOf(':');
                        if (colonIndex === -1)
                        {
                            result.startSheetName = value
                        }
                        else
                        {
                            result.startSheetName = value.substr(0, colonIndex);
                            result.endSheetName = value.substr(colonIndex + 1)
                        }
                        if (!result.startSheetName || result.startSheetName === '')
                        {
                            result.success = false;
                            return result
                        }
                        var self = this;
                        var valid = self._validateWorkbook(result.workBookName, containsSpecial);
                        valid = context.ignoreError && !isUnparse || self._validateSheetName(result.startSheetName, isR1C1, containsSpecial);
                        valid &= context.ignoreError && !isUnparse || self._validateSheetName(result.endSheetName, isR1C1, containsSpecial);
                        if (isUnparse)
                        {
                            if (result.startSheetName)
                            {
                                result.startSheetName = result.startSheetName.replace("'", "''")
                            }
                            if (result.endSheetName)
                            {
                                result.endSheetName = result.endSheetName.replace("'", "''")
                            }
                        }
                        result.success = valid;
                        return result
                    };
                    Parser.prototype._isStartWithCellReference = function(value, isR1C1)
                    {
                        return isR1C1 ? this._isR1C1CellReferance(value) : this._isA1CellReferance(value)
                    };
                    Parser.prototype._isA1CellReferance = function(value)
                    {
                        var self = this;
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var result = {
                                startRow: bandIndex, startColumn: bandIndex, endRow: bandIndex, endColumn: bandIndex, startRowRelative: true, startColumnRelative: true, endRowRelative: true, endColumnRelative: true, success: false, endIndex: 0
                            };
                        value = value.replace(' ', '');
                        var length = value.length;
                        var read = self._readOneA1Element(value, 0);
                        result.endIndex = read.endIndex;
                        if (!read.success || result.endIndex > length)
                        {
                            return result
                        }
                        var read2;
                        if (read.isRow)
                        {
                            result.startRow = read.elementIndex;
                            result.startRowRelative = read.isRelative;
                            if (value.charAt(result.endIndex) === ':')
                            {
                                result.endIndex++;
                                read2 = self._readOneA1Element(value, result.endIndex);
                                result.endIndex = read2.endIndex;
                                if (!read2.success || !read2.isRow)
                                {
                                    return result
                                }
                                result.endRow = read2.elementIndex;
                                result.endRowRelative = read2.isRelative;
                                result.success = true;
                                return result
                            }
                            else
                            {
                                return result
                            }
                        }
                        else
                        {
                            result.startColumn = read.elementIndex;
                            result.startColumnRelative = read.isRelative;
                            if (value.charAt(result.endIndex) === ':')
                            {
                                result.endIndex++;
                                read2 = self._readOneA1Element(value, result.endIndex);
                                result.endIndex = read2.endIndex;
                                if (!read2.success || read2.isRow)
                                {
                                    return result
                                }
                                result.endColumn = read2.elementIndex;
                                result.endColumnRelative = read2.isRelative;
                                result.success = true;
                                return result
                            }
                        }
                        if (isNumber(value.charAt(result.endIndex)) || value.charAt(result.endIndex) === '$')
                        {
                            read2 = self._readOneA1Element(value, result.endIndex);
                            result.endIndex = read2.endIndex;
                            if (!read2.success || !read2.isRow)
                            {
                                return result
                            }
                            result.startRow = read2.elementIndex;
                            result.startRowRelative = read2.isRelative;
                            var cellEndIndex = result.endIndex;
                            if (result.endIndex < length - 1 && value.charAt(result.endIndex) === ':')
                            {
                                if (value.charAt(result.endIndex + 1) === "'")
                                {
                                    result.success = true;
                                    return result
                                }
                                var nextSheetIndex = value.indexOf('!', result.endIndex + 1);
                                var nextRangeIndex = value.indexOf(':', result.endIndex + 1);
                                if (nextSheetIndex !== -1 && (nextRangeIndex === -1 || nextRangeIndex > nextSheetIndex))
                                {
                                    result.success = true;
                                    return result
                                }
                                result.endIndex++;
                                var read3 = self._readOneA1Element(value, result.endIndex);
                                if (!read3.success || read3.isRow)
                                {
                                    result.endIndex = cellEndIndex;
                                    result.success = true;
                                    return result
                                }
                                else
                                {
                                    result.endIndex = read3.endIndex
                                }
                                result.endColumn = read3.elementIndex;
                                result.endColumnRelative = read3.isRelative;
                                var read4 = self._readOneA1Element(value, result.endIndex);
                                if (!read4.success || !read4.isRow)
                                {
                                    result.endIndex = cellEndIndex;
                                    result.endColumn = bandIndex;
                                    result.success = true;
                                    return result
                                }
                                else
                                {
                                    result.endIndex = read4.endIndex
                                }
                                result.endRow = read4.elementIndex;
                                result.endRowRelative = read4.isRelative;
                                result.success = true;
                                return result
                            }
                            else
                            {
                                result.success = true;
                                return result
                            }
                        }
                        else
                        {
                            return result
                        }
                    };
                    Parser.prototype._isR1C1CellReferance = function(value, baseRow, baseColumn)
                    {
                        var self = this;
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var result = {
                                startRow: bandIndex, startColumn: bandIndex, endRow: bandIndex, endColumn: bandIndex, startRowRelative: true, startColumnRelative: true, endRowRelative: true, endColumnRelative: true, success: false, endIndex: 0
                            };
                        value = value.replace(' ', '');
                        var length = value.length;
                        var read = self._readOneR1C1Element(value, baseRow, baseColumn, 0);
                        result.endIndex = read.endIndex;
                        if (!read.success)
                        {
                            return result
                        }
                        var read2;
                        if (read.isRow)
                        {
                            result.startRow = read.elementIndex;
                            result.startRowRelative = read.isRelative;
                            if (result.endIndex >= length)
                            {
                                result.success = true;
                                return result
                            }
                            if (value.charAt(result.endIndex) === ':')
                            {
                                result.endIndex++;
                                read2 = self._readOneR1C1Element(value, baseRow, baseColumn, result.endIndex);
                                result.endIndex = read2.endIndex;
                                if (!read2.success || !read2.isRow)
                                {
                                    return result
                                }
                                result.endRow = read2.elementIndex;
                                result.endRowRelative = read2.isRelative;
                                result.success = true;
                                return result
                            }
                        }
                        else
                        {
                            result.startColumn = read.elementIndex;
                            result.startColumnRelative = read.isRelative;
                            if (result.endIndex >= length)
                            {
                                result.success = true;
                                return result
                            }
                            if (value.charAt(result.endIndex) === ':')
                            {
                                result.endIndex++;
                                read2 = self._readOneR1C1Element(value, baseRow, baseColumn, result.endIndex);
                                result.endIndex = read2.endIndex;
                                if (!read2.success || read2.isRow)
                                {
                                    return result
                                }
                                result.endColumn = read2.elementIndex;
                                result.endColumnRelative = read2.isRelative;
                                result.success = true;
                                return result
                            }
                            else
                            {
                                return result
                            }
                        }
                        if (value.charAt(result.endIndex) === 'C' || value.charAt(result.endIndex) === 'c')
                        {
                            read2 = self._readOneR1C1Element(value, baseRow, baseColumn, result.endIndex);
                            result.endIndex = read2.endIndex;
                            if (!read2.success || read2.isRow)
                            {
                                return result
                            }
                            result.startColumn = read2.elementIndex;
                            result.startColumnRelative = read2.isRelative;
                            var cellEndIndex = result.endIndex;
                            if (result.endIndex < length - 1 && value.charAt(result.endIndex) === ':')
                            {
                                if (value.charAt(result.endIndex + 1) === "'")
                                {
                                    result.success = true;
                                    return result
                                }
                                var nextSheetIndex = value.indexOf('!', result.endIndex + 1);
                                var nextRangeIndex = value.indexOf(':', result.endIndex + 1);
                                if (nextSheetIndex !== -1 && (nextRangeIndex === -1 || nextRangeIndex > nextSheetIndex))
                                {
                                    result.success = true;
                                    return result
                                }
                                result.endIndex++;
                                var read3 = self._readOneR1C1Element(value, baseRow, baseColumn, result.endIndex);
                                if (!read3.success || !read3.isRow)
                                {
                                    result.endIndex = cellEndIndex;
                                    result.success = true;
                                    return result
                                }
                                else
                                {
                                    result.endIndex = read3.endIndex
                                }
                                result.endRow = read3.elementIndex;
                                result.endRowRelative = read3.isRelative;
                                var read4 = self._readOneR1C1Element(value, baseRow, baseColumn, result.endIndex);
                                if (!read4.success || read4.isRow)
                                {
                                    result.endIndex = cellEndIndex;
                                    result.success = true;
                                    return result
                                }
                                else
                                {
                                    result.endIndex = read4.endIndex
                                }
                                result.endColumn = read4.elementIndex;
                                result.endColumnRelative = read4.isRelative;
                                result.success = true;
                                return result
                            }
                            else
                            {
                                result.success = true;
                                return result
                            }
                        }
                        else
                        {
                            return result
                        }
                    };
                    Parser.prototype._readOneA1Element = function(value, startIndex)
                    {
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var result = {
                                endIndex: startIndex, elementIndex: bandIndex, isRow: true, isRelative: true, success: false
                            };
                        var length = value.length;
                        if (startIndex >= length)
                        {
                            return result
                        }
                        if (value.charAt(startIndex) === '$')
                        {
                            result.isRelative = false;
                            startIndex++
                        }
                        if (startIndex >= length)
                        {
                            return result
                        }
                        var index = startIndex,
                            intValue;
                        var currentChar = value.charAt(index);
                        if (isNumber(currentChar) && currentChar !== '0')
                        {
                            result.isRow = true;
                            while (index < length && isNumber(currentChar))
                            {
                                index++;
                                if (index < length)
                                {
                                    currentChar = value.charAt(index)
                                }
                            }
                            intValue = parseInt(value.substr(startIndex, index - startIndex), 10);
                            if (intValue >= 1 && intValue <= Parser.maxRowCount)
                            {
                                result.elementIndex = intValue - 1;
                                result.endIndex = index;
                                result.success = true;
                                return result
                            }
                        }
                        else if (isLetter(currentChar))
                        {
                            result.isRow = false;
                            while (index < length && isLetter(currentChar))
                            {
                                index++;
                                if (index < length)
                                {
                                    currentChar = value.charAt(index)
                                }
                            }
                            var s = value.substr(startIndex, index - startIndex);
                            if (s.length > 3)
                            {
                                return result
                            }
                            s = s.toUpperCase();
                            intValue = 0;
                            for (var i = s.length - 1; i >= 0; i--)
                            {
                                intValue += (s.charCodeAt(i) - 65 + 1) * LetterPows[s.length - i - 1]
                            }
                            if (intValue <= Parser.maxColumnCount)
                            {
                                result.elementIndex = intValue - 1;
                                result.endIndex = index;
                                result.success = true;
                                return result
                            }
                        }
                        return result
                    };
                    Parser.prototype._readOneR1C1Element = function(value, baseRow, baseColumn, startIndex)
                    {
                        var bandIndex = Parser.BAND_INDEX_CONST;
                        var result = {
                                endIndex: startIndex, elementIndex: bandIndex, isRow: true, isRelative: false, success: false
                            };
                        var length = value.length;
                        if (startIndex >= length)
                        {
                            return result
                        }
                        var index = startIndex;
                        var currentChar = value.charAt(index);
                        var baseIndex;
                        if (currentChar === 'R' || currentChar === 'r')
                        {
                            result.isRow = true;
                            baseIndex = baseRow
                        }
                        else if (currentChar === 'C' || currentChar === 'c')
                        {
                            result.isRow = false;
                            baseIndex = baseColumn
                        }
                        else
                        {
                            return result
                        }
                        startIndex++;
                        index++;
                        if (startIndex >= length)
                        {
                            result.endIndex = startIndex;
                            result.elementIndex = baseIndex;
                            result.isRelative = true;
                            result.success = true;
                            return result
                        }
                        currentChar = value.charAt(index);
                        if (currentChar === '[')
                        {
                            startIndex++;
                            index++;
                            result.isRelative = true
                        }
                        if (startIndex >= length)
                        {
                            return result
                        }
                        var isNegative = false;
                        currentChar = value.charAt(index);
                        if (result.isRelative && currentChar === '-')
                        {
                            startIndex++;
                            index++;
                            isNegative = true
                        }
                        if (startIndex >= length)
                        {
                            return result
                        }
                        currentChar = value.charAt(index);
                        if (isNumber(currentChar))
                        {
                            while (index < length && isNumber(currentChar))
                            {
                                index++;
                                if (index < length)
                                {
                                    currentChar = value.charAt(index)
                                }
                            }
                            var intValue = parseInt(value.substr(startIndex, index - startIndex), 10);
                            if (result.isRelative)
                            {
                                if (index >= length || value.charAt(index) !== ']')
                                {
                                    return result
                                }
                                index++
                            }
                            if (intValue < (result.isRow ? Parser.maxRowCount : Parser.maxColumnCount))
                            {
                                if (result.isRelative)
                                {
                                    intValue = isNegative ? -intValue : intValue;
                                    result.elementIndex = intValue + baseIndex
                                }
                                else
                                {
                                    result.elementIndex = intValue - 1
                                }
                                result.endIndex = index;
                                result.success = true;
                                return result
                            }
                        }
                        else if (result.isRelative)
                        {
                            return result
                        }
                        else
                        {
                            result.endIndex = startIndex;
                            result.elementIndex = baseIndex;
                            result.isRelative = true;
                            result.success = true;
                            return result
                        }
                    };
                    Parser.prototype._validateWorkbook = function(name, containsSpecial)
                    {
                        if (name === keyword_undefined || name === keyword_null || name === '')
                        {
                            return true
                        }
                        var currentChar;
                        for (var i = 0; i < name.length; i++)
                        {
                            currentChar = name[i];
                            if (containsSpecial)
                            {
                                if (currentChar === '*' || currentChar === ':' || currentChar === '[' || currentChar === ']' || currentChar === '?')
                                {
                                    return false
                                }
                                if (currentChar === "'")
                                {
                                    if (i === 0 || i >= name.length - 1 || name.charAt(i + 1) !== "'")
                                    {
                                        return false
                                    }
                                }
                            }
                            else if (currentChar === "'" || currentChar === '[' || currentChar === ']' || currentChar === '?' || currentChar === '%' || Parser._operatorInfix.indexOf(currentChar) !== -1)
                            {
                                return false
                            }
                        }
                        return true
                    };
                    Parser.prototype._validateSheetName = function(name, isR1C1, containsSpecial)
                    {
                        if (name === keyword_undefined || name === keyword_null || name === '')
                        {
                            return true
                        }
                        if (!containsSpecial && isDigit(name.charAt(0)))
                        {
                            return false
                        }
                        var isStartWithCellRef = this._isStartWithCellReference(name, isR1C1);
                        if (!containsSpecial && isStartWithCellRef.success && isStartWithCellRef.endIndex === name.length)
                        {
                            return false
                        }
                        var currentChar;
                        for (var i = 0; i < name.length; i++)
                        {
                            currentChar = name.charAt(i);
                            if (containsSpecial)
                            {
                                if (currentChar === '*' || currentChar === ':' || currentChar === '[' || currentChar === ']' || currentChar === '?' || currentChar === '\\' || currentChar === '/')
                                {
                                    return false
                                }
                            }
                            else if (currentChar === "'" || currentChar === '[' || currentChar === ']' || currentChar === '?' || currentChar === '\\' || currentChar === '%' || currentChar === '"' || Parser._operatorInfix.indexOf(currentChar) !== -1)
                            {
                                return false
                            }
                        }
                        return true
                    };
                    Parser.prototype._createStructExpression = function(context, value, startIndex)
                    {
                        if (value.charAt(value.length - 1) === ']')
                        {
                            try
                            {
                                return new Expressions.StructReferenceExpression(value, context)
                            }
                            catch(ex)
                            {
                                throw Sheets.SR.Exp_FormulaInvalid + Sheets.SR.SingleQuote + "{" + Sheets.SR.AtIndexOn + startIndex + Sheets.SR.FullStop;
                            }
                        }
                        else
                        {
                            var table = context.getTableByName(value);
                            if (table)
                            {
                                return Expressions.StructReferenceExpression.create(table)
                            }
                        }
                        return keyword_null
                    };
                    Parser.prototype._validateName = function(name)
                    {
                        if (name === keyword_undefined || name === keyword_null || name === '')
                        {
                            return false
                        }
                        var nameLength = name.length;
                        if (nameLength === 1 && (name === 'R' || name === 'r' || name === 'C' || name === 'c'))
                        {
                            return false
                        }
                        var currentChar = name.charAt(0);
                        if (!(currentChar === '_' || currentChar === '\\' || isLetter(currentChar) || isSymbol(currentChar)))
                        {
                            return false
                        }
                        for (var i = 1; i < nameLength; i++)
                        {
                            currentChar = name.charAt(i);
                            if (!(currentChar === '_' || currentChar === '\\' || currentChar === '?' || currentChar === '.' || isLetterOrDigit(currentChar) || isSymbol(currentChar)))
                            {
                                return false
                            }
                        }
                        return true
                    };
                    Parser.prototype.parseReferenceExpressionInfos = function(formula, source, baseRow, baseCol)
                    {
                        var self = this;
                        var tokens = [];
                        try
                        {
                            tokens = self._parseToToken(formula, false)
                        }
                        catch(e) {}
                        tokens = self._fillBlankToTokens(tokens, formula);
                        return self._getExpressToken(tokens, formula, source, baseRow, baseCol)
                    };
                    Parser.prototype._adjustArrayTokens = function(tokens)
                    {
                        var arrayRowIndex = 0;
                        for (var i = 0; i < tokens.length; i++)
                        {
                            var token = tokens[i];
                            if (token.type === 1 && token.subType === 1 && token.value === const_array)
                            {
                                arrayRowIndex = 0
                            }
                            else if (token.type === 1 && token.subType === 1 && token.value === const_arrayRow)
                            {
                                if (arrayRowIndex === 0)
                                {
                                    tokens.splice(i, 1);
                                    i--
                                }
                                else
                                {}
                                arrayRowIndex++
                            }
                            else if (token.type === 1 && token.subType === 2 && token.value === "}")
                            {
                                arrayRowIndex--;
                                if (arrayRowIndex === 0)
                                {
                                    tokens.splice(i, 1);
                                    i--
                                }
                                else
                                {}
                            }
                        }
                        return tokens
                    };
                    Parser.prototype._fillBlankToTokens = function(refTokens, formula)
                    {
                        var offset = 0;
                        var blank;
                        refTokens.splice(0, 0, new FormulaToken('=', 1, 0, 0));
                        var tokenLen;
                        for (var k = refTokens.length - 1; k > 0; k--)
                        {
                            if (refTokens[k].index === refTokens[k - 1].index && refTokens[k].value === refTokens[k - 1].value)
                            {
                                refTokens = Sheets.ArrayHelper.removeByIndex(refTokens, k)
                            }
                        }
                        for (var i = 0; i < refTokens.length - 1; i++)
                        {
                            tokenLen = this._getTokenLength(refTokens[i]);
                            offset = refTokens[i + 1].index - refTokens[i].index - tokenLen;
                            if (offset > 0)
                            {
                                blank = {
                                    index: refTokens[i].index + tokenLen, value: formula.substring(refTokens[i].index + tokenLen, refTokens[i + 1].index), type: 7
                                };
                                refTokens.splice(i + 1, 0, blank)
                            }
                        }
                        tokenLen = this._getTokenLength(refTokens[i]);
                        if (refTokens.length > 0 && formula.length > refTokens[i].index + tokenLen)
                        {
                            blank = {
                                index: refTokens[i].index + refTokens[i].value.length, value: formula.substring(refTokens[i].index + refTokens[i].value.length, formula.length), type: 7
                            };
                            refTokens.splice(i + 1, 0, blank)
                        }
                        for (var j = 0; j < refTokens.length; j++)
                        {
                            if (refTokens[j].value.trim() === '(')
                            {
                                refTokens[j].type = 1;
                                refTokens[j].subType = 1
                            }
                            else if (refTokens[j].value.trim() === ')')
                            {
                                refTokens[j].type = 1;
                                refTokens[j].subType = 2
                            }
                            else if (refTokens[j].value.trim() === '{')
                            {
                                refTokens[j].type = 1;
                                refTokens[j].subType = 1
                            }
                            else if (refTokens[j].value.trim() === '}')
                            {
                                refTokens[j].type = 1;
                                refTokens[j].subType = 2
                            }
                        }
                        return refTokens
                    };
                    Parser.prototype._getTokenLength = function(token)
                    {
                        if ((token.type === 1) && ((token.value === 'ARRAY') || (token.value === 'ARRAYROW')))
                        {
                            if (token.value === 'ARRAY')
                            {
                                return 1
                            }
                            if (token.value === 'ARRAYROW')
                            {
                                return 1
                            }
                        }
                        return token.value.length
                    };
                    Parser.prototype._getExpressToken = function(refTokens, formula, source, baseRow, baseCol)
                    {
                        var self = this;
                        var context;
                        var evaluateContext = keyword_undefined;
                        var service = source.getCalcService();
                        if (service)
                        {
                            context = new Calc.SheetParserContext(source, service.useR1C1, baseRow, baseCol);
                            evaluateContext = new EvaluateContext(source._getSheetSource(), false, baseRow, baseCol)
                        }
                        else
                        {
                            context = new ParserContext(keyword_null, false, 0, 0)
                        }
                        var newTokens = [];
                        for (var refIndex = 0; refIndex < refTokens.length; refIndex++)
                        {
                            try
                            {
                                var token = refTokens[refIndex];
                                if (token.value === '[' || Sheets.StringUtil.startsWith(token.value, '#'))
                                {
                                    newTokens.push({
                                        text: token.value, type: token.type, subType: token.subType, canDrag: false, ranges: token.ranges, value: token.value
                                    });
                                    continue
                                }
                                var exprInfos = [];
                                self._buildExpressionInfo(context, token, exprInfos);
                                if (exprInfos.length > 0)
                                {
                                    for (var i = 0; i < exprInfos.length; i++)
                                    {
                                        var info = exprInfos[i];
                                        if (info instanceof FormulaToken)
                                        {
                                            newTokens.push({
                                                text: info.value, type: info.type, subType: info.subType, canDrag: canDrage, ranges: [], value: info.value
                                            })
                                        }
                                        else if (info instanceof ExpressionInfo)
                                        {
                                            var exprInfo = info;
                                            var exprString = formula.substring(exprInfo.startIndex, exprInfo.endIndex + 1);
                                            var ranges = [];
                                            var canDrage = true;
                                            if (!exprInfo.expression)
                                            {
                                                ranges = null
                                            }
                                            else if (exprInfo.expression.t === 8)
                                            {
                                                canDrage = false;
                                                if (evaluateContext)
                                                {
                                                    var nameRef = evaluateContext.getName(exprInfo.expression.name);
                                                    self._getRanges(nameRef, ranges, evaluateContext, baseRow, baseCol)
                                                }
                                            }
                                            else if (exprInfo.expression.t === 17)
                                            {
                                                canDrage = false;
                                                var cellRange = exprInfo.expression.getRange(baseRow, baseCol);
                                                if (cellRange)
                                                {
                                                    ranges.push(self._cellRange2Range(cellRange))
                                                }
                                            }
                                            else if (exprInfo.expression instanceof Expressions.ReferenceExpression)
                                            {
                                                if (exprInfo.expression instanceof Expressions.ExternalReferenceExpression)
                                                {
                                                    if (source._getSheetSource && exprInfo.expression.source === source._getSheetSource())
                                                    {
                                                        ranges.push(self._cellRange2Range(exprInfo.expression.getRange(baseRow, baseCol)))
                                                    }
                                                    else
                                                    {
                                                        ranges = null
                                                    }
                                                }
                                                else
                                                {
                                                    ranges.push(self._cellRange2Range(exprInfo.expression.getRange(baseRow, baseCol)))
                                                }
                                            }
                                            else
                                            {
                                                ranges = null
                                            }
                                            if (ranges && ranges.length > 0)
                                            {
                                                newTokens.push({
                                                    text: exprString, type: 0, subType: 7, canDrag: canDrage, ranges: ranges, value: exprString
                                                })
                                            }
                                            else
                                            {
                                                newTokens.push({
                                                    text: exprString, type: token.type, subType: token.subType, canDrag: canDrage, ranges: ranges, value: exprString
                                                })
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    newTokens.push({
                                        text: token.value, type: token.type, subType: token.subType, canDrag: false, ranges: token.ranges, value: token.value
                                    })
                                }
                            }
                            catch(e)
                            {
                                newTokens.push({
                                    text: token.value, type: token.type, subType: token.subType, canDrag: false, ranges: token.ranges, value: token.value
                                })
                            }
                        }
                        return newTokens
                    };
                    Parser.prototype._cellRange2Range = function(cellRange)
                    {
                        return new Sheets.Range(cellRange.row, cellRange.column, cellRange.rowCount, cellRange.columnCount)
                    };
                    Parser.prototype._getRanges = function(expr, ranges, evaluateContext, baseRow, baseCol)
                    {
                        if (!expr)
                        {
                            return
                        }
                        while (expr.t === 14)
                        {
                            expr = expr.argument
                        }
                        var self = this;
                        if (expr.t === 24)
                        {
                            var expendExpr = expr;
                            expr = expendExpr.expr
                        }
                        if (expr instanceof Expressions.ConstantExpression)
                        {}
                        else if (expr instanceof Expressions.ExternalReferenceExpression)
                        {
                            if (evaluateContext.source && expr.source === evaluateContext.source)
                            {
                                var cellRange = expr.getRange(baseRow, baseCol);
                                ranges.push(self._cellRange2Range(cellRange))
                            }
                        }
                        else if (expr instanceof Expressions.ReferenceExpression)
                        {
                            var cellRange = expr.getRange(baseRow, baseCol);
                            ranges.push(self._cellRange2Range(cellRange))
                        }
                        else if (expr.t === 9)
                        {
                            var svc,
                                nameContext = keyword_null;
                            if ((svc = expr.source.getCalcService()))
                            {
                                nameContext = new EvaluateContext(expr.source, false, baseRow, baseCol)
                            }
                            var nameRef = nameContext.getName(expr.name);
                            self._getRanges(nameRef, ranges, nameContext, baseRow, baseCol)
                        }
                        else if (expr.t === 8)
                        {
                            var nameRef1 = evaluateContext.getName(expr.name);
                            self._getRanges(nameRef1, ranges, evaluateContext, baseRow, baseCol)
                        }
                        else if (expr.t === 11)
                        {
                            self._getRanges(expr.operand, ranges, evaluateContext, baseRow, baseCol)
                        }
                        else if (expr.t === 10)
                        {
                            self._getRanges(expr.left, ranges, evaluateContext, baseRow, baseCol);
                            self._getRanges(expr.right, ranges, evaluateContext, baseRow, baseCol)
                        }
                        else if (expr.t === 7)
                        {
                            var functionExpr = expr;
                            for (var i = 0; i < functionExpr.argCount(); i++)
                            {
                                self._getRanges(functionExpr.getArg(i), ranges, evaluateContext, baseRow, baseCol)
                            }
                        }
                    };
                    Parser.prototype._buildExpressionInfo = function(context, token, list)
                    {
                        if (typeof token === "undefined" || typeof token === "function" || token === null)
                        {
                            return
                        }
                        if (token.type !== 0)
                        {
                            return
                        }
                        var self = this;
                        var value = token.value;
                        var endIndex;
                        var expression;
                        var expressionResult = self._buildCellReferenceOrNameExpressions2(context, value, token.index);
                        if (expressionResult == null)
                        {
                            return
                        }
                        endIndex = expressionResult.endIndex;
                        expression = expressionResult.expression;
                        var info = new ExpressionInfo(token.index, token.index + endIndex - 1, expression);
                        list.push(info);
                        if (endIndex <= 0 || endIndex >= value.length)
                        {
                            return
                        }
                        if (value[endIndex] != ':')
                        {
                            return
                        }
                        list.push(new FormulaToken(':', 5, endIndex + token.index));
                        endIndex++;
                        while (endIndex > 0 && endIndex < value.length)
                        {
                            var startIndex = endIndex + token.index;
                            var subEndIndex;
                            expressionResult = self._buildCellReferenceOrNameExpressions2(context, value.substring(endIndex), token.index);
                            if (expressionResult == null)
                            {
                                return
                            }
                            subEndIndex = expressionResult.endIndex;
                            expression = expressionResult.expression;
                            info = new ExpressionInfo(startIndex, startIndex + subEndIndex - 1, expression);
                            list.push(info);
                            endIndex += subEndIndex;
                            if (endIndex >= value.length || value[endIndex] !== ':')
                            {
                                return
                            }
                            list.push(new FormulaToken(':', 5, endIndex + token.index));
                            endIndex++
                        }
                    };
                    Parser.BAND_INDEX_CONST = -2147483648;
                    Parser.maxRowCount = 1048576;
                    Parser.maxColumnCount = 16384;
                    Parser._isLetter = isLetter;
                    Parser._isLetterOrDigit = isLetterOrDigit;
                    Parser.listSeparator = ',';
                    Parser.numberDecimalSeparator = '.';
                    Parser.arrayGroupSeparator = ';';
                    Parser._arrayArgumentSepatator = Parser.listSeparator;
                    Parser._operatorInfix = '\\+-*/^&=><: ' + Parser.listSeparator;
                    Parser.unparseWithoutCulture = false;
                    return Parser
                })();
            Calc.Parser = Parser;
            var ExpressionInfo = (function()
                {
                    function ExpressionInfo(startIndex, endIndex, expr)
                    {
                        var self = this;
                        this.startIndex = startIndex;
                        this.endIndex = endIndex;
                        this.expression = expr
                    }
                    return ExpressionInfo
                })();
            var EvaluateContext = (function()
                {
                    function EvaluateContext(source, arrayFormula, baseRow, baseColumn, rowCount, columnCount, activeRow, activeColumn)
                    {
                        this.asyncId = 0;
                        this.asyncCount = 0;
                        this._expandArrayToMultiCallCount = 0;
                        var self = this,
                            length = arguments.length;
                        self.source = source;
                        self.arrayFormulaMode = length >= 2 ? arrayFormula : false;
                        self.row = length >= 3 ? baseRow : 0;
                        self.column = length >= 4 ? baseColumn : 0;
                        self.rowCount = length >= 5 ? rowCount : 1;
                        self.columnCount = length >= 6 ? columnCount : 1;
                        self.activeRow = length >= 7 ? activeRow : self.row;
                        self.activeColumn = length >= 8 ? activeColumn : self.column;
                        self.rowOffset = length < 7 ? self.row : self.activeRow - self.row;
                        self.columnOffset = length < 8 ? self.column : self.activeColumn - self.column
                    }
                    EvaluateContext.prototype.getValue = function(source, row, column)
                    {
                        if (!source)
                        {
                            return CalcErrorsReference
                        }
                        return source.getValue(row, column)
                    };
                    EvaluateContext.prototype.getReference = function(source, row, column, rowCount, columnCount)
                    {
                        if (!source)
                        {
                            return CalcErrorsReference
                        }
                        return source.getReference(row, column, rowCount, columnCount)
                    };
                    EvaluateContext.prototype.getSheetRangeReference = function(startSource, endSource, row, column, rowCount, columnCount)
                    {
                        if (!startSource || !endSource)
                        {
                            return CalcErrorsReference
                        }
                        return startSource.getSheetRangeReference(endSource, row, column, rowCount, columnCount)
                    };
                    EvaluateContext.prototype.getFunction = function(name)
                    {
                        var self = this;
                        return self.source ? self.source.getCustomFunction(name) : keyword_null
                    };
                    EvaluateContext.prototype.getName = function(name)
                    {
                        var self = this;
                        var nameInfo = self.source ? self.source.getCustomName(name) : keyword_null;
                        return nameInfo
                    };
                    EvaluateContext.prototype._isExpandArrayToMultiCall = function()
                    {
                        return this._expandArrayToMultiCallCount > 0
                    };
                    EvaluateContext.prototype._beginExpandArrayToMultiCall = function()
                    {
                        this._expandArrayToMultiCallCount++
                    };
                    EvaluateContext.prototype._endExpandArrayToMultiCall = function()
                    {
                        this._expandArrayToMultiCallCount--
                    };
                    EvaluateContext.prototype._offset = function(row, column)
                    {
                        var self = this;
                        return new EvaluateContext(self.source, self.arrayFormulaMode, self.row + row, self.column + column, self.rowCount, self.columnCount, self.rowOffset, self.columnOffset)
                    };
                    EvaluateContext.prototype.SetAsyncResult = function(ctx, value)
                    {
                        this.source.service._evaluator.SetAsyncResult(ctx, value);
                        this.source.refresh()
                    };
                    return EvaluateContext
                })();
            Calc.EvaluateContext = EvaluateContext;
            var AsyncEvaluateContext = (function()
                {
                    function AsyncEvaluateContext(context)
                    {
                        this.id = context.asyncId++;
                        this.ctx = context;
                        this.row = context.activeRow;
                        this.col = context.activeColumn
                    }
                    AsyncEvaluateContext.prototype.SetAsyncResult = function(value)
                    {
                        this.ctx.SetAsyncResult(this, value)
                    };
                    return AsyncEvaluateContext
                })();
            Calc.AsyncEvaluateContext = AsyncEvaluateContext;
            var defaultParser = new Parser;
            var Evaluator = (function()
                {
                    function Evaluator()
                    {
                        this._aync = {}
                    }
                    Evaluator.prototype.evaluateFormula = function(formula, parserContext, evaluatorContext)
                    {
                        return this.evaluateExpression(defaultParser.parse(formula, parserContext), evaluatorContext)
                    };
                    Evaluator.prototype.evaluateExpression = function(expression, evaluatorContext, convertNullToZero)
                    {
                        var result = this._evaluate(expression, evaluatorContext, false, false);
                        if (convertNullToZero)
                        {
                            return (result === keyword_undefined || result === keyword_null) ? 0 : result
                        }
                        return result
                    };
                    Evaluator.prototype._evaluate = function(expr, context, acceptsArray, acceptsReference)
                    {
                        if (!expr)
                        {
                            throw Sheets.SR.Exp_ExprIsNull;
                        }
                        while (expr.t === 14)
                        {
                            expr = expr.argument
                        }
                        var self = this;
                        var result;
                        var needExpendIndexs = keyword_null;
                        if (expr.t === 24)
                        {
                            var expendExpr = expr;
                            expr = expendExpr.expr;
                            needExpendIndexs = expendExpr.needExpendIndexs
                        }
                        if (expr instanceof Expressions.ConstantExpression)
                        {
                            result = self._evaluateConst(expr, context, acceptsArray)
                        }
                        else if (expr instanceof Expressions.ReferenceExpression)
                        {
                            result = self._evaluateReference(expr, context, acceptsReference)
                        }
                        else if (expr.t === 9)
                        {
                            var svc,
                                nameContext = keyword_null;
                            if ((svc = expr.source.getCalcService()))
                            {
                                nameContext = new EvaluateContext(expr.source, context.arrayFormulaMode, context.row, context.column)
                            }
                            if (!nameContext)
                            {
                                result = CalcErrorsName
                            }
                            result = self._evaluateName(expr.name, nameContext, context, acceptsArray, acceptsReference)
                        }
                        else if (expr.t === 8)
                        {
                            result = self._evaluateName(expr.name, context, context, acceptsArray, acceptsReference)
                        }
                        else if (expr.t === 11)
                        {
                            result = self._evaluateUnaryOperation(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                        }
                        else if (expr.t === 10)
                        {
                            result = self._evaluateBinaryOperation(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                        }
                        else if (expr.t === 7)
                        {
                            result = self._evaluateFunction(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                        }
                        return result
                    };
                    Evaluator.prototype._evaluateConst = function(expr, context, acceptsArray)
                    {
                        var value = expr.value;
                        if (Convert.arr(value))
                        {
                            if (acceptsArray || (context && (context.arrayFormulaMode || context._isExpandArrayToMultiCall())))
                            {
                                return value
                            }
                            return _Helper.getArrayValue(value, 0, 0)
                        }
                        return value
                    };
                    Evaluator.prototype._evaluateReference = function(expr, context, acceptsReference)
                    {
                        if (!context)
                        {
                            return CalcErrorsValue
                        }
                        var source = context.source;
                        if (expr instanceof Expressions.ExternalReferenceExpression)
                        {
                            source = expr.source
                        }
                        else if (expr.t === 17)
                        {
                            source = expr.source()
                        }
                        var baseRow = context.row,
                            baseColumn = context.column;
                        var pos = expr.getRange(baseRow, baseColumn);
                        if (!pos)
                        {
                            return CalcErrorsReference
                        }
                        if (acceptsReference || context.arrayFormulaMode)
                        {
                            if (expr.t === 16)
                            {
                                return context.getSheetRangeReference(expr.startSource, expr.endSource, pos.row, pos.column, pos.rowCount, pos.columnCount)
                            }
                            return context.getReference(source, pos.row, pos.column, pos.rowCount, pos.columnCount)
                        }
                        var row = pos.row,
                            column = pos.column;
                        if (pos.rowCount > 1 || pos.columnCount > 1)
                        {
                            var rowInRange = context.row >= pos.row && context.row < pos.row + pos.rowCount;
                            var colInRange = context.column >= pos.column && context.column < pos.column + pos.columnCount;
                            if (!rowInRange && !colInRange)
                            {
                                return CalcErrorsValue
                            }
                            else if (rowInRange && !colInRange && pos.columnCount === 1)
                            {
                                row = context.row
                            }
                            else if (!rowInRange && colInRange && pos.rowCount === 1)
                            {
                                column = context.column
                            }
                            else if (pos.rowCount === 1 || pos.columnCount === 1)
                            {
                                row = context.row;
                                column = context.column
                            }
                            else
                            {
                                return CalcErrorsValue
                            }
                        }
                        else if (pos.row === -1 && pos.rowCount === -1)
                        {
                            if (pos.columnCount !== 1)
                            {
                                return CalcErrorsValue
                            }
                            row = context.row
                        }
                        else if (pos.column === -1 && pos.columnCount === -1)
                        {
                            if (pos.rowCount !== 1)
                            {
                                return CalcErrorsValue
                            }
                            column = context.column
                        }
                        return context.getValue(source, row, column)
                    };
                    Evaluator.prototype._evaluateName = function(name, nameContext, evalContext, acceptsArray, acceptsReference)
                    {
                        if (!nameContext || !evalContext)
                        {
                            return CalcErrorsName
                        }
                        var sub = nameContext.getName(name);
                        if (!sub)
                        {
                            return CalcErrorsName
                        }
                        return this._evaluate(sub, evalContext, acceptsArray, acceptsReference)
                    };
                    Evaluator.prototype._evaluateOperationArg = function(argExpr, context, acceptsArray, acceptsReference)
                    {
                        var arg = this._evaluate(argExpr, context, acceptsArray, acceptsReference);
                        if (Convert.err(arg))
                        {
                            return arg
                        }
                        if (arg === Calc.missingArgument)
                        {
                            return CalcErrorsNotAvailable
                        }
                        return arg
                    };
                    Evaluator.prototype._evaluateUnaryOperation = function(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                    {
                        var acceptsReferences = false;
                        if (needExpendIndexs != keyword_null && needExpendIndexs.length > 0)
                        {
                            acceptsArray = true;
                            acceptsReferences = true
                        }
                        var arg = this._evaluate(expr.operand, context, acceptsArray, acceptsReferences);
                        if (Convert.err(arg))
                        {
                            return arg
                        }
                        if (arg === Calc.missingArgument)
                        {
                            return CalcErrorsNotAvailable
                        }
                        return this._evaluateWithArgs(expr, function(args1)
                            {
                                return expr.operator.evaluate(args1[0], context)
                            }, context, needExpendIndexs, [arg], acceptsArray, acceptsReference)
                    };
                    Evaluator.prototype._evaluateBinaryOperation = function(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                    {
                        var acceptsArrays = [acceptsArray, acceptsArray];
                        var acceptsReferences = [expr.operator.acceptsReference, expr.operator.acceptsReference];
                        if (needExpendIndexs != keyword_null && needExpendIndexs.length > 0)
                        {
                            for (var i = 0; i < needExpendIndexs.length; i++)
                            {
                                acceptsArrays[needExpendIndexs[i]] = true;
                                acceptsReferences[needExpendIndexs[i]] = true
                            }
                            ;
                        }
                        var sub = [expr.left, expr.right];
                        var args = [];
                        for (var i = 0; i < 2; i++)
                        {
                            var arg = this._evaluate(sub[i], context, acceptsArrays[i], acceptsReferences[i]);
                            if (Convert.err(arg))
                                return arg;
                            if (arg === Calc.missingArgument)
                                return CalcErrorsNotAvailable;
                            args[i] = arg
                        }
                        return this._evaluateWithArgs(expr, function(args1)
                            {
                                return expr.operator.evaluate(args1[0], args1[1], context)
                            }, context, needExpendIndexs, args, acceptsArray, acceptsReference)
                    };
                    Evaluator.prototype.startCache = function()
                    {
                        this._functionResultCaches = {}
                    };
                    Evaluator.prototype.endCache = function()
                    {
                        this._functionResultCaches = keyword_null
                    };
                    Evaluator.prototype._evaluateFunction = function(expr, context, acceptsArray, acceptsReference, needExpendIndexs)
                    {
                        if (!expr || !expr.fn || typeof expr.fn === "string")
                        {
                            return CalcErrorsName
                        }
                        var argCount = expr.argCount(),
                            self = this,
                            asyncCount = context.asyncCount;
                        var fn = expr.fn;
                        var args;
                        var getReferenceValues = keyword_null;
                        if (argCount === 0)
                        {
                            args = []
                        }
                        else
                        {
                            args = [];
                            var acceptsArrays = [];
                            var acceptsReferences = [];
                            for (var i = 0; i < argCount; i++)
                            {
                                acceptsArrays[i] = fn.acceptsArray(i);
                                acceptsReferences[i] = fn.acceptsReference(i)
                            }
                            if (needExpendIndexs && needExpendIndexs.length > 0)
                            {
                                getReferenceValues = [];
                                for (var i = 0; i < argCount; i++)
                                {
                                    getReferenceValues[i] = true
                                }
                                for (var i = 0; i < needExpendIndexs.length; i++)
                                {
                                    var argIndex = needExpendIndexs[i];
                                    acceptsArrays[argIndex] = true;
                                    acceptsReferences[argIndex] = true;
                                    getReferenceValues[argIndex] = !(fn.acceptsReference(argIndex) && !fn.acceptsArray(argIndex))
                                }
                            }
                            if (fn.isBranch() && (context.arrayFormulaMode || context._isExpandArrayToMultiCall()))
                            {
                                acceptsArrays[fn.findTestArgument()] = true;
                                acceptsReferences[fn.findTestArgument()] = true
                            }
                            var testArgValue;
                            var testArg = -1;
                            var branchArgument = -1;
                            if (fn.isBranch())
                            {
                                var testArg = fn.findTestArgument();
                                if (fn.acceptsArray(testArg))
                                {
                                    context._beginExpandArrayToMultiCall()
                                }
                                testArgValue = self._evaluate(expr.getArg(testArg), context, acceptsArrays[testArg], acceptsReferences[testArg]);
                                if (fn.acceptsArray(testArg))
                                {
                                    context._endExpandArrayToMultiCall()
                                }
                                if (!Convert.ref(testArgValue) && !Convert.arr(testArgValue))
                                {
                                    branchArgument = fn.findBranchArgument(testArgValue)
                                }
                            }
                            for (var i = 0; i < argCount; i++)
                            {
                                if (testArg === i)
                                {
                                    var arg = testArgValue
                                }
                                else if (branchArgument >= 0 && i !== branchArgument)
                                {
                                    args[i] = null;
                                    continue
                                }
                                else
                                {
                                    if (fn.acceptsArray(i))
                                    {
                                        context._beginExpandArrayToMultiCall()
                                    }
                                    var arg = self._evaluate(expr.getArg(i), context, acceptsArrays[i], acceptsReferences[i]);
                                    if (fn.acceptsArray(i))
                                    {
                                        context._endExpandArrayToMultiCall()
                                    }
                                }
                                if (!fn.acceptsArray(i) && (Convert.arr(arg)) || (!fn.acceptsReference(i)) && (Convert.ref(arg)))
                                {
                                    var array = (Convert.arr(arg)) ? arg : keyword_null;
                                    var reference = (Convert.ref(arg)) ? arg : keyword_null;
                                    if (array != keyword_null && array.getRowCount() == 1 && array.getColumnCount() == 1)
                                    {
                                        arg = array.getValue(0, 0)
                                    }
                                    else if (reference != keyword_null && reference.getRowCount(0) == 1 && reference.getColumnCount(0) == 1)
                                    {
                                        arg = reference.getValue(0, 0, 0)
                                    }
                                    else
                                    {
                                        var list = [];
                                        var contains = false;
                                        if (needExpendIndexs != keyword_null)
                                        {
                                            for (var j = 0; j < needExpendIndexs.length; j++)
                                            {
                                                list.push(needExpendIndexs[j]);
                                                if (needExpendIndexs[j] == i)
                                                {
                                                    contains = true
                                                }
                                            }
                                        }
                                        if (!contains)
                                        {
                                            list.push(i);
                                            needExpendIndexs = list
                                        }
                                    }
                                }
                                if ((Convert.err(arg)) && !fn.acceptsError(i))
                                    return arg;
                                if (arg === Calc.missingArgument)
                                {
                                    if (!fn.acceptsMissingArgument(i))
                                    {
                                        arg = keyword_null
                                    }
                                }
                                args[i] = arg
                            }
                        }
                        return self._evaluateWithArgs(expr, function(args1)
                            {
                                if (fn.isContextSensitive())
                                {
                                    context.acceptsReference = acceptsReference || context._isExpandArrayToMultiCall();
                                    if (fn instanceof Functions.AsyncFunction)
                                    {
                                        var key = context.source.getName() + "_" + context.activeRow + "_" + context.activeColumn + "_" + context.asyncId;
                                        var result = self._aync[key];
                                        if (result !== keyword_undefined)
                                        {
                                            delete self._aync[key];
                                            return result
                                        }
                                        var aContext = new AsyncEvaluateContext(context);
                                        context.asyncCount++;
                                        if (context.asyncCount = asyncCount + 1)
                                        {
                                            result = fn.evaluateWithContext(args1, aContext);
                                            if (result === keyword_undefined)
                                            {
                                                result = fn.defaultValue()
                                            }
                                        }
                                        else
                                        {
                                            result = fn.defaultValue()
                                        }
                                        return result
                                    }
                                    return fn.evaluateWithContext(args1, context)
                                }
                                else
                                {
                                    var functionCaches = context.arrayFormulaMode ? self._functionResultCaches : keyword_null;
                                    if (functionCaches)
                                    {
                                        var cached = false;
                                        var functionInfos = functionCaches[fn.name + args1.length];
                                        if (functionInfos)
                                        {
                                            for (var i = 0; i < functionInfos.length; i++)
                                            {
                                                var functionInfo = functionInfos[i];
                                                cached = true;
                                                if (functionInfo.args.length === args1.length)
                                                {
                                                    for (var argIndex = 0; argIndex < args1.length; argIndex++)
                                                    {
                                                        var cacheArg = functionInfo.args[argIndex],
                                                            newArg = args1[argIndex];
                                                        if (cacheArg === newArg)
                                                        {
                                                            continue
                                                        }
                                                        if ((cacheArg instanceof Calc.SheetReference) && newArg instanceof Calc.SheetReference)
                                                        {
                                                            var rangeCount = cacheArg._rangeCount;
                                                            if (cacheArg._sheetSource !== newArg._sheetSource || rangeCount !== newArg._rangeCount)
                                                            {
                                                                cached = false;
                                                                break
                                                            }
                                                            for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++)
                                                            {
                                                                if (cacheArg.getRow(rangeIndex) !== newArg.getRow(rangeIndex) || cacheArg.getColumn(rangeIndex) !== newArg.getColumn(rangeIndex) || cacheArg.getRowCount(rangeIndex) !== newArg.getRowCount(rangeIndex) || cacheArg.getColumnCount(rangeIndex) !== newArg.getColumnCount(rangeIndex))
                                                                {
                                                                    cached = false;
                                                                    break
                                                                }
                                                            }
                                                        }
                                                        else
                                                        {
                                                            cached = false;
                                                            break
                                                        }
                                                    }
                                                }
                                                if (cached)
                                                {
                                                    functionInfo.flag++;
                                                    return functionInfo.value
                                                }
                                            }
                                        }
                                        else
                                        {
                                            functionInfos = functionCaches[fn.name + args1.length] = []
                                        }
                                    }
                                    var value = fn.evaluate(args1);
                                    if (functionCaches)
                                    {
                                        var length = functionInfos.length;
                                        if (length >= 100)
                                        {
                                            var tmp = [];
                                            for (var i = 0; i < length; i++)
                                            {
                                                if (functionInfos[i].flag > 0)
                                                {
                                                    tmp.push(functionInfos[i])
                                                }
                                            }
                                            tmp.sort(function(a, b)
                                            {
                                                return b.flag - a.flag
                                            });
                                            length = Math.min(50, tmp.length);
                                            functionInfos = tmp.slice(0, length);
                                            functionCaches[fn.name + args1.length] = functionInfos
                                        }
                                        functionInfos.push({
                                            args: args1, value: value, flag: 0
                                        })
                                    }
                                    return value
                                }
                            }, context, needExpendIndexs, args, acceptsArray, acceptsReference, getReferenceValues)
                    };
                    Evaluator.prototype.SetAsyncResult = function(context, value)
                    {
                        var ctx = context.ctx;
                        var key = ctx.source.getName() + "_" + ctx.activeRow + "_" + ctx.activeColumn + "_" + context.id;
                        this._aync[key] = value;
                        ctx.source.service.recalculate(ctx.source, ctx.activeRow, ctx.activeColumn)
                    };
                    Evaluator.prototype._evaluateWithArgs = function(expr, evaluateDelegate, context, needExpendIndexs, args, acceptsArray, acceptsReference, getReferenceValues)
                    {
                        if (needExpendIndexs && needExpendIndexs.length > 0)
                        {
                            var expendedArgs = this._expandArgs(context, expr, args, needExpendIndexs, getReferenceValues);
                            if (expendedArgs == keyword_null)
                            {
                                return CalcErrorsNotAvailable
                            }
                            var valueArray = [];
                            var rowCount = expendedArgs[0].length;
                            var colCount = expendedArgs[0][0].length;
                            for (var rowIndex = 0; rowIndex < rowCount; rowIndex++)
                            {
                                valueArray[rowIndex] = [];
                                for (var colIndex = 0; colIndex < colCount; colIndex++)
                                {
                                    try
                                    {
                                        var expArgs = [];
                                        for (var argIndex = 0; argIndex < args.length; argIndex++)
                                        {
                                            expArgs[argIndex] = expendedArgs[argIndex][rowIndex][colIndex]
                                        }
                                        var value = evaluateDelegate(expArgs);
                                        if (Convert.ref(value))
                                        {
                                            if (expr.t === 7)
                                            {
                                                var fn = expr.fn;
                                                if (fn.returnReference && fn.returnReference())
                                                {
                                                    return value
                                                }
                                            }
                                            value = this.getOneValue(context, value)
                                        }
                                        valueArray[rowIndex][colIndex] = value
                                    }
                                    catch(InvalidCastException)
                                    {
                                        valueArray[rowIndex][colIndex] = CalcErrorsValue
                                    }
                                }
                            }
                            return new _ConcreteArray(valueArray)
                        }
                        else
                        {
                            try
                            {
                                var value = evaluateDelegate(args);
                                if (context.arrayFormulaMode && context._isExpandArrayToMultiCall())
                                {
                                    return value
                                }
                                if ((Convert.arr(value)) && !acceptsArray)
                                {
                                    return this.getOneValue(context, value)
                                }
                                else if ((Convert.ref(value)) && !acceptsReference)
                                {
                                    return this.getOneValue(context, value)
                                }
                                else
                                {
                                    return value
                                }
                            }
                            catch(InvalidCastException)
                            {
                                return CalcErrorsValue
                            }
                        }
                    };
                    Evaluator.prototype.getOneValue = function(context, value)
                    {
                        if (Convert.ref(value))
                        {
                            var reference = value;
                            if (reference.getRangeCount() > 1)
                            {
                                value = CalcErrorsValue
                            }
                            else
                            {
                                var r,
                                    c;
                                if (context.rowOffset != -1 || context.columnOffset != -1)
                                {
                                    r = reference.getRowCount(0) == 1 ? 0 : context.rowOffset;
                                    c = reference.getColumnCount(0) == 1 ? 0 : context.columnOffset
                                }
                                else
                                {
                                    r = reference.getRowCount(0) == 1 ? 0 : context.row - reference.getRow(0);
                                    c = reference.getColumnCount(0) == 1 ? 0 : context.column - reference.getColumn(0)
                                }
                                if (r >= reference.getRowCount(0) || c >= reference.getColumnCount(0))
                                {
                                    value = CalcErrorsNotAvailable
                                }
                                else
                                {
                                    value = reference.getValue(0, r, c)
                                }
                            }
                        }
                        else if (Convert.arr(value))
                        {
                            var array = value;
                            if (context.arrayFormulaMode && (context.rowOffset != -1 || context.columnOffset != -1))
                            {
                                var r = array.getRowCount() == 1 ? 0 : context.rowOffset;
                                var c = array.getColumnCount() == 1 ? 0 : context.columnOffset;
                                if (r >= array.getRowCount() || c >= array.getColumnCount())
                                {
                                    value = CalcErrorsNotAvailable
                                }
                                else
                                {
                                    value = array.getValue(r, c)
                                }
                            }
                            else
                            {
                                value = array.getValue(0, 0)
                            }
                        }
                        return value
                    };
                    Evaluator.prototype._expandArgs = function(context, expr, args, needExpendIndexs, getReferenceValues)
                    {
                        var rowCount = 1;
                        var colCount = 1;
                        var testArg = -1;
                        var expandRow = true,
                            expandColumn = true;
                        var functionExpr = expr.t === 7 ? expr : keyword_null;
                        if (functionExpr != keyword_null && !functionExpr.fn.expandRows())
                        {
                            expandRow = false
                        }
                        if (functionExpr != keyword_null && !functionExpr.fn.expandColumns())
                        {
                            expandColumn = false
                        }
                        if (functionExpr != keyword_null && functionExpr.fn.isBranch && (context.arrayFormulaMode || context._isExpandArrayToMultiCall()))
                        {
                            testArg = functionExpr.fn.findTestArgument();
                            var indexList = [];
                            var contains = false;
                            if (needExpendIndexs)
                            {
                                for (var i = 0; i < needExpendIndexs.length; i++)
                                {
                                    indexList.push(needExpendIndexs[i]);
                                    if (needExpendIndexs[i] === testArg)
                                    {
                                        contains = true
                                    }
                                }
                            }
                            if (contains || (Convert.arr(args[testArg])) || (Convert.ref(args[testArg])))
                            {
                                for (var j = 0; j < functionExpr.argCount(); j++)
                                {
                                    if (j != testArg && Sheets.ArrayHelper.indexOf(indexList, j) < 0 && (Convert.arr(args[j]) || Convert.ref(args[j])))
                                    {
                                        indexList.push(j)
                                    }
                                }
                                needExpendIndexs = indexList
                            }
                        }
                        for (var k = 0; k < needExpendIndexs.length; k++)
                        {
                            var argValue = args[needExpendIndexs[k]];
                            var array = Convert.arr(argValue) ? argValue : null;
                            var reference = Convert.ref(argValue) ? argValue : null;
                            var rc = 0,
                                cc = 0;
                            if (array != keyword_null)
                            {
                                rc = array.getRowCount();
                                cc = array.getColumnCount()
                            }
                            else if (reference != keyword_null)
                            {
                                if (reference.getRangeCount() > 1)
                                {
                                    return keyword_null
                                }
                                rc = expandRow ? reference.getRowCount(0) : 1;
                                cc = expandColumn ? reference.getColumnCount(0) : 1
                            }
                            rowCount = rc > rowCount ? rc : rowCount;
                            colCount = cc > colCount ? cc : colCount
                        }
                        var expArgs = [];
                        var expendIndexIndex = 0;
                        var expendIndex = needExpendIndexs[expendIndexIndex];
                        for (var argIndex = 0; argIndex < args.length; argIndex++)
                        {
                            expArgs[argIndex] = [];
                            var value = args[argIndex];
                            var array = null;
                            var reference = null;
                            var rc = 1,
                                cc = 1;
                            if (argIndex === expendIndex)
                            {
                                array = Convert.arr(value) ? value : keyword_null;
                                reference = Convert.ref(value) ? value : keyword_null;
                                if (array != keyword_null || reference != keyword_null)
                                {
                                    rc = array != keyword_null ? array.getRowCount() : (expandRow ? reference.getRowCount(0) : 1);
                                    cc = array != keyword_null ? array.getColumnCount() : (expandColumn ? reference.getColumnCount(0) : 1);
                                    if ((rc != 1 && rc != rowCount || cc != 1 && cc != colCount) && (testArg == -1 || argIndex == testArg) && !context.arrayFormulaMode)
                                    {
                                        return keyword_null
                                    }
                                }
                                expendIndexIndex++;
                                if (expendIndexIndex < needExpendIndexs.length)
                                {
                                    expendIndex = needExpendIndexs[expendIndexIndex]
                                }
                                else
                                {
                                    expendIndex = -1
                                }
                            }
                            if (reference != keyword_null)
                            {
                                var source = expr.source || context.source;
                                var sRow = reference.getRow(0),
                                    sCol = reference.getColumn(0);
                                rowCount = Math.min(context.source.getRowCount(), sRow + rowCount) - sRow;
                                colCount = Math.min(context.source.getColumnCount(), sCol + colCount) - sCol
                            }
                            for (var rowIndex = 0; rowIndex < rowCount; rowIndex++)
                            {
                                expArgs[argIndex][rowIndex] = [];
                                for (var colIndex = 0; colIndex < colCount; colIndex++)
                                {
                                    if (rc != 1 && rowIndex >= rc || cc != 1 && colIndex >= cc)
                                    {
                                        expArgs[argIndex][rowIndex][colIndex] = CalcErrorsNotAvailable
                                    }
                                    else if (array != keyword_null)
                                    {
                                        expArgs[argIndex][rowIndex][colIndex] = array.getValue(rc == 1 ? 0 : rowIndex, cc == 1 ? 0 : colIndex)
                                    }
                                    else if (reference != keyword_null)
                                    {
                                        if (getReferenceValues == keyword_null || getReferenceValues[argIndex])
                                        {
                                            expArgs[argIndex][rowIndex][colIndex] = reference.getValue(0, rc == 1 ? 0 : rowIndex, cc == 1 ? 0 : colIndex)
                                        }
                                        else
                                        {
                                            expArgs[argIndex][rowIndex][colIndex] = reference.create([new Sheets.Range(reference.getRow(0) + (rc == 1 ? 0 : rowIndex), reference.getColumn(0) + (cc == 1 ? 0 : colIndex), 1, 1)])
                                        }
                                    }
                                    else
                                    {
                                        expArgs[argIndex][rowIndex][colIndex] = value
                                    }
                                }
                            }
                        }
                        return expArgs
                    };
                    return Evaluator
                })();
            Calc.Evaluator = Evaluator
        })(Sheets.Calc || (Sheets.Calc = {}));
        var Calc = Sheets.Calc
    })(GcSpread.Sheets || (GcSpread.Sheets = {}));
    var Sheets = GcSpread.Sheets
})(GcSpread || (GcSpread = {}));
var __extends = this.__extends || function(d, b)
    {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __()
        {
            this.constructor = d
        }
        __.prototype = b.prototype;
        d.prototype = new __
    };
var GcSpread;
(function(GcSpread)
{
    (function(Sheets)
    {
        (function(Calc)
        {
            Sheets.feature("calc.common", ["core.migrate", "core.stringResource", "core.common", "core.globalize"]);
            var const_undefined = "undefined",
                const_number = "number",
                const_string = "string",
                const_boolean = "boolean",
                const_true = "TRUE",
                const_false = "FALSE",
                const_array = "ARRAY",
                const_arrayRow = "ARRAYROW",
                const_null = "#NULL!",
                const_div0 = "#DIV/0!",
                const_value = "#VALUE!",
                const_ref = "#REF!",
                const_name = "#NAME?",
                const_na = "#N/A",
                const_num = "#NUM!",
                ErrorList = [const_null, const_div0, const_value, const_ref, const_name, const_na, const_num],
                ErrorCodeList = [0x00, 0x07, 0x0F, 0x17, 0x1D, 0x2A, 0x24],
                LetterPows = [1, 26, 676],
                keyword_null = null,
                keyword_undefined = undefined,
                supportRowColumnFormula = false,
                Math_min = Math.min,
                Math_max = Math.max,
                Math_abs = Math.abs,
                Math_pow = Math.pow;
            var CalcValueTypeStrings = ["v", "n", "s", "b", "d"];
            var DefaultValues = [keyword_null, 0, "", false, new Date];
            var CalcErrorsNull = new Calc.CalcError(const_null, 0x00),
                CalcErrorsDivideByZero = new Calc.CalcError(const_div0, 0x07),
                CalcErrorsValue = new Calc.CalcError(const_value, 0x0F),
                CalcErrorsReference = new Calc.CalcError(const_ref, 0x17),
                CalcErrorsName = new Calc.CalcError(const_name, 0x1D),
                CalcErrorsNotAvailable = new Calc.CalcError(const_na, 0x2A),
                CalcErrorsNumber = new Calc.CalcError(const_num, 0x24);
            var SheetSource = (function(_super)
                {
                    __extends(SheetSource, _super);
                    function SheetSource(sheet)
                    {
                        _super.call(this, keyword_null);
                        this._sheet = sheet
                    }
                    SheetSource.prototype.startCalculation = function()
                    {
                        if (this._valueCaches)
                        {
                            return
                        }
                        var rowCount = this.getRowCount(),
                            colCount = this.getColumnCount();
                        this._valueCaches = {
                            rowCount: rowCount, colCount: colCount
                        }
                    };
                    SheetSource.prototype.endCalculation = function()
                    {
                        this._valueCaches = keyword_null
                    };
                    SheetSource.prototype.getValue = function(row, column, valueType)
                    {
                        var self = this,
                            sheet = self._sheet;
                        valueType = valueType === keyword_undefined ? 0 : valueType;
                        if (row < 0 || column < 0)
                            return CalcErrorsValue;
                        if (sheet._isValidatingCell && sheet._validatingRow === row && sheet._validatingColumn === column)
                        {
                            return sheet._validatingValue
                        }
                        var cache = self._valueCaches,
                            typeString = CalcValueTypeStrings[valueType];
                        if (cache)
                        {
                            var rowCount = cache.rowCount,
                                colCount = cache.colCount,
                                rowCache,
                                cellCache,
                                value;
                            if (row >= rowCount)
                            {
                                return CalcErrorsReference
                            }
                            if (column >= colCount)
                            {
                                return CalcErrorsReference
                            }
                            rowCache = cache[row];
                            if (!rowCache)
                            {
                                rowCache = cache[row] = {}
                            }
                            cellCache = rowCache[column];
                            if (!cellCache)
                            {
                                cellCache = rowCache[column] = {v: sheet.getValue(row, column)}
                            }
                            value = cellCache[typeString];
                            if (value === keyword_undefined)
                            {
                                value = Calc.Convert.convertValue(cellCache.v, valueType, true);
                                cellCache[typeString] = value
                            }
                            return value
                        }
                        else
                        {
                            if (row >= self.getRowCount())
                            {
                                return CalcErrorsReference
                            }
                            if (column >= self.getColumnCount())
                            {
                                return CalcErrorsReference
                            }
                            return self._sheet.getValue(row, column)
                        }
                    };
                    SheetSource.prototype.getReference = function(row, column, rowCount, columnCount)
                    {
                        var self = this;
                        if (row === -1 && column === -1)
                        {
                            return self.getSheetReference()
                        }
                        else if (row === -1)
                        {
                            return new Calc.SheetReference(self, [{
                                        row: 0, rowCount: self.getRowCount(), col: column, colCount: columnCount
                                    }])
                        }
                        else if (column === -1)
                        {
                            return new Calc.SheetReference(self, [{
                                        row: row, rowCount: rowCount, col: 0, colCount: self.getColumnCount()
                                    }])
                        }
                        else
                        {
                            return new Calc.SheetReference(self, [{
                                        row: row, rowCount: rowCount, col: column, colCount: columnCount
                                    }])
                        }
                    };
                    SheetSource.prototype.getSheetRangeReference = function(endSource, row, column, rowCount, columnCount)
                    {
                        if (this._sheet && this._sheet.parent && this._sheet.parent.sheets && (endSource instanceof SheetSource))
                        {
                            var sheets = this._sheet.parent.sheets,
                                searched = false,
                                source,
                                references = [];
                            for (var i = 0; i < sheets.length; i++)
                            {
                                source = sheets[i]._getSheetSource();
                                if (source === this)
                                {
                                    searched = true
                                }
                                else if (source === endSource)
                                {
                                    references.push(source.getReference(row, column, rowCount, columnCount));
                                    break
                                }
                                if (searched)
                                {
                                    references.push(source.getReference(row, column, rowCount, columnCount))
                                }
                            }
                            return new Calc._SheetRangeReference(references)
                        }
                    };
                    SheetSource.prototype.getSources = function(endSource)
                    {
                        if (this._sheet && this._sheet.parent && this._sheet.parent.sheets && (endSource instanceof SheetSource))
                        {
                            var sheets = this._sheet.parent.sheets,
                                searched = false,
                                source,
                                sources = [];
                            for (var i = 0; i < sheets.length; i++)
                            {
                                source = sheets[i]._getSheetSource();
                                if (source === this)
                                {
                                    searched = true
                                }
                                else if (source === endSource)
                                {
                                    sources.push(source);
                                    break
                                }
                                if (searched)
                                {
                                    sources.push(source)
                                }
                            }
                            return sources
                        }
                    };
                    SheetSource.prototype.referenceToArray = function(reference, valueType, toOneDimension, breakOnError, breakOnConvertError, ignoreBlank)
                    {
                        var self = this,
                            row,
                            col,
                            rowCount = 1,
                            colCount = 1,
                            startRow,
                            startCol,
                            rangeCount,
                            result = [],
                            cellCache,
                            value,
                            rowValues,
                            sheet = self._sheet,
                            valueCaches = self._valueCaches,
                            rowCaches,
                            cacheKey,
                            typeString = CalcValueTypeStrings[valueType],
                            defaultValues = DefaultValues,
                            errorObject = Calc.Convert.CalcConvertedError;
                        rangeCount = reference.getRangeCount();
                        if (rangeCount === 0)
                        {
                            result.isError = true;
                            return []
                        }
                        if (valueCaches)
                        {
                            cacheKey = reference.getRangeCount() + "_" + reference.getRow(0) + "_" + reference.getColumn(0) + "_" + reference.getRowCount(0) + "_" + reference.getColumnCount(0) + "_" + valueType + "_" + toOneDimension;
                            value = valueCaches[cacheKey];
                            if (value)
                            {
                                result = value.slice(0);
                                result.rowCount = value.rowCount;
                                result.colCount = value.colCount;
                                result.rangeCount = value.rangeCount;
                                return result
                            }
                        }
                        var maxRowCount = this.getRowCount(),
                            maxColCount = this.getColumnCount();
                        toOneDimension = toOneDimension === keyword_undefined ? true : toOneDimension;
                        for (var rangeIndex = 0; rangeIndex < rangeCount; rangeIndex++)
                        {
                            if (!toOneDimension)
                            {
                                rowValues = [];
                                result.push(rowValues)
                            }
                            rowCount = reference.getRowCount(rangeIndex);
                            if (rowCount === 0)
                            {
                                result.isError = true;
                                return []
                            }
                            colCount = reference.getColumnCount(rangeIndex);
                            if (colCount === 0)
                            {
                                result.isError = true;
                                return []
                            }
                            startRow = reference.getRow(rangeIndex);
                            startCol = reference.getColumn(rangeIndex);
                            if (breakOnError && (startRow + rowCount > maxRowCount || startCol + colCount > maxColCount))
                            {
                                result = [CalcErrorsReference];
                                result.isError = true;
                                return result
                            }
                            var r,
                                c,
                                colValues,
                                t,
                                needConsideValidating = sheet._isValidatingCell;
                            for (var i = 0; i < rowCount; i++)
                            {
                                row = startRow + i;
                                if (!toOneDimension)
                                {
                                    colValues = [];
                                    rowValues.push(colValues)
                                }
                                if (valueCaches)
                                {
                                    rowCaches = valueCaches[row];
                                    if (!rowCaches)
                                    {
                                        rowCaches = valueCaches[row] = {}
                                    }
                                }
                                for (var j = 0; j < colCount; j++)
                                {
                                    col = startCol + j;
                                    if (needConsideValidating && sheet._validatingRow === row && sheet._validatingColumn === col)
                                    {
                                        value = sheet._validatingValue;
                                        needConsideValidating = false
                                    }
                                    else
                                    {
                                        if (valueCaches)
                                        {
                                            t = rowCaches[col];
                                            if (t)
                                            {
                                                value = t.v
                                            }
                                            else
                                            {
                                                value = sheet.getValue(row, col);
                                                t = rowCaches[col] = {v: value}
                                            }
                                        }
                                        else
                                        {
                                            value = sheet.getValue(row, col)
                                        }
                                        if (breakOnError && Calc.Convert.err(value))
                                        {
                                            result = [value];
                                            result.isError = true;
                                            return result
                                        }
                                        if (t && t[typeString] !== keyword_undefined)
                                        {
                                            value = t[typeString]
                                        }
                                        else
                                        {
                                            value = Calc.Convert.convertValue(value, valueType, true, ignoreBlank);
                                            if (t)
                                            {
                                                t[typeString] = value
                                            }
                                            if (breakOnConvertError && t === value)
                                            {
                                                result = [CalcErrorsValue];
                                                result.isError = true;
                                                return result
                                            }
                                        }
                                    }
                                    if (toOneDimension)
                                    {
                                        result.push(value)
                                    }
                                    else
                                    {
                                        colValues.push(value)
                                    }
                                }
                            }
                        }
                        if (!toOneDimension && rangeCount === 1)
                        {
                            result = result[0]
                        }
                        result.rowCount = rowCount;
                        result.colCount = colCount;
                        result.rangeCount = rangeCount;
                        if (valueCaches)
                        {
                            valueCaches[cacheKey] = result.slice(0);
                            valueCaches[cacheKey].rowCount = rowCount;
                            valueCaches[cacheKey].colCount = colCount;
                            valueCaches[cacheKey].rangeCount = rangeCount
                        }
                        return result
                    };
                    SheetSource.prototype.getColumnCount = function()
                    {
                        return this._sheet.getColumnCount()
                    };
                    SheetSource.prototype.getRowCount = function()
                    {
                        return this._sheet.getRowCount()
                    };
                    SheetSource.prototype.isHiddenRow = function(row, onlyFiltered)
                    {
                        var sheet = this._sheet,
                            hasFilter = sheet.hasRowFilterOut();
                        if (hasFilter || !onlyFiltered)
                        {
                            return sheet.getRowHeight(row) === 0
                        }
                        return false
                    };
                    SheetSource.prototype.getName = function()
                    {
                        return this._sheet.getName()
                    };
                    SheetSource.prototype.setValue = function(row, column, value)
                    {
                        var self = this,
                            sheet = self._sheet;
                        var caches = self._valueCaches;
                        if (caches)
                        {
                            var rowCaches = caches[row];
                            if (rowCaches)
                            {
                                var cellCache = rowCaches[column];
                                if (cellCache)
                                {
                                    cellCache.v = value;
                                    if (cellCache.b !== undefined)
                                    {
                                        cellCache.b = undefined
                                    }
                                    if (cellCache.d !== undefined)
                                    {
                                        cellCache.d = undefined
                                    }
                                    if (cellCache.n !== undefined)
                                    {
                                        cellCache.n = undefined
                                    }
                                    if (cellCache.s !== undefined)
                                    {
                                        cellCache.s = undefined
                                    }
                                }
                            }
                        }
                        var m = sheet._getModel();
                        if (!m)
                        {
                            return
                        }
                        var valueSet = false;
                        var tm = sheet._tableManager;
                        var table = tm && tm.find(row, column);
                        if (table)
                        {
                            var isHeaderRow = table.showHeader() && row === table.headerIndex(),
                                isFooterRow = table.showFooter() && row === table.footerIndex();
                            if (!isHeaderRow && !isFooterRow)
                            {
                                valueSet = table._setValue(row, column, value)
                            }
                        }
                        var bm = sheet._bindingManager;
                        if (!valueSet && bm && bm._dataSource)
                        {
                            var bdValue = bm.getValue(row, column);
                            if (bdValue.hasBinding)
                            {
                                var oldItem = $.extend({}, sheet.getDataItem(row));
                                m._updateDirty(row, column, {
                                    originalItem: oldItem, oldValue: bm.getValue(row, column).value
                                });
                                bm.setValue(row, column, value)
                            }
                            valueSet = bdValue.hasBinding
                        }
                        if (!valueSet || sheet.checkingChanges)
                        {
                            m.setValue(row, column, value)
                        }
                    };
                    SheetSource.prototype.getCustomFunction = function(name)
                    {
                        return this._sheet ? this._sheet._findCustomFunction(name) : keyword_null
                    };
                    SheetSource.prototype.getCustomName = function(name)
                    {
                        var nameInfo = this._sheet ? this._sheet._findCustomName(name) : keyword_null;
                        if (nameInfo)
                        {
                            return nameInfo.getExpression()
                        }
                        return keyword_null
                    };
                    SheetSource.prototype.getSheet = function()
                    {
                        return this._sheet
                    };
                    SheetSource.prototype.getParserContext = function(useR1C1, baseRow, baseColumn, option)
                    {
                        return new SheetParserContext(this._sheet, useR1C1, baseRow, baseColumn, option)
                    };
                    SheetSource.prototype.setFormula = function(row, column, formula)
                    {
                        this._sheet._getModel().setFormula(row, column, formula)
                    };
                    SheetSource.prototype.setArrayFormula = function(row, column, rowCount, columnCount, formula)
                    {
                        this._sheet._getModel().setFormula(row, column, formula, new Sheets.Range(row, column, rowCount, columnCount))
                    };
                    SheetSource.prototype.refresh = function()
                    {
                        this._sheet.repaint()
                    };
                    return SheetSource
                })(Calc.CalcSource);
            Calc.SheetSource = SheetSource;
            var SheetParserContext = (function(_super)
                {
                    __extends(SheetParserContext, _super);
                    function SheetParserContext(sheet, useR1C1, baseRow, baseColumn, option)
                    {
                        _super.call(this, sheet._getSheetSource(), useR1C1, baseRow, baseColumn, option);
                        this._sheet = sheet
                    }
                    SheetParserContext.prototype.getExternalSource = function(bookName, sheetName)
                    {
                        var self = this;
                        var spread = self._sheet.parent;
                        if (bookName && (!spread || spread.name !== bookName))
                        {
                            return keyword_null
                        }
                        else if (!spread)
                        {
                            return Calc.compareStringIgnoreCase(self._sheet._name, sheetName) ? self._sheet._getSheetSource() : keyword_null
                        }
                        var sc = spread.sheets;
                        if (sc && sc.length > 0)
                        {
                            for (var i = 0; i < sc.length; i++)
                            {
                                var sheet = sc[i];
                                if (Calc.compareStringIgnoreCase(sheet._name, sheetName))
                                {
                                    return sheet._getSheetSource()
                                }
                            }
                        }
                        return _super.prototype.getExternalSource.call(this, bookName, sheetName)
                    };
                    SheetParserContext.prototype.getExternalSourceToken = function(source)
                    {
                        return source.getName()
                    };
                    SheetParserContext.prototype.getTableByName = function(name)
                    {
                        return this._sheet.findTableByName(name)
                    };
                    SheetParserContext.prototype.getTableByIndex = function(rowIndex, columnIndex)
                    {
                        return this._sheet.findTable(rowIndex, columnIndex)
                    };
                    SheetParserContext.prototype.setSource = function(source)
                    {
                        this.source = source;
                        if (source && source.getSheet)
                        {
                            this._sheet = source.getSheet()
                        }
                    };
                    return SheetParserContext
                })(Calc.ParserContext);
            Calc.SheetParserContext = SheetParserContext;
            function evaluateFormula(context, formula, baseRow, baseColumn, useR1C1)
            {
                var sheet = context && (context instanceof GcSpread.Sheets["Sheet"]) && context;
                var parser = new Calc.Parser;
                baseRow = baseRow === keyword_undefined ? 0 : baseRow;
                baseColumn = baseColumn === keyword_undefined ? 0 : baseColumn;
                var parserContext = new SheetParserContext(sheet, !!useR1C1, baseRow, baseColumn);
                var expression = parser.parse(formula, parserContext);
                return Calc.evaluateExpression(context, expression, baseRow, baseColumn)
            }
            Calc.evaluateFormula = evaluateFormula;
            function evaluateExpression(context, expression, baseRow, baseColumn)
            {
                var calcService = context.getCalcService();
                if (baseRow === keyword_undefined)
                {
                    baseRow = context.getActiveRowIndex()
                }
                if (baseColumn === keyword_undefined)
                {
                    baseColumn = context.getActiveColumnIndex()
                }
                var sheetSource = context._getSheetSource();
                var result = calcService.evaluateParsedFormula(sheetSource, expression, baseRow, baseColumn, false, true);
                return result
            }
            Calc.evaluateExpression = evaluateExpression;
            function rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative, table)
            {
                var row = range.row,
                    col = range.col,
                    endRow = range.row + range.rowCount - 1,
                    endCol = range.col + range.colCount - 1;
                var startRowRelative = false,
                    endRowRelative = false,
                    startColRelative = false,
                    endColRelative = false;
                if (arguments.length >= 4)
                {
                    startRowRelative = (rangeReferenceRelative & 1) !== 0;
                    endRowRelative = (rangeReferenceRelative & 4) !== 0;
                    startColRelative = (rangeReferenceRelative & 2) !== 0;
                    endColRelative = (rangeReferenceRelative & 8) !== 0;
                    row -= startRowRelative ? baseRow : 0;
                    endRow -= endRowRelative ? baseRow : 0;
                    col -= startColRelative ? baseCol : 0;
                    endCol -= endColRelative ? baseCol : 0
                }
                var expression;
                if (table)
                {
                    var structReferencePortions = getReferencePortions(range, table, baseRow);
                    var structReferenceColumnSpecifier = getReferenceColumnSpecifier(range, table, baseRow);
                    if (structReferencePortions && structReferenceColumnSpecifier)
                    {
                        expression = Calc.Expressions.StructReferenceExpression.create(table, structReferencePortions, structReferenceColumnSpecifier, range.col - table.dataRange().col, range.col + range.colCount - table.dataRange().col - 1);
                        return expression
                    }
                }
                if (range.row < 0 && range.col < 0)
                {
                    expression = new Calc.Expressions.RangeExpression
                }
                else if (range.row < 0)
                {
                    expression = new Calc.Expressions.RangeExpression;
                    expression.initBand(col, endCol, startColRelative, endColRelative, false)
                }
                else if (range.col < 0)
                {
                    expression = new Calc.Expressions.RangeExpression;
                    expression.initBand(row, endRow, startRowRelative, endRowRelative, true)
                }
                else if (range.rowCount === 1 && range.colCount === 1)
                {
                    expression = new Calc.Expressions.CellExpression(row, col, startRowRelative, startColRelative)
                }
                else
                {
                    expression = new Calc.Expressions.RangeExpression(row, col, endRow, endCol, startRowRelative, startColRelative, endRowRelative, endColRelative)
                }
                return expression
            }
            Calc.rangeToExpression = rangeToExpression;
            function getReferencePortions(range, table, baseRow)
            {
                if (range.rowCount === 1)
                {
                    if (table.hasHeadersRow() && range.row === table.startRow())
                    {
                        return 2
                    }
                    if (table.hasTotalsRow() && range.row === table.endRow())
                    {
                        return 8
                    }
                    if (baseRow === range.row)
                    {
                        return 1
                    }
                }
                else
                {
                    if (table.hasHeadersRow() && range.row === table.startRow())
                    {
                        if (range.rowCount === table.dataRange().rowCount + 1)
                        {
                            return 6
                        }
                        if (table.hasTotalsRow() && range.rowCount === table.dataRange().rowCount + 1 + 1)
                        {
                            return 14
                        }
                    }
                    if (range.row === table.dataRange().row)
                    {
                        if (range.rowCount === table.dataRange().rowCount)
                        {
                            return 3
                        }
                        if (table.hasTotalsRow() && range.rowCount === table.dataRange().rowCount + 1)
                        {
                            return 12
                        }
                    }
                }
                return keyword_undefined
            }
            function getReferenceColumnSpecifier(range, table, baseRow)
            {
                if (range.col === table.startColumn() && range.colCount === table.dataRange().colCount)
                {
                    return 1
                }
                if (range.colCount === 1)
                {
                    return 2
                }
                if (range.col >= table.startColumn() && (range.col + range.colCount - 1) <= table.endColumn())
                {
                    return 4
                }
                return keyword_undefined
            }
            function rangeToFormula(range, baseRow, baseCol, rangeReferenceRelative, useR1C1)
            {
                var expression = Calc.rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative);
                var context = new Calc.ParserContext(keyword_null, !!useR1C1, baseRow, baseCol);
                var parser = new Calc.Parser;
                return parser.unparse(expression, context)
            }
            Calc.rangeToFormula = rangeToFormula;
            function rangeToFormulaWithStructReference(source, range, baseRow, baseCol, rangeReferenceRelative, useR1C1, table)
            {
                var expression = Calc.rangeToExpression(range, baseRow, baseCol, rangeReferenceRelative, table);
                var context = new Calc.SheetParserContext(source, !!useR1C1, baseRow, baseCol);
                var parser = new Calc.Parser;
                return parser.unparse(expression, context)
            }
            Calc.rangeToFormulaWithStructReference = rangeToFormulaWithStructReference;
            function formulaToRange(sheet, formula, baseRow, baseCol)
            {
                if (!formula)
                {
                    return null
                }
                baseRow = !baseRow ? 0 : baseRow;
                baseCol = !baseCol ? 0 : baseCol;
                var service = sheet.getCalcService();
                var expr = service.parse(sheet._getSheetSource(), formula, baseRow, baseCol),
                    source;
                if (expr)
                {
                    source = expr.source;
                    if (source && expr.t === 17)
                    {
                        source = expr.source()
                    }
                }
                if (expr && expr.getRange && (!source || source === sheet._getSheetSource()))
                {
                    var cellRange = expr.getRange(baseRow, baseCol);
                    if (!cellRange)
                    {
                        return null
                    }
                    return new Sheets.Range(cellRange.row, cellRange.column, cellRange.rowCount, cellRange.columnCount)
                }
                return null
            }
            Calc.formulaToRange = formulaToRange;
            function rangesToFormula(ranges, baseRow, baseCol, rangeReferenceRelative, useR1C1)
            {
                var formula = "";
                var parser = new Calc.Parser;
                var context = new Calc.ParserContext(keyword_null, !!useR1C1, baseRow, baseCol);
                if (ranges.length > 1)
                {
                    formula = "("
                }
                for (var i = 0; i < ranges.length; i++)
                {
                    var expression = Calc.rangeToExpression(ranges[i], baseRow, baseCol, rangeReferenceRelative);
                    var rangeFormula = parser.unparse(expression, context);
                    if (i > 0)
                    {
                        formula += ', ' + rangeFormula
                    }
                    else
                    {
                        formula = rangeFormula
                    }
                }
                if (ranges.length > 1)
                {
                    formula += ")"
                }
                return formula
            }
            Calc.rangesToFormula = rangesToFormula;
            (function(RangeReferenceRelative)
            {
                RangeReferenceRelative[RangeReferenceRelative["allAbsolute"] = 0] = "allAbsolute";
                RangeReferenceRelative[RangeReferenceRelative["startRowRelative"] = 1] = "startRowRelative";
                RangeReferenceRelative[RangeReferenceRelative["startColRelative"] = 2] = "startColRelative";
                RangeReferenceRelative[RangeReferenceRelative["endRowRelative"] = 4] = "endRowRelative";
                RangeReferenceRelative[RangeReferenceRelative["endColRelative"] = 8] = "endColRelative";
                RangeReferenceRelative[RangeReferenceRelative["rowRelative"] = 5] = "rowRelative";
                RangeReferenceRelative[RangeReferenceRelative["colRelative"] = 10] = "colRelative";
                RangeReferenceRelative[RangeReferenceRelative["allRelative"] = 15] = "allRelative"
            })(Calc.RangeReferenceRelative || (Calc.RangeReferenceRelative = {}));
            var RangeReferenceRelative = Calc.RangeReferenceRelative
        })(Sheets.Calc || (Sheets.Calc = {}));
        var Calc = Sheets.Calc
    })(GcSpread.Sheets || (GcSpread.Sheets = {}));
    var Sheets = GcSpread.Sheets
})(GcSpread || (GcSpread = {}));
var GcSpread;
(function(GcSpread)
{
    (function(Sheets)
    {
        (function(Calc)
        {
            (function(_Functions)
            {
                Sheets.feature("calc.functions", ["calc.common"]);
                var $ = jQuery;
                var keyword_null = null,
                    keyword_undefined = undefined,
                    CalcConvert = Calc.Convert,
                    Math_abs = Math.abs,
                    Math_sqrt = Math.sqrt,
                    Math_max = Math.max,
                    Math_min = Math.min,
                    Math_floor = Math.floor,
                    Math_ceil = Math.ceil,
                    Math_sin = Math.sin,
                    Math_asin = Math.asin,
                    Math_cos = Math.cos,
                    Math_acos = Math.acos,
                    Math_tan = Math.tan,
                    Math_atan = Math.atan,
                    Math_atan2 = Math.atan2,
                    Math_exp = Math.exp,
                    Math_log = Math.log,
                    Math_PI = Math.PI,
                    Math_random = Math.random,
                    Math_pow = Math.pow,
                    const_string = "string",
                    const_boolean = "boolean",
                    const_number = "number";
                var CalcErrors = Calc.Errors,
                    CalcErrorsNull = CalcErrors.Null,
                    CalcErrorsDivideByZero = CalcErrors.DivideByZero,
                    CalcErrorsValue = CalcErrors.Value,
                    CalcErrorsReference = CalcErrors.Reference,
                    CalcErrorsName = CalcErrors.Name,
                    CalcErrorsNotAvailable = CalcErrors.NotAvailable,
                    CalcErrorsNumber = CalcErrors.Number;
                var Functions = Calc.Functions;
                Functions._builtInFunctions = Functions._builtInFunctions || {};
                function _defineBuildInFunction(name, fnEvaluate, options)
                {
                    if (name === keyword_undefined || name === keyword_null)
                    {
                        throw Sheets.SR.Exp_InvalidFunctionName;
                    }
                    var fn;
                    name = name.toUpperCase();
                    if (!Functions._builtInFunctions.hasOwnProperty(name))
                    {
                        fn = new Functions.Function(name, 0, 255);
                        Functions._builtInFunctions[name] = fn
                    }
                    else
                    {
                        fn = Functions._builtInFunctions[name];
                        if (!fn)
                        {
                            Functions._builtInFunctions[name] = new Functions.Function(name, 0, 255);
                            fn = Functions[name.toUpperCase()]
                        }
                        else if (!options || !options.override)
                        {
                            throw Sheets.SR.Exp_OverrideNotAllowed;
                        }
                    }
                    if (fnEvaluate && typeof fnEvaluate === "function")
                    {
                        fn.evaluate = fnEvaluate
                    }
                    if (options)
                    {
                        for (var prop in options)
                        {
                            if (options.hasOwnProperty(prop) && prop !== 'override')
                            {
                                fn[prop] = options[prop]
                            }
                        }
                    }
                    return fn
                }
                _Functions._defineBuildInFunction = _defineBuildInFunction;
                ;
                _Functions.def = _defineBuildInFunction;
                var _DateHelper = (function()
                    {
                        function _DateHelper(){}
                        _DateHelper.days360 = dt_days360;
                        _DateHelper.yearfrac = dt_yearfrac;
                        return _DateHelper
                    })();
                _Functions._DateHelper = _DateHelper;
                function acceptsAny(i)
                {
                    return true
                }
                _Functions.acceptsAny = acceptsAny;
                function acceptsNone()
                {
                    return false
                }
                _Functions.acceptsNone = acceptsNone;
                function acceptsNotZero(i)
                {
                    return i !== 0
                }
                _Functions.acceptsNotZero = acceptsNotZero;
                function acceptsOne(i)
                {
                    return i === 1
                }
                _Functions.acceptsOne = acceptsOne;
                function acceptsTwo(i)
                {
                    return i === 2
                }
                _Functions.acceptsTwo = acceptsTwo;
                function acceptsZeroTwo(i)
                {
                    return i === 0 || i === 2
                }
                _Functions.acceptsZeroTwo = acceptsZeroTwo;
                function acceptsZeroOdd(i)
                {
                    return i === 0 || i % 2 === 1
                }
                _Functions.acceptsZeroOdd = acceptsZeroOdd;
                function acceptsThree(i)
                {
                    return i === 3
                }
                _Functions.acceptsThree = acceptsThree;
                function isVolatile()
                {
                    return true
                }
                _Functions.isVolatile = isVolatile;
                function acceptsOneTwo(i)
                {
                    return i === 1 || i === 2
                }
                _Functions.acceptsOneTwo = acceptsOneTwo;
                function isBranch()
                {
                    return true
                }
                _Functions.isBranch = isBranch;
                function acceptsZero(i)
                {
                    return i === 0
                }
                _Functions.acceptsZero = acceptsZero;
                function __iterate(obj, fn, ctx)
                {
                    if (CalcConvert.err(obj))
                    {
                        ctx.value = obj;
                        return false
                    }
                    else if (CalcConvert.ref(obj))
                    {
                        for (var a = 0; a < obj.getRangeCount(); a++)
                        {
                            for (var r = 0; r < obj.getRowCount(a); r++)
                            {
                                for (var c = 0; c < obj.getColumnCount(a); c++)
                                {
                                    if (obj instanceof Calc._SheetRangeReference)
                                    {
                                        for (var i = 0; i < obj.getSheetCount(); i++)
                                        {
                                            if (ctx.includeSubtotal || !obj.isSubtotal(i, a, r, c))
                                            {
                                                if (fn(obj.getValue(i, a, r, c), ctx) === false)
                                                {
                                                    return false
                                                }
                                            }
                                        }
                                    }
                                    else if (ctx.includeSubtotal || !obj.isSubtotal(a, r, c))
                                    {
                                        if (fn(obj.getValue(a, r, c), ctx) === false)
                                        {
                                            return false
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (CalcConvert.arr(obj))
                    {
                        for (var i1 = 0; i1 < obj.length(); i1++)
                        {
                            if (fn(obj.getValueByIndex(i1), ctx) === false)
                            {
                                return false
                            }
                        }
                    }
                    else if ($.isArray(obj))
                    {
                        $.each(obj, function(i, v)
                        {
                            return fn(v, ctx)
                        })
                    }
                    else
                    {
                        if (fn(obj, ctx) === false)
                        {
                            return false
                        }
                    }
                    return true
                }
                function findTestArgument()
                {
                    return 0
                }
                _Functions.findTestArgument = findTestArgument;
                function findBranchArgument(test)
                {
                    if (CalcConvert.err(test))
                    {
                        return -1
                    }
                    var result = false;
                    try
                    {
                        result = CalcConvert.B(test)
                    }
                    catch(err) {}
                    return result ? 1 : 2
                }
                function acceptAboveZero(i)
                {
                    return i > 0
                }
                _Functions.acceptAboveZero = acceptAboveZero;
                function acceptsSecond(i)
                {
                    return i === 1
                }
                _Functions.acceptsSecond = acceptsSecond;
                function acceptsSecondOrThirdOrFourth(i)
                {
                    return i === 1 || i === 2 || i === 3
                }
                _Functions.acceptsSecondOrThirdOrFourth = acceptsSecondOrThirdOrFourth;
                function acceptsThird(i)
                {
                    return i === 2
                }
                _Functions.acceptsThird = acceptsThird;
                function acceptsFirstOrThird(i)
                {
                    return i === 0 || i === 2
                }
                _Functions.acceptsFirstOrThird = acceptsFirstOrThird;
                function acceptsFirstOrOne(i)
                {
                    return i === 0 || i === 1
                }
                _Functions.acceptsFirstOrOne = acceptsFirstOrOne;
                function acceptsFirstOrOdd(i)
                {
                    return i === 0 || i % 2 === 1
                }
                _Functions.acceptsFirstOrOdd = acceptsFirstOrOdd;
                function acceptsFirst(i)
                {
                    return i === 0
                }
                _Functions.acceptsFirst = acceptsFirst;
                function acceptsFirstOrSecondOrThird(i)
                {
                    return i === 0 || i === 1 || i === 2
                }
                _Functions.acceptsFirstOrSecondOrThird = acceptsFirstOrSecondOrThird;
                function acceptsEven(i)
                {
                    return i % 2 === 0
                }
                _Functions.acceptsEven = acceptsEven;
                function acceptsFourth(i)
                {
                    return i === 3
                }
                _Functions.acceptsFourth = acceptsFourth;
                function acceptsNotFourth(i)
                {
                    return i !== 3
                }
                _Functions.acceptsNotFourth = acceptsNotFourth;
                function acceptsFourthOrFifth(i)
                {
                    return i === 3 || i === 4
                }
                _Functions.acceptsFourthOrFifth = acceptsFourthOrFifth;
                function acceptsNotSecond(i)
                {
                    return i !== 1
                }
                _Functions.acceptsNotSecond = acceptsNotSecond;
                function acceptsThreeFour(i)
                {
                    return i === 3 || i === 4
                }
                _Functions.acceptsThreeFour = acceptsThreeFour;
                function acceptsTwoThree(i)
                {
                    return i === 2 || i === 3
                }
                _Functions.acceptsTwoThree = acceptsTwoThree;
                function acceptsPositive(i)
                {
                    return i > 0
                }
                _Functions.acceptsPositive = acceptsPositive;
                function acceptsFour(i)
                {
                    return i === 4
                }
                _Functions.acceptsFour = acceptsFour;
                function acceptsFourFive(i)
                {
                    return i === 4 || i === 5
                }
                _Functions.acceptsFourFive = acceptsFourFive;
                function acceptsFive(i)
                {
                    return i === 5
                }
                _Functions.acceptsFive = acceptsFive;
                function acceptsSix(i)
                {
                    return i === 6
                }
                _Functions.acceptsSix = acceptsSix;
                function acceptsEight(i)
                {
                    return i === 8
                }
                _Functions.acceptsEight = acceptsEight;
                function acceptsSeven(i)
                {
                    return i === 7
                }
                _Functions.acceptsSeven = acceptsSeven;
                function acceptsNotTwo(i)
                {
                    return i !== 2
                }
                _Functions.acceptsNotTwo = acceptsNotTwo;
                function acceptsFiveSix(i)
                {
                    return i === 5 || i === 6
                }
                _Functions.acceptsFiveSix = acceptsFiveSix;
                function acceptsFourSixSeven(i)
                {
                    return i === 4 || i === 6 || i === 7
                }
                _Functions.acceptsFourSixSeven = acceptsFourSixSeven;
                function acceptsThreeFourFive(i)
                {
                    return i === 3 || i === 4 || i === 5
                }
                _Functions.acceptsThreeFourFive = acceptsThreeFourFive;
                function acceptsMoreThanOne(i)
                {
                    return i >= 1
                }
                _Functions.acceptsMoreThanOne = acceptsMoreThanOne;
                function acceptsTwoThreeFour(i)
                {
                    return i === 2 || i === 3 || i === 4
                }
                _Functions.acceptsTwoThreeFour = acceptsTwoThreeFour;
                function acceptsOneTwoThree(i)
                {
                    return i === 1 || i === 2 || i === 3
                }
                _Functions.acceptsOneTwoThree = acceptsOneTwoThree;
                var KeyValuePair = (function()
                    {
                        function KeyValuePair(charKey, intValue)
                        {
                            this.Key = charKey;
                            this.Value = intValue
                        }
                        return KeyValuePair
                    })();
                var regExpKeyPattern = [/\\/g, /\(/g, /\[/g, /\{/g, /\^/g, /\$/g, /\|/g, /\)/g, /\+/g, /\./g];
                function __createStringcomparisonRegexPattern(s1)
                {
                    if (s1 === "" || s1 === keyword_undefined || s1 === keyword_null)
                    {
                        return s1
                    }
                    for (var i in regExpKeyPattern)
                    {
                        if (regExpKeyPattern.hasOwnProperty(i))
                        {
                            s1 = s1.replace(regExpKeyPattern[i], regExpKeyPattern[i].source)
                        }
                    }
                    s1 = s1.replace("~?", "{113E2532-EAF5-444c-A5CB-3D7446971C4D}");
                    s1 = s1.replace("~*", "{E21523B3-0F1F-458f-B547-23D25713D0EC}");
                    s1 = s1.replace("?", ".");
                    s1 = s1.replace("*", "((.|\\n)*)");
                    s1 = s1.replace("{113E2532-EAF5-444c-A5CB-3D7446971C4D}", "\\?");
                    s1 = s1.replace("{E21523B3-0F1F-458f-B547-23D25713D0EC}", "\\*");
                    return s1.toString()
                }
                var _FinancialHelper = (function()
                    {
                        function _FinancialHelper(){}
                        _FinancialHelper.__isLeapYear = function(year)
                        {
                            return (year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)) || year === 1900
                        };
                        _FinancialHelper.__compareDateTime = function(date1, date2)
                        {
                            return date1 - date2
                        };
                        _FinancialHelper.__toOADate = function(date)
                        {
                            return new GcSpread.Sheets._DateTimeHelper(date).toOADate()
                        };
                        _FinancialHelper.__annual_year_basis = function(date, basis)
                        {
                            var leap_year;
                            switch (basis)
                            {
                                case 0:
                                    return 360;
                                case 1:
                                    leap_year = _FinancialHelper.__isLeapYear(date.getFullYear());
                                    return leap_year ? 366 : 365;
                                case 2:
                                    return 360;
                                case 3:
                                    return 365;
                                case 4:
                                    return 360;
                                default:
                                    return -1
                            }
                        };
                        _FinancialHelper.__getDaysInMonth = function(year, month)
                        {
                            switch (month)
                            {
                                case 0:
                                case 2:
                                case 4:
                                case 6:
                                case 7:
                                case 9:
                                case 11:
                                    return 31;
                                case 1:
                                    if (_FinancialHelper.__isLeapYear(year))
                                    {
                                        return 29
                                    }
                                    else
                                    {
                                        return 28
                                    }
                                    break;
                                case 3:
                                case 5:
                                case 8:
                                case 10:
                                    return 30
                            }
                        };
                        _FinancialHelper.__Days_Between_BASIS_30E_360 = function(from, to)
                        {
                            var y1,
                                m1,
                                d1,
                                y2,
                                m2,
                                d2;
                            y1 = from.getFullYear();
                            m1 = from.getMonth();
                            d1 = from.getDate();
                            y2 = to.getFullYear();
                            m2 = to.getMonth();
                            d2 = to.getDate();
                            if (d1 === 31)
                            {
                                d1 = 30
                            }
                            if (d2 === 31)
                            {
                                d2 = 30
                            }
                            return (y2 - y1) * 360 + (m2 - m1) * 30 + (d2 - d1)
                        };
                        _FinancialHelper.__Days_Between_BASIS_30Ep_360 = function(from, to)
                        {
                            var y1,
                                m1,
                                d1,
                                y2,
                                m2,
                                d2;
                            y1 = from.getFullYear();
                            m1 = from.getMonth();
                            d1 = from.getDate();
                            y2 = to.getFullYear();
                            m2 = to.getMonth();
                            d2 = to.getDate();
                            if (d1 === 31)
                            {
                                d1 = 30
                            }
                            if (d2 === 31)
                            {
                                d2 = 1;
                                m2++
                            }
                            return (y2 - y1) * 360 + (m2 - m1) * 30 + (d2 - d1)
                        };
                        _FinancialHelper.__Days_Between_BASIS_MSRB_30_360_SYM = function(from, to)
                        {
                            var y1,
                                m1,
                                d1,
                                y2,
                                m2,
                                d2;
                            y1 = from.getFullYear();
                            m1 = from.getMonth();
                            d1 = from.getDate();
                            y2 = to.getFullYear();
                            m2 = to.getMonth();
                            d2 = to.getDate();
                            if (m1 === 2 && _FinancialHelper.__getDaysInMonth(y1, m1) === d1)
                            {
                                d1 = 30
                            }
                            if (m2 === 2 && _FinancialHelper.__getDaysInMonth(y2, m2) === d2)
                            {
                                d2 = 30
                            }
                            if (d2 === 31 && d1 >= 30)
                            {
                                d2 = 30
                            }
                            if (d1 === 31)
                            {
                                d1 = 30
                            }
                            return (y2 - y1) * 360 + (m2 - m1) * 30 + (d2 - d1)
                        };
                        _FinancialHelper.__Days_Between_BASIS_MSRB_30_360 = function(from, to)
                        {
                            var y1,
                                m1,
                                d1,
                                y2,
                                m2,
                                d2;
                            y1 = from.getFullYear();
                            m1 = from.getMonth();
                            d1 = from.getDate();
                            y2 = to.getFullYear();
                            m2 = to.getMonth();
                            d2 = to.getDate();
                            if ((m1 === 2 && _FinancialHelper.__getDaysInMonth(y1, m1) === d1) && (m2 === 2 && _FinancialHelper.__getDaysInMonth(y2, m2) === d2))
                            {
                                d1 = 30;
                                d2 = 30
                            }
                            if (d2 === 31 && d1 >= 30)
                            {
                                d2 = 30
                            }
                            if (d1 === 31)
                            {
                                d1 = 30
                            }
                            return (y2 - y1) * 360 + (m2 - m1) * 30 + (d2 - d1)
                        };
                        _FinancialHelper.__days_between_basis = function(from, to, basis)
                        {
                            var sign = 1;
                            if (_FinancialHelper.__compareDateTime(from, to) > 0)
                            {
                                var tmp = from;
                                from = to;
                                to = tmp;
                                sign = -1
                            }
                            switch (basis)
                            {
                                case 1:
                                case 2:
                                case 3:
                                    return sign * CalcConvert.I(_FinancialHelper.__toOADate(to) - _FinancialHelper.__toOADate(from));
                                case 4:
                                    return sign * _FinancialHelper.__Days_Between_BASIS_30E_360(from, to);
                                case 5:
                                    return sign * _FinancialHelper.__Days_Between_BASIS_30Ep_360(from, to);
                                case 6:
                                    return sign * _FinancialHelper.__Days_Between_BASIS_MSRB_30_360_SYM(from, to);
                                default:
                                    return sign * _FinancialHelper.__Days_Between_BASIS_MSRB_30_360(from, to)
                            }
                        };
                        return _FinancialHelper
                    })();
                _Functions._FinancialHelper = _FinancialHelper;
                var _StatHelper = (function()
                    {
                        function _StatHelper(){}
                        _StatHelper.__dev1 = function(args, stc, includeSubtotals, includeHiddenRow)
                        {
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 1, false, false, false, true);
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                var val = rowRef[col];
                                                if (val !== CalcConvert.CalcConvertedError)
                                                {
                                                    stc.sumx += val;
                                                    stc.sumx2 += val * val;
                                                    stc.n++
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        };
                        _StatHelper.st_normsdist = function(args)
                        {
                            var z;
                            if (isNaN(z = CalcConvert.D(args[0])))
                            {
                                return CalcErrorsValue
                            }
                            var Z_MAX = 6.0;
                            var y;
                            var x;
                            var w;
                            if (z === 0.0)
                            {
                                x = 0.0
                            }
                            else
                            {
                                y = 0.5 * Math_abs(z);
                                if (y >= (Z_MAX * 0.5))
                                {
                                    x = 1.0
                                }
                                else if (y < 1.0)
                                {
                                    w = y * y;
                                    x = ((((((((0.000124818987 * w - 0.001075204047) * w + 0.005198775019) * w - 0.019198292004) * w + 0.059054035642) * w - 0.151968751364) * w + 0.319152932694) * w - 0.531923007300) * w + 0.797884560593) * y * 2.0
                                }
                                else
                                {
                                    y -= 2.0;
                                    x = (((((((((((((-0.000045255659 * y + 0.000152529290) * y - 0.000019538132) * y - 0.000676904986) * y + 0.001390604284) * y - 0.000794620820) * y - 0.002034254874) * y + 0.006549791214) * y - 0.010557625006) * y + 0.011630447319) * y - 0.009279453341) * y + 0.005353579108) * y - 0.002141268741) * y + 0.000535310849) * y + 0.999936657524
                                }
                            }
                            return z > 0.0 ? ((x + 1.0) * 0.5) : ((1.0 - x) * 0.5)
                        };
                        _StatHelper.__averageIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var sum = 0.0;
                            var n = 0.0;
                            var n = 0;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 1, false, false, false, true);
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                var val = rowRef[col];
                                                if (val !== CalcConvert.CalcConvertedError)
                                                {
                                                    sum += val;
                                                    n++
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (n === 0)
                            {
                                return CalcErrorsDivideByZero
                            }
                            return CalcConvert.toResult(sum / n)
                        };
                        _StatHelper.__countIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var n = 0;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 0, false, false, false, true);
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                var val = rowRef[col];
                                                if (val !== null && val !== "" && val !== CalcConvert.CalcConvertedError && CalcConvert.num(val))
                                                {
                                                    n++
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return n
                        };
                        _StatHelper.__countaIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var n = 0;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 0, false, false, false);
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                var val = rowRef[col];
                                                if (val !== keyword_null && val !== keyword_undefined)
                                                {
                                                    n++
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return n
                        };
                        _StatHelper.__maxIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var anyValue = false,
                                max = 0.0,
                                val;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 1, false, true, false, true);
                                if (array.isError)
                                {
                                    return array[0]
                                }
                                if (array.isConvertError)
                                {
                                    return CalcErrorsValue
                                }
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                val = rowRef[col];
                                                if (val !== CalcConvert.CalcConvertedError)
                                                {
                                                    if (!anyValue || val > max)
                                                    {
                                                        max = val
                                                    }
                                                    anyValue = true
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return max
                        };
                        _StatHelper.__minIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var anyValue = false,
                                min = 0.0,
                                val;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 1, false, true, false, true);
                                if (array.isError)
                                {
                                    return array[0]
                                }
                                if (array.isConvertError)
                                {
                                    return CalcErrorsValue
                                }
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                val = rowRef[col];
                                                if (val !== CalcConvert.CalcConvertedError)
                                                {
                                                    if (!anyValue || val < min)
                                                    {
                                                        min = val
                                                    }
                                                    anyValue = true
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return min
                        };
                        _StatHelper.__sumIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var result = 0,
                                val;
                            for (var i = 0; i < args.length; i++)
                            {
                                var array = CalcConvert.toArr(args[i], 1, false, true, false, true);
                                if (array.isError)
                                {
                                    return array[0]
                                }
                                if (array.isConvertError)
                                {
                                    return CalcErrorsValue
                                }
                                for (var range = 0; range < array.rangeCount; range++)
                                {
                                    var rangeRef = array.rangeCount > 1 ? array[range] : array;
                                    var refRow,
                                        refCol;
                                    if (array.isReference)
                                    {
                                        refRow = args[i].getRow(range);
                                        refCol = args[i].getColumn(range)
                                    }
                                    for (var row = 0; row < rangeRef.length; row++)
                                    {
                                        if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                        {
                                            continue
                                        }
                                        var rowRef = rangeRef[row];
                                        for (var col = 0; col < rowRef.length; col++)
                                        {
                                            if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                            {
                                                val = rowRef[col];
                                                if (val !== CalcConvert.CalcConvertedError)
                                                {
                                                    result += val
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return result
                        };
                        _StatHelper.__stdevIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var data = {
                                    sumx: 0.0, sumx2: 0.0, n: 0.0
                                };
                            var flag = _StatHelper.__dev1(args, data, includeSubtotals, includeHiddenRow);
                            if (CalcConvert.err(flag))
                            {
                                return flag
                            }
                            if (data.n <= 1.0)
                            {
                                return CalcErrorsDivideByZero
                            }
                            return CalcConvert.toResult(Math_sqrt(Math_max(0.0, (data.n * data.sumx2 - data.sumx * data.sumx) / (data.n * (data.n - 1.0)))))
                        };
                        _StatHelper.__stdevpIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var data = {
                                    sumx: 0.0, sumx2: 0.0, n: 0.0
                                };
                            var flag = _StatHelper.__dev1(args, data, includeSubtotals, includeHiddenRow);
                            if (CalcConvert.err(flag))
                            {
                                return flag
                            }
                            if (data.n <= 0.0)
                            {
                                return CalcErrorsDivideByZero
                            }
                            return CalcConvert.toResult(Math_sqrt(Math_max(0.0, (data.n * data.sumx2 - data.sumx * data.sumx) / (data.n * data.n))))
                        };
                        _StatHelper.__varrIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var data = {
                                    sumx: 0.0, sumx2: 0.0, n: 0.0
                                };
                            var flag = _StatHelper.__dev1(args, data, includeSubtotals, includeHiddenRow);
                            if (CalcConvert.err(flag))
                            {
                                return flag
                            }
                            if (data.n <= 1.0)
                            {
                                return CalcErrorsDivideByZero
                            }
                            return CalcConvert.toResult(Math_max(0.0, (data.n * data.sumx2 - data.sumx * data.sumx) / (data.n * (data.n - 1.0))))
                        };
                        _StatHelper.__varpIncludeSubtotals = function(args, includeSubtotals, includeHiddenRow)
                        {
                            var data = {
                                    sumx: 0.0, sumx2: 0.0, n: 0.0
                                };
                            var flag = _StatHelper.__dev1(args, data, includeSubtotals, includeHiddenRow);
                            if (CalcConvert.err(flag))
                            {
                                return flag
                            }
                            if (data.n <= 0.0)
                            {
                                return CalcErrorsDivideByZero
                            }
                            return CalcConvert.toResult(Math_max(0.0, (data.n * data.sumx2 - data.sumx * data.sumx) / (data.n * data.n)))
                        };
                        _StatHelper.st_percentile = st_percentile;
                        return _StatHelper
                    })();
                _Functions._StatHelper = _StatHelper;
                function mt_abs(args)
                {
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_abs(num))
                }
                function mt_int(args)
                {
                    var num = parseFloat((args[0]));
                    if (num === keyword_undefined || num === keyword_null)
                    {
                        return CalcErrorsValue
                    }
                    return Functions._MathHelper.approxFloor(num)
                }
                function mt_ceiling(args)
                {
                    var num = CalcConvert.D(args[0]);
                    var sign = CalcConvert.D(args[1]);
                    if (isNaN(num) || isNaN(sign))
                    {
                        return CalcErrorsValue
                    }
                    if (num === 0.0 || sign === 0.0)
                    {
                        return 0.0
                    }
                    if (num > 0.0 && sign < 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    if (num < 0.0 && 0.0 < sign)
                    {
                        sign = -sign;
                        return Functions._MathHelper.approxFloor(num / sign) * sign
                    }
                    return Functions._MathHelper.approxCeiling(num / sign) * sign
                }
                function mt_combin(args)
                {
                    var n = parseFloat(args[0]);
                    var k = parseFloat(args[1]);
                    if (isNaN(n) || isNaN(k))
                    {
                        return CalcErrorsValue
                    }
                    if (n < 0.0 || k < 0.0 || n < k)
                    {
                        return CalcErrorsNumber
                    }
                    var result = 1.0;
                    k = Math_min(n - k, k);
                    for (var i = 1.0; i <= k; i++)
                    {
                        result *= n - i + 1.0;
                        result /= i
                    }
                    return CalcConvert.toResult(result)
                }
                function mt_degrees(args)
                {
                    var num;
                    if (isNaN(num = parseFloat(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return 180.0 * num / Math_PI
                }
                function mt_even(args)
                {
                    var num = parseFloat(args[0]);
                    if (num < 0.0)
                    {
                        num = Math_floor(num);
                        if (num % 2.0 !== 0.0)
                        {
                            num -= 1.0
                        }
                    }
                    else
                    {
                        num = Math_ceil(num);
                        if (num % 2.0 !== 0.0)
                        {
                            num += 1.0
                        }
                    }
                    return num
                }
                function mt_fact(args)
                {
                    var num = parseInt(args[0], 10);
                    var result = 1.0;
                    if (isNaN(num))
                    {
                        return CalcErrorsValue
                    }
                    if (num < 0 || 170 < num)
                    {
                        return CalcErrorsNumber
                    }
                    for (var i = 1; i <= num; i++)
                    {
                        result *= i
                    }
                    return result
                }
                function mt_factdouble(args)
                {
                    var num = parseInt(args[0], 10);
                    var result = 1.0;
                    if (isNaN(num))
                    {
                        return CalcErrorsValue
                    }
                    if (num < 0 || 300 < num)
                    {
                        return CalcErrorsNumber
                    }
                    for (var i = num; i > 1; i -= 2)
                    {
                        result *= i
                    }
                    return result
                }
                function mt_ln(args)
                {
                    var num = parseFloat(args[0]);
                    if (num === keyword_undefined || num === keyword_null)
                    {
                        return CalcErrorsValue
                    }
                    if (num <= 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_log(num))
                }
                function mt_mod(args)
                {
                    var num = parseFloat(args[0]);
                    var divisor = parseFloat(args[1]);
                    if (divisor === 0.0)
                    {
                        return "#DIV/0!"
                    }
                    return num - divisor * Math_floor(num / divisor)
                }
                function mt_odd(args)
                {
                    var num = parseFloat(args[0]);
                    if (num < 0.0)
                    {
                        num = Math_floor(num);
                        if (num % 2.0 === 0.0)
                        {
                            num -= 1.0
                        }
                    }
                    else
                    {
                        num = Math_ceil(num);
                        if (num % 2.0 === 0.0)
                        {
                            num += 1.0
                        }
                    }
                    return num
                }
                function mt_pi(args)
                {
                    return Math_PI
                }
                function mt_power(args)
                {
                    var num = parseFloat(args[0]);
                    var power = parseFloat(args[1]);
                    return Math_pow(num, power)
                }
                function __sumItems(item, ctx)
                {
                    if (CalcConvert.err(item))
                    {
                        ctx.value = item;
                        return false
                    }
                    else if (CalcConvert.ref(item) || CalcConvert.arr(item) || $.isArray(item))
                    {
                        return __iterate(item, __sumItems, ctx)
                    }
                    else
                    {
                        var dv = {value: 0};
                        if (CalcConvert.rD(item, dv))
                        {
                            var v = dv.value;
                            if (!isNaN(v) && isFinite(v))
                            {
                                ctx.value += v
                            }
                        }
                        return true
                    }
                }
                function mt_sum(args)
                {
                    if (!args || args.length < 1)
                    {
                        throw Sheets.SR.Exp_InvalidArgument;
                    }
                    var result = 0;
                    var length1,
                        length2,
                        length3;
                    for (var argIndex = 0; argIndex < args.length; argIndex++)
                    {
                        var obj = args[argIndex];
                        var arrayValue;
                        if (CalcConvert.err(obj))
                        {
                            return obj
                        }
                        else if (CalcConvert.ref(obj) || CalcConvert.arr(obj))
                        {
                            arrayValue = CalcConvert.toArr(obj, 1, true, true, false);
                            if (arrayValue.isError)
                            {
                                return arrayValue[0]
                            }
                        }
                        else
                        {
                            arrayValue = CalcConvert.toArr(obj, 1, true, true, true)
                        }
                        length1 = arrayValue.length;
                        for (var i = 0; i < length1; i++)
                        {
                            if (arrayValue[i] !== CalcConvert.CalcConvertedError)
                            {
                                result += arrayValue[i]
                            }
                        }
                    }
                    return result
                }
                function mt_sign(args)
                {
                    var num = parseFloat(args[0]);
                    if (num > 0)
                    {
                        return 1
                    }
                    else if (num === 0)
                    {
                        return 0
                    }
                    else
                    {
                        return -1
                    }
                }
                function __gcdImp(a, b)
                {
                    while (b !== 0)
                    {
                        var r = a % b;
                        a = b;
                        b = r
                    }
                    return a
                }
                function mt_gcd(args)
                {
                    var result = 0;
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 1, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            var obj = array[i];
                            if (obj !== CalcConvert.CalcConvertedError)
                            {
                                if (obj < 0)
                                {
                                    return CalcErrorsNumber
                                }
                                result = __gcdImp(result, CalcConvert.I(obj))
                            }
                        }
                    }
                    return result
                }
                function mt_lcm(args)
                {
                    var result = 1;
                    var nums = [];
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 1, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            var obj = array[j];
                            if (obj !== CalcConvert.CalcConvertedError)
                            {
                                if (obj < 0)
                                {
                                    return CalcErrorsNumber
                                }
                                else if (obj === 0)
                                {
                                    return 0
                                }
                                nums.push(CalcConvert.I(obj))
                            }
                        }
                        for (var k = 0; k < nums.length; k++)
                        {
                            var item = nums[k];
                            result /= __gcdImp(result, item);
                            result *= item
                        }
                    }
                    return result
                }
                function __productImp(args, includeSubtotals, includeHiddenRow)
                {
                    var result = 1.0;
                    var count = 0;
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 1, false, false, false, true);
                        for (var range = 0; range < array.rangeCount; range++)
                        {
                            var rangeRef = array.rangeCount > 1 ? array[range] : array;
                            var refRow,
                                refCol;
                            if (array.isReference)
                            {
                                refRow = args[i].getRow(range);
                                refCol = args[i].getColumn(range)
                            }
                            for (var row = 0; row < rangeRef.length; row++)
                            {
                                if (!includeSubtotals && array.isReference && args[i].isHiddenRow(range, row, includeHiddenRow))
                                {
                                    continue
                                }
                                var rowRef = rangeRef[row];
                                for (var col = 0; col < rowRef.length; col++)
                                {
                                    if (includeSubtotals || !array.isReference || !args[i].isSubtotal(range, row + refRow, col + refCol))
                                    {
                                        var val = rowRef[col];
                                        if (val !== CalcConvert.CalcConvertedError)
                                        {
                                            result *= CalcConvert.D(val);
                                            count++
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return CalcConvert.toResult(count > 0 ? result : 0.0)
                }
                function mt_product(args)
                {
                    return __productImp(args, true, true)
                }
                function mt_sqrt(args)
                {
                    var num = parseFloat(args[0]);
                    if (num >= 0)
                    {
                        return Math_sqrt(num)
                    }
                    else
                    {
                        return CalcErrorsNumber
                    }
                }
                function mt_quotient(args)
                {
                    if (CalcConvert.err(args[0]))
                    {
                        return args[0]
                    }
                    if (CalcConvert.err(args[1]))
                    {
                        return args[1]
                    }
                    var num = CalcConvert.D(args[0]);
                    var denom = CalcConvert.D(args[1]);
                    if (isNaN(num) || isNaN(denom))
                    {
                        return CalcErrorsValue
                    }
                    if (denom === 0.0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    return parseInt((num / denom).toString(), 10)
                }
                function mt_subtotal(args)
                {
                    var number = CalcConvert.I(args[0]);
                    var list = [];
                    for (var i = 1; i < args.length; i++)
                    {
                        list[i - 1] = args[i]
                    }
                    var Functions = Calc.Functions;
                    var _StatHelper = Functions._StatHelper;
                    if (number === 1 || number === 101)
                    {
                        return _StatHelper.__averageIncludeSubtotals(list, false, number === 1)
                    }
                    else if (number === 2 || number === 102)
                    {
                        return _StatHelper.__countIncludeSubtotals(list, false, number === 2)
                    }
                    else if (number === 3 || number === 103)
                    {
                        return _StatHelper.__countaIncludeSubtotals(list, false, number === 3)
                    }
                    else if (number === 4 || number === 104)
                    {
                        return _StatHelper.__maxIncludeSubtotals(list, false, number === 4)
                    }
                    else if (number === 5 || number === 105)
                    {
                        return _StatHelper.__minIncludeSubtotals(list, false, number === 5)
                    }
                    else if (number === 6 || number === 106)
                    {
                        return __productImp(list, false, number === 6)
                    }
                    else if (number === 7 || number === 107)
                    {
                        return _StatHelper.__stdevIncludeSubtotals(list, false, number === 7)
                    }
                    else if (number === 8 || number === 108)
                    {
                        return _StatHelper.__stdevpIncludeSubtotals(list, false, number === 8)
                    }
                    else if (number === 9 || number === 109)
                    {
                        return _StatHelper.__sumIncludeSubtotals(list, false, number === 9)
                    }
                    else if (number === 10 || number === 110)
                    {
                        return _StatHelper.__varrIncludeSubtotals(list, false, number === 10)
                    }
                    else if (number === 11 || number === 111)
                    {
                        return _StatHelper.__varpIncludeSubtotals(list, false, number === 11)
                    }
                    return CalcErrorsValue
                }
                function mt_floor(args)
                {
                    var num = CalcConvert.D(args[0]);
                    var sign = CalcConvert.D(args[1]);
                    if (isNaN(num) || isNaN(sign))
                    {
                        return CalcErrorsValue
                    }
                    if (num === 0.0 || sign === 0.0)
                    {
                        return 0.0
                    }
                    if (num > 0.0 && sign < 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    var _MathHelper = Functions._MathHelper;
                    if (num < 0.0 && 0.0 < sign)
                    {
                        sign = -sign;
                        return _MathHelper.approxCeiling(num / sign) * sign
                    }
                    return _MathHelper.approxFloor(num / sign) * sign
                }
                function mt_mround(args)
                {
                    var number = CalcConvert.D(args[0]);
                    var multiple = CalcConvert.D(args[1]);
                    if (isNaN(number) || isNaN(multiple))
                    {
                        return CalcErrorsValue
                    }
                    if (number === 0.0 || multiple === 0.0)
                    {
                        return 0.0
                    }
                    if ((number < 0.0 && 0.0 < multiple) || (multiple < 0.0 && 0.0 < number))
                    {
                        return CalcErrorsNumber
                    }
                    return Functions._MathHelper.approxFloor(number / multiple + 0.5) * multiple
                }
                function mt_round(args)
                {
                    var number = CalcConvert.D(args[0]);
                    if (isNaN(number))
                    {
                        return CalcErrorsValue
                    }
                    var digits = CalcConvert.I(args[1]);
                    var _MathHelper = Functions._MathHelper;
                    var power = _MathHelper.pow10(Math_abs(digits));
                    if (digits < 0)
                    {
                        number /= power
                    }
                    else
                    {
                        number *= power
                    }
                    if (number < 0.0)
                    {
                        number = _MathHelper.approxCeiling(number - 0.5)
                    }
                    else
                    {
                        number = _MathHelper.approxFloor(number + 0.5)
                    }
                    if (digits < 0)
                    {
                        number *= power
                    }
                    else
                    {
                        number /= power
                    }
                    return CalcConvert.toResult(number)
                }
                function mt_rounddown(args)
                {
                    var number = CalcConvert.D(args[0]);
                    if (isNaN(number))
                    {
                        return CalcErrorsValue
                    }
                    var digits = CalcConvert.I(args[1]);
                    var _MathHelper = Functions._MathHelper;
                    var power = _MathHelper.pow10(Math_abs(digits));
                    if (digits < 0)
                    {
                        number /= power
                    }
                    else
                    {
                        number *= power
                    }
                    if (number < 0.0)
                    {
                        number = _MathHelper.approxCeiling(number)
                    }
                    else
                    {
                        number = _MathHelper.approxFloor(number)
                    }
                    if (digits < 0)
                    {
                        number *= power
                    }
                    else
                    {
                        number /= power
                    }
                    return CalcConvert.toResult(number)
                }
                function mt_roundup(args)
                {
                    var number = CalcConvert.D(args[0]);
                    if (isNaN(number))
                    {
                        return CalcErrorsValue
                    }
                    var digits = CalcConvert.I(args[1]);
                    var _MathHelper = Functions._MathHelper;
                    var power = _MathHelper.pow10(Math_abs(digits));
                    if (digits < 0)
                    {
                        number /= power
                    }
                    else
                    {
                        number *= power
                    }
                    if (number < 0.0)
                    {
                        number = _MathHelper.approxFloor(number)
                    }
                    else
                    {
                        number = _MathHelper.approxCeiling(number)
                    }
                    if (digits < 0)
                    {
                        number *= power
                    }
                    else
                    {
                        number /= power
                    }
                    return CalcConvert.toResult(number)
                }
                function mt_trunc(args)
                {
                    var number = CalcConvert.D(args[0]);
                    if (isNaN(number))
                    {
                        return CalcErrorsValue
                    }
                    var digits = Calc._Helper._argumentExists(args, 1) ? CalcConvert.I(args[1]) : 0;
                    var _MathHelper = Functions._MathHelper;
                    var power = _MathHelper.pow10(Math_abs(digits));
                    if (digits < 0)
                    {
                        number /= power
                    }
                    else
                    {
                        number *= power
                    }
                    if (number < 0.0)
                    {
                        number = _MathHelper.approxCeiling(number)
                    }
                    else
                    {
                        number = _MathHelper.approxFloor(number)
                    }
                    if (digits < 0)
                    {
                        number *= power
                    }
                    else
                    {
                        number /= power
                    }
                    return CalcConvert.toResult(number)
                }
                function mt_exp(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_exp(d))
                }
                function mt_ceilingprecise(args)
                {
                    var num = CalcConvert.D(args[0]);
                    var sign;
                    if (Calc._Helper._argumentExists(args, 1))
                    {
                        sign = CalcConvert.D(args[1]);
                        if (isNaN(sign))
                        {
                            return CalcErrorsValue
                        }
                    }
                    else
                    {
                        sign = 1.0
                    }
                    if (num == 0.0 || sign == 0.0)
                    {
                        return 0.0
                    }
                    return Functions._MathHelper.approxCeiling(num / Math_abs(sign)) * Math_abs(sign)
                }
                function mt_floorprecise(args)
                {
                    var num = CalcConvert.D(args[0]);
                    var sign = Calc._Helper._argumentExists(args, 1) ? CalcConvert.D(args[1]) : 1.0;
                    if (num == 0.0 || sign == 0.0)
                    {
                        return 0.0
                    }
                    return Functions._MathHelper.approxFloor(num / Math_abs(sign)) * Math_abs(sign)
                }
                var MathEx = (function()
                    {
                        function MathEx(){}
                        MathEx.log = function(a, base)
                        {
                            if (isNaN(a))
                            {
                                return a
                            }
                            if (isNaN(base))
                            {
                                return base
                            }
                            if (base !== 1.0 && a === 1.0 || base !== 0.0 && (base !== Number.POSITIVE_INFINITY))
                            {
                                return (Math_log(a) / Math_log(base))
                            }
                            return NaN
                        };
                        MathEx.log10 = function(num)
                        {
                            return MathEx.log(num, 10)
                        };
                        return MathEx
                    })();
                function mt_log(args)
                {
                    var num = CalcConvert.D(args[0]);
                    if (isNaN(num))
                    {
                        return CalcErrorsValue
                    }
                    var newBase;
                    if (Calc._Helper._argumentExists(args, 1))
                    {
                        newBase = CalcConvert.D(args[1]);
                        if (isNaN(newBase))
                        {
                            return CalcErrorsValue
                        }
                    }
                    else
                    {
                        newBase = 10.0
                    }
                    if (num <= 0.0 || newBase <= 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    if (newBase === 1.0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    return CalcConvert.toResult(MathEx.log(num, newBase))
                }
                function mt_log10(args)
                {
                    var num = CalcConvert.D(args[0]);
                    if (isNaN(num))
                    {
                        return CalcErrorsValue
                    }
                    if (num <= 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(MathEx.log10(num))
                }
                function _evaluateSingleCriteria(criteria, range, sumRange)
                {
                    var sum = 0.0;
                    if (criteria === keyword_undefined || criteria === keyword_null)
                    {
                        return sum
                    }
                    var criteriaFun = Functions._MathHelper.parseCriteria(criteria);
                    var rangeIsArray = CalcConvert.arr(range);
                    var sumRangeIsArray = CalcConvert.arr(sumRange);
                    var rangeArray = range;
                    var rangeRef = range;
                    var sumRangeArray = sumRange;
                    var sumRangeRef = sumRange;
                    var rangeCount = rangeIsArray ? 1 : rangeRef.getRangeCount();
                    if (rangeCount != (sumRangeIsArray ? 1 : sumRangeRef.getRangeCount()))
                    {
                        return CalcErrorsValue
                    }
                    var rowCount = rangeIsArray ? rangeArray.getRowCount() : rangeRef.getRowCount(0);
                    if (rowCount != (sumRangeIsArray ? sumRangeArray.getRowCount() : sumRangeRef.getRowCount(0)))
                    {
                        return CalcErrorsValue
                    }
                    var colCount = rangeIsArray ? rangeArray.getColumnCount() : rangeRef.getColumnCount(0);
                    if (colCount != (sumRangeIsArray ? sumRangeArray.getColumnCount() : sumRangeRef.getColumnCount(0)))
                    {
                        return CalcErrorsValue
                    }
                    var rangeA = range.toArray(0, true, true);
                    if (rangeA.isError)
                    {
                        return rangeA[0]
                    }
                    var sumRangeA = sumRange.toArray(1, true, true);
                    if (sumRangeA.isError)
                    {
                        return sumRangeA[0]
                    }
                    for (var i = 0; i < rangeA.length; i++)
                    {
                        var val = rangeA[i];
                        if (criteriaFun && criteriaFun(val))
                        {
                            var obj = sumRangeA[i];
                            sum += obj
                        }
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sumif(args)
                {
                    var range = args[0];
                    var criteria = args[1];
                    if (criteria === keyword_undefined || criteria === keyword_null)
                    {
                        throw Sheets.SR.Exp_CriteriaIsNull;
                    }
                    var sumRange = Calc._Helper._argumentExists(args, 2) ? args[2] : args[0];
                    var critieriaRef = args[1];
                    var rowCount,
                        colCount;
                    if (CalcConvert.ref(critieriaRef))
                    {
                        rowCount = critieriaRef.getRowCount(0);
                        colCount = critieriaRef.getColumnCount(0);
                        if (rowCount === 1 && colCount === 1)
                        {
                            return _evaluateSingleCriteria(critieriaRef.getValue(0, 0, 0), range, sumRange)
                        }
                        return new Calc._TernaryCompositeConcreteReference(critieriaRef.getSource(), critieriaRef.getRow(0), critieriaRef.getColumn(0), rowCount, colCount, _evaluateSingleCriteria, range, sumRange)
                    }
                    var criteriaArray = args[1];
                    if (CalcConvert.arr(criteriaArray))
                    {
                        rowCount = criteriaArray.getRowCount();
                        colCount = criteriaArray.getColumnCount();
                        var result = new Calc._ConcreteArray(criteriaArray, colCount);
                        for (var r = 0; r < rowCount; r++)
                        {
                            for (var c = 0; c < colCount; c++)
                            {
                                result._array[r][c] = _evaluateSingleCriteria(criteriaArray.getValue(r, c), range, sumRange)
                            }
                        }
                        return result
                    }
                    return _evaluateSingleCriteria(criteria, range, sumRange)
                }
                function mt_sumifs(args)
                {
                    var sum = 0.0;
                    var sumRange = CalcConvert.toArr(args[0], 1, true, true, false);
                    if (sumRange.isError)
                    {
                        return sumRange[0]
                    }
                    var length = sumRange.length,
                        rowCount = sumRange.rowCount,
                        colCount = sumRange.colCount;
                    var ranges = [];
                    var criteriaFuns = [];
                    for (var j = 1; j < args.length; j = j + 2)
                    {
                        var range = CalcConvert.toArr(args[j], 0, true, false, false);
                        if (range.rowCount !== rowCount || range.colCount !== colCount)
                        {
                            return CalcErrorsValue
                        }
                        var criteria = args[j + 1];
                        var criteriaFun = Functions._MathHelper.parseCriteria(criteria);
                        ranges.push(range);
                        criteriaFuns.push(criteriaFun)
                    }
                    var criteriaLength = ranges.length;
                    for (var i = 0; i < length; i++)
                    {
                        var condition = true;
                        for (var j = 0; j < criteriaLength; j++)
                        {
                            var range = ranges[j];
                            var criteriaFun = criteriaFuns[j];
                            var obj1 = range[i];
                            condition = criteriaFun && criteriaFun(obj1);
                            if (!condition)
                            {
                                break
                            }
                        }
                        if (condition)
                        {
                            var obj = sumRange[i];
                            if (obj !== CalcConvert.CalcConvertedError)
                            {
                                sum += obj
                            }
                        }
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sumproduct(args)
                {
                    var sum = 0.0;
                    var convert = CalcConvert,
                        argsArray = [];
                    ;
                    var rowCount,
                        columnCount,
                        length;
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 1, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        if (i == 0)
                        {
                            rowCount = array.rowCount;
                            columnCount = array.colCount;
                            length = array.length
                        }
                        else if (array.rowCount !== rowCount || array.colCount !== columnCount)
                        {
                            return CalcErrorsValue
                        }
                        argsArray.push(array)
                    }
                    for (var i = 0; i < length; i++)
                    {
                        var product = 1.0;
                        for (var argIndex = 0; argIndex < args.length; argIndex++)
                        {
                            var o = argsArray[argIndex][i];
                            if (o !== CalcConvert.CalcConvertedError)
                            {
                                product *= o
                            }
                            else
                            {
                                product = 0.0;
                                break
                            }
                        }
                        sum += product
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sumsq(args)
                {
                    var x;
                    var sumx2 = 0.0;
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 1, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            x = array[j];
                            if (x !== CalcConvert.CalcConvertedError)
                            {
                                sumx2 += x * x
                            }
                        }
                    }
                    return CalcConvert.toResult(sumx2)
                }
                function mt_sumx2my2(args)
                {
                    var sum = 0.0;
                    var x;
                    var y;
                    var array1 = CalcConvert.toArr(args[0], 1, true, true, false);
                    if (array1.isError)
                    {
                        return array1[0]
                    }
                    if (array1.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    var array2 = CalcConvert.toArr(args[1], 1, true, true, false);
                    if (array2.isError)
                    {
                        return array2[0]
                    }
                    if (array2.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    if (array1.length !== array2.length)
                    {
                        return CalcErrorsNotAvailable
                    }
                    for (var i = 0; i < array1.length; i++)
                    {
                        x = array1[i];
                        y = array2[i];
                        if (x !== CalcConvert.CalcConvertedError && y !== CalcConvert.CalcConvertedError)
                        {
                            sum += x * x - y * y
                        }
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sumx2py2(args)
                {
                    var sum = 0.0;
                    var x;
                    var y;
                    var array1 = CalcConvert.toArr(args[0], 1, true, true, false);
                    if (array1.isError)
                    {
                        return array1[0]
                    }
                    if (array1.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    var array2 = CalcConvert.toArr(args[1], 1, true, true, false);
                    if (array2.isError)
                    {
                        return array2[0]
                    }
                    if (array2.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    if (array1.length !== array2.length)
                    {
                        return CalcErrorsNotAvailable
                    }
                    for (var i = 0; i < array1.length; i++)
                    {
                        x = array1[i];
                        y = array2[i];
                        if (x !== CalcConvert.CalcConvertedError && y !== CalcConvert.CalcConvertedError)
                        {
                            sum += x * x + y * y
                        }
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sumxmy2(args)
                {
                    var sum = 0.0;
                    var x;
                    var y;
                    var array1 = CalcConvert.toArr(args[0], 1, true, true, false);
                    if (array1.isError)
                    {
                        return array1[0]
                    }
                    if (array1.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    var array2 = CalcConvert.toArr(args[1], 1, true, true, false);
                    if (array2.isError)
                    {
                        return array2[0]
                    }
                    if (array2.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    if (array1.length !== array2.length)
                    {
                        return CalcErrorsNotAvailable
                    }
                    for (var i = 0; i < array1.length; i++)
                    {
                        x = array1[i];
                        y = array2[i];
                        if (x !== CalcConvert.CalcConvertedError && y !== CalcConvert.CalcConvertedError)
                        {
                            sum += (x - y) * (x - y)
                        }
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_seriessum(args)
                {
                    var x;
                    var m,
                        n;
                    if (isNaN(x = CalcConvert.D(args[0])) || isNaN(n = CalcConvert.I(args[1])) || isNaN(m = CalcConvert.I(args[2])))
                    {
                        return CalcErrorsValue
                    }
                    var coeff = CalcConvert.toArr(args[3], 1, true, true, true);
                    if (coeff.isError)
                    {
                        return coeff[0]
                    }
                    if (coeff.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    var sum = 0.0;
                    for (var i = 0; i < coeff.length; i++)
                    {
                        var a;
                        if (isNaN(a = CalcConvert.D(coeff[i])))
                        {
                            return CalcErrorsValue
                        }
                        sum += a * Math_pow(x, n + i * m)
                    }
                    return CalcConvert.toResult(sum)
                }
                function mt_sqrtpi(args)
                {
                    var number;
                    if (isNaN(number = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    if (number < 0.0)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_sqrt(number * Math_PI))
                }
                function mt_radians(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return Math_PI * d / 180.0
                }
                function mt_cos(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_cos(d))
                }
                function mt_acos(args)
                {
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    if (num < -1.0 || 1.0 < num)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_acos(num))
                }
                function mt_cosh(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult((Math_exp(d) + Math_exp(-d)) / 2)
                }
                function mt_acosh(args)
                {
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    if (num < 1.0)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_log(num + Math_sqrt(num * num - 1.0)))
                }
                function mt_sin(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_sin(d))
                }
                function mt_asin(args)
                {
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    if (num < -1.0 || 1.0 < num)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_asin(num))
                }
                function mt_sinh(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult((Math_exp(d) - Math_exp(-d)) / 2)
                }
                function mt_asinh(args)
                {
                    var number;
                    if (isNaN(number = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_log(number + Math_sqrt(number * number + 1.0)))
                }
                function mt_tan(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_tan(d))
                }
                function mt_atan(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return CalcConvert.toResult(Math_atan(d))
                }
                function mt_atan2(args)
                {
                    var x,
                        y;
                    if (isNaN(x = CalcConvert.D(args[0])) || isNaN(y = CalcConvert.D(args[1])))
                    {
                        return CalcErrorsValue
                    }
                    if (x === 0.0 && y === 0.0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    return CalcConvert.toResult(Math_atan2(y, x))
                }
                function mt_tanh(args)
                {
                    var d;
                    if (isNaN(d = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    var x = Math_exp(d);
                    var y = Math_exp(-d);
                    return CalcConvert.toResult(x - y) / (x + y)
                }
                function mt_atanh(args)
                {
                    var number;
                    if (isNaN(number = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    if (number <= -1.0 || 1.0 <= number)
                    {
                        return CalcErrorsNumber
                    }
                    return CalcConvert.toResult(Math_log((1.0 + number) / (1.0 - number)) / 2.0)
                }
                function mt_mdeterm(args)
                {
                    var Convert = CalcConvert,
                        errorObject = CalcConvert.CalcConvertedError;
                    var array = CalcConvert.toArr(args[0], 1, false, true, true);
                    if (array.isError)
                    {
                        return array[0]
                    }
                    if (array.rangeCount > 1 || array.rowCount !== array.colCount)
                    {
                        return CalcErrorsValue
                    }
                    var dim = array.rowCount;
                    var result = 1.0;
                    for (var i2 = 0; i2 < dim - 1; i2++)
                    {
                        if (array[i2][i2] === 0.0)
                        {
                            var found = false;
                            for (var j2 = i2 + 1; !found && j2 < dim; j2++)
                            {
                                if (array[j2][i2] !== 0.0)
                                {
                                    for (var k1 = i2; k1 < dim; k1++)
                                    {
                                        var temp = array[i2][k1];
                                        array[i2][k1] = array[j2][k1];
                                        array[j2][k1] = temp
                                    }
                                    result *= -1.0;
                                    found = true
                                }
                            }
                            if (!found)
                            {
                                return 0.0
                            }
                        }
                        for (var j3 = i2 + 1; j3 < dim; j3++)
                        {
                            if (array[j3][i2] !== 0.0)
                            {
                                var factor = array[j3][i2] / array[i2][i2];
                                for (var k2 = i2; k2 < dim; k2++)
                                {
                                    array[j3][k2] -= factor * array[i2][k2]
                                }
                            }
                        }
                    }
                    for (var i = 0; i < dim; i++)
                    {
                        result *= array[i][i]
                    }
                    return result
                }
                function mt_minverse(args)
                {
                    var Convert = CalcConvert,
                        errorObject = CalcConvert.CalcConvertedError;
                    var array = CalcConvert.toArr(args[0], 1, false, true, true);
                    if (array.isError)
                    {
                        return array[0]
                    }
                    if (array.rangeCount > 1 || array.rowCount !== array.colCount)
                    {
                        return CalcErrorsValue
                    }
                    var dim = array.rowCount;
                    var b = [];
                    for (var i1 = 0; i1 < dim; i1++)
                    {
                        b[i1] = [dim];
                        for (var j1 = 0; j1 < dim; j1++)
                        {
                            b[i1][j1] = i1 === j1 ? 1.0 : 0.0
                        }
                    }
                    for (var i2 = 0; i2 < dim; i2++)
                    {
                        if (array[i2][i2] === 0.0)
                        {
                            var found = false;
                            for (var j2 = i2 + 1; !found && j2 < dim; j2++)
                            {
                                if (array[j2][i2] !== 0.0)
                                {
                                    for (var k = i2; k < dim; k++)
                                    {
                                        var temp = array[i2][k];
                                        array[i2][k] = array[j2][k];
                                        array[j2][k] = temp
                                    }
                                    for (var k1 = 1; k1 < dim; k1++)
                                    {
                                        var temp1 = b[i2][k1];
                                        b[i2][k1] = b[j2][k1];
                                        b[j2][k1] = temp1
                                    }
                                    found = true
                                }
                            }
                            if (!found)
                            {
                                return CalcErrorsNumber
                            }
                        }
                        for (var j3 = 0; j3 < dim; j3++)
                        {
                            if (j3 !== i2 && array[j3][i2] !== 0.0)
                            {
                                var factor = array[j3][i2] / array[i2][i2];
                                for (var k2 = i2; k2 < dim; k2++)
                                {
                                    array[j3][k2] -= factor * array[i2][k2]
                                }
                                for (var k3 = 0; k3 < dim; k3++)
                                {
                                    b[j3][k3] -= factor * b[i2][k3]
                                }
                            }
                        }
                    }
                    for (var i3 = 0; i3 < dim; i3++)
                    {
                        var factor1 = array[i3][i3];
                        for (var k4 = 0; k4 < dim; k4++)
                        {
                            b[i3][k4] /= factor1
                        }
                    }
                    return new Calc._ConcreteArray(b)
                }
                function mt_mmult(args)
                {
                    var arrayA = CalcConvert.toArr(args[0], 1, false, true, true);
                    var arrayB = CalcConvert.toArr(args[1], 1, false, true, true);
                    if (arrayA.isError || arrayB.isError)
                    {
                        return arrayA.isError ? arrayA[0] : arrayB[0]
                    }
                    var rowCountA = arrayA.rowCount;
                    var columnCountA = arrayA.colCount;
                    var rowCountB = arrayB.rowCount;
                    var columnCountB = arrayB.colCount;
                    if (arrayA.isConvertError || arrayB.isConvertError || columnCountA !== rowCountB)
                    {
                        return CalcErrorsValue
                    }
                    var result = [],
                        resultRow,
                        rowA;
                    for (var i2 = 0; i2 < rowCountA; i2++)
                    {
                        result[i2] = resultRow = [];
                        rowA = arrayA[i2];
                        for (var j2 = 0; j2 < columnCountB; j2++)
                        {
                            var sum = 0.0;
                            for (var k = 0; k < rowCountB; k++)
                            {
                                sum += rowA[k] * arrayB[k][j2]
                            }
                            resultRow[j2] = sum
                        }
                    }
                    return new Calc._ConcreteArray(result)
                }
                function __fact(x)
                {
                    var result = 1.0;
                    for (var i = x; i > 1; i--)
                    {
                        result *= i
                    }
                    return result
                }
                function mt_multinomial(args)
                {
                    var sumx = 0;
                    var prod = 1.0;
                    var convert = CalcConvert,
                        array;
                    for (var i = 0; i < args.length; i++)
                    {
                        array = CalcConvert.toArr(args[i], 0, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            var obj = array[j];
                            var x = CalcConvert.I(obj);
                            if (x < 0 || 170 < x)
                            {
                                return CalcErrorsNumber
                            }
                            sumx += x;
                            prod *= __fact(x)
                        }
                    }
                    if (sumx < 0 || 170 < sumx)
                    {
                        return CalcErrorsNumber
                    }
                    return __fact(sumx) / prod
                }
                function mt_rand(args)
                {
                    var random = Math_random();
                    var result = -1 + random * 2;
                    return Math_abs(result)
                }
                function mt_randbetween(args)
                {
                    if (CalcConvert.err(args[1]))
                    {
                        return args[1]
                    }
                    if (CalcConvert.err(args[0]))
                    {
                        return args[0]
                    }
                    var min,
                        max;
                    if (isNaN(min = CalcConvert.I(args[0])) || isNaN(max = CalcConvert.I(args[1])))
                    {
                        return CalcErrorsValue
                    }
                    if (max < min)
                    {
                        return CalcErrorsNumber
                    }
                    var random = Math_random();
                    return CalcConvert.I(min + random * (max - min + 1))
                }
                function _getInfoList()
                {
                    var info = [];
                    info.push(new KeyValuePair('M', 1000));
                    info.push(new KeyValuePair('D', 500));
                    info.push(new KeyValuePair('C', 100));
                    info.push(new KeyValuePair('L', 50));
                    info.push(new KeyValuePair('X', 10));
                    info.push(new KeyValuePair('V', 5));
                    info.push(new KeyValuePair('I', 1));
                    return info
                }
                function mt_roman(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    if (CalcConvert.err(args[0]))
                    {
                        return args[0]
                    }
                    var number = CalcConvert.I(args[0]);
                    var form = 0;
                    if (_Helper._argumentExists(args, 1))
                    {
                        if (CalcConvert.err(args[1]))
                        {
                            return args[1]
                        }
                        form = typeof(args[1]) === 'boolean' ? (args[1] ? 0 : 4) : CalcConvert.I(args[1])
                    }
                    var sb = [];
                    if (number < 0 || 3999 < number || form < 0 || 4 < form)
                    {
                        return CalcErrorsValue
                    }
                    var info = _getInfoList();
                    for (var i = 0; i < info.length; i += 2)
                    {
                        if (2 <= i && info[i - 2].Value - info[i].Value <= number)
                        {
                            var i1 = i;
                            var i2 = i - 2;
                            for (var step = 0; step < form && i1 + 1 < info.length && info[i2].Value - info[i1 + 1].Value <= number; step++)
                            {
                                i1++
                            }
                            sb.push(info[i1].Key);
                            sb.push(info[i2].Key);
                            number += info[i1].Value;
                            number -= info[i2].Value
                        }
                        if (1 <= i && info[i - 1].Value <= number)
                        {
                            sb.push(info[i - 1].Key);
                            number -= info[i - 1].Value
                        }
                        if (1 <= i && info[i - 1].Value - info[i].Value <= number)
                        {
                            var i21 = i;
                            var i22 = i - 1;
                            for (var step1 = 0; step1 < form && i21 + 1 < info.length && info[i22].Value - info[i21 + 1].Value <= number; step1++)
                            {
                                i21++
                            }
                            sb.push(info[i21].Key);
                            sb.push(info[i22].Key);
                            number += info[i21].Value;
                            number -= info[i22].Value
                        }
                        while (info[i].Value <= number)
                        {
                            sb.push(info[i].Key);
                            number -= info[i].Value
                        }
                    }
                    return sb.join('')
                }
                function lg_and(args)
                {
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 3, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        else if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            if (!array[j])
                            {
                                return false
                            }
                        }
                    }
                    return true
                }
                function lg_or(args)
                {
                    for (var i = 0; i < args.length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 3, true, true, false);
                        if (array.isError)
                        {
                            return array[0]
                        }
                        else if (array.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                        for (var j = 0; j < array.length; j++)
                        {
                            if (array[j] && array[j] !== CalcConvert.CalcConvertedError)
                            {
                                return true
                            }
                        }
                    }
                    return false
                }
                function _not$evaluateSingleValue(value)
                {
                    try
                    {
                        var result = CalcConvert.B(value);
                        return !result
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function lg_not(args)
                {
                    if (CalcConvert.ref(args[0]))
                    {
                        if (args[0].getRangeCount() > 1)
                        {
                            return CalcErrorsValue
                        }
                        return new Calc._UnaryCompositeConcreteReference(args[0].getSource(), args[0].getRow(0), args[0].getColumn(0), args[0].getRowCount(0), args[0].getColumnCount(0), _not$evaluateSingleValue)
                    }
                    if (CalcConvert.arr(args[0]))
                    {
                        var result = [];
                        var rowCount = args[0].getRowCount();
                        var columnCount = args[0].getColumnCount();
                        for (var i = 0; i < rowCount; i++)
                        {
                            result[i] = [columnCount];
                            for (var j = 0; j < columnCount; j++)
                            {
                                var val = args[0].getValue(i, j);
                                var type = typeof val;
                                if (type === const_boolean || type === const_number)
                                {
                                    result[i][j] = !val
                                }
                                else
                                {
                                    result[i][j] = CalcErrorsValue
                                }
                            }
                        }
                        return new Calc._ConcreteArray(result)
                    }
                    return _not$evaluateSingleValue(args[0])
                }
                function _if$evaluateSingleValue(arg0, arg1, arg2)
                {
                    try
                    {
                        var condition = CalcConvert.B(arg0);
                        return condition ? arg1 : arg2
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function lg_if(args)
                {
                    var arg0 = args[0];
                    var arg1 = args[1];
                    var _Helper = Calc._Helper;
                    var arg2 = _Helper._argumentExists(args, 2) ? args[2] : (args.length === 2 ? false : 0);
                    var val = _Helper.tryExtractToSingleValue(arg0);
                    if (val.success)
                    {
                        arg0 = val.value;
                        return _if$evaluateSingleValue(arg0, arg1, arg2)
                    }
                    val = _Helper.tryExtractToSingleValue(arg1);
                    arg1 = val.value;
                    var isArg1Simple = val.success;
                    val = _Helper.tryExtractToSingleValue(arg2);
                    arg2 = val.value;
                    var isArg2Simple = val.success;
                    var rowCount = arg0.getRowCount();
                    var columnCount = arg0.getColumnCount();
                    var result = [];
                    for (var i = 0; i < rowCount; i++)
                    {
                        result[i] = [columnCount];
                        for (var j = 0; j < columnCount; j++)
                        {
                            result[i][j] = _if$evaluateSingleValue(arg0.getValue(i, j), isArg1Simple ? arg1 : _Helper.getArrayValue(arg1, i, j), isArg2Simple ? arg2 : _Helper.getArrayValue(arg2, i, j))
                        }
                    }
                    return new Calc._ConcreteArray(result)
                }
                function _iferror$evaluateSingle(value, valueIfError)
                {
                    return (CalcConvert.err(value)) ? ((valueIfError !== keyword_undefined && valueIfError !== keyword_null) ? valueIfError : 0) : ((value !== keyword_undefined && value !== keyword_null) ? value : 0)
                }
                function lg_iferror(args)
                {
                    var isError = CalcConvert.err(args[0]);
                    if (!isError && CalcConvert.ref(args[0]))
                    {
                        var arg0Ref = args[0];
                        if (arg0Ref.getRangeCount() > 1)
                        {
                            return CalcErrorsValue
                        }
                        return new Calc._BinaryCompositeConcreteReference(arg0Ref.getSource(), arg0Ref.getRow(0), arg0Ref.getColumn(0), arg0Ref.getRowCount(0), arg0Ref.getColumnCount(0), _iferror$evaluateSingle, args[1])
                    }
                    return isError ? ((args[1] !== keyword_undefined && args[1] !== keyword_null) ? args[1] : 0) : ((args[0] !== keyword_undefined && args[0] !== keyword_null) ? args[0] : 0)
                }
                function lg_true(args)
                {
                    return true
                }
                function lg_false(args)
                {
                    return false
                }
                function dt_date(args)
                {
                    try
                    {
                        var year,
                            month,
                            day;
                        if (isNaN(year = CalcConvert.I(args[0])) || isNaN(month = CalcConvert.I(args[1])) || isNaN(day = CalcConvert.I(args[2])))
                        {
                            return CalcErrorsValue
                        }
                        if (year < 0 || 9999 < year)
                        {
                            return CalcErrorsNumber
                        }
                        if (year <= 1899)
                        {
                            year += 1900
                        }
                        var date = new Date(year, month - 1, day);
                        if (date < new Date(1899, 11, 30))
                        {
                            return CalcErrorsNumber
                        }
                        return date
                    }
                    catch(err)
                    {
                        return CalcErrorsNumber
                    }
                }
                function dt_time(args)
                {
                    var hour,
                        minute,
                        second;
                    try
                    {
                        if (isNaN(hour = CalcConvert.I(args[0])) || isNaN(minute = CalcConvert.I(args[1])) || isNaN(second = CalcConvert.I(args[2])))
                        {
                            return CalcErrorsValue
                        }
                        var time = GcSpread.Sheets._DateTimeHelper.fromOADate(0);
                        time.setHours(hour);
                        time.setMinutes(minute);
                        time.setSeconds(second);
                        time.setMilliseconds(0);
                        if (time.getHours() < 0 && time.getMinutes() < 0 && time.getSeconds() < 0)
                        {
                            return CalcErrorsNumber
                        }
                        return time
                    }
                    catch(err)
                    {
                        return CalcErrorsNumber
                    }
                }
                function _isLeapYear(year)
                {
                    return (year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)) || year === 1900
                }
                function dt_datevalue(args)
                {
                    var text = CalcConvert.S(args[0]);
                    if (text === keyword_undefined || text === keyword_null || text === '')
                    {
                        return CalcErrorsValue
                    }
                    try
                    {
                        var date = GcSpread.Sheets._DateTimeHelper.parseLocale(text);
                        var year = date.getFullYear();
                        if (year < 1900)
                        {
                            return CalcErrorsValue
                        }
                        var month = date.getMonth();
                        var day = date.getDate();
                        var days = 0;
                        for (var i = 1900; i < year; i++)
                        {
                            if (_isLeapYear(i))
                            {
                                days += 366
                            }
                            else
                            {
                                days += 365
                            }
                        }
                        for (var i1 = 0; i1 < month; i1++)
                        {
                            switch (i1)
                            {
                                case 0:
                                case 2:
                                case 4:
                                case 6:
                                case 7:
                                case 9:
                                case 11:
                                    days += 31;
                                    break;
                                case 1:
                                    if (_isLeapYear(year))
                                    {
                                        days += 29
                                    }
                                    else
                                    {
                                        days += 28
                                    }
                                    break;
                                case 3:
                                case 5:
                                case 8:
                                case 10:
                                    days += 30;
                                    break
                            }
                        }
                        days += day;
                        return days
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function __parseTime(text)
                {
                    try
                    {
                        return GcSpread.Sheets._DateTimeHelper.parseLocale(text)
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_timevalue(args)
                {
                    var text = CalcConvert.S(args[0]);
                    if (text === keyword_undefined || text === keyword_null || text === '')
                    {
                        return CalcErrorsValue
                    }
                    try
                    {
                        var time = __parseTime(text);
                        var totalSeconds = ((time.getHours() * 60) + time.getMinutes()) * 60 + time.getSeconds();
                        var allSecondsADay = 24 * 3600;
                        return totalSeconds / allSecondsADay
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_now(args)
                {
                    return new Date
                }
                function dt_today(args)
                {
                    var date = new Date;
                    date.setHours(0);
                    date.setMinutes(0);
                    date.setSeconds(0);
                    date.setMilliseconds(0);
                    return date
                }
                function dt_hour(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getHours()
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_minute(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getMinutes()
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_second(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getSeconds()
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_day(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getDate()
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_month(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getMonth() + 1
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function dt_year(args)
                {
                    try
                    {
                        var dt = CalcConvert.DT(args[0]);
                        return dt.getFullYear()
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function _getDayOfYear(date)
                {
                    var year = date.getFullYear();
                    var month = date.getMonth();
                    var day = date.getDate();
                    var days = 0;
                    for (var i = 0; i < month; i++)
                    {
                        switch (i)
                        {
                            case 0:
                            case 2:
                            case 4:
                            case 6:
                            case 7:
                            case 9:
                            case 11:
                                days += 31;
                                break;
                            case 1:
                                if (_isLeapYear(year))
                                {
                                    days += 29
                                }
                                else
                                {
                                    days += 28
                                }
                                break;
                            case 3:
                            case 5:
                            case 8:
                            case 10:
                                days += 30;
                                break
                        }
                    }
                    days += day;
                    return days
                }
                function _getWeekOfYear(date, type)
                {
                    var days = _getDayOfYear(date);
                    var dayOfFirstDay = new Date(date.getFullYear(), 0, 1).getDay();
                    if (type === 2)
                    {
                        dayOfFirstDay -= 1;
                        if (dayOfFirstDay < 0)
                        {
                            dayOfFirstDay = 6
                        }
                    }
                    var dayDiff = days - 1 - (6 - dayOfFirstDay);
                    if (dayDiff < 0)
                    {
                        dayDiff = 0
                    }
                    return 1 + CalcConvert.I(dayDiff / 7) + ((dayDiff % 7 !== 0) ? 1 : 0)
                }
                function dt_weeknum(args)
                {
                    var date;
                    try
                    {
                        date = CalcConvert.DT(args[0])
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                    var type;
                    if (isNaN(type = CalcConvert.I(Calc._Helper._argumentExists(args, 1) ? args[1] : 1)))
                    {
                        return CalcErrorsValue
                    }
                    var cal;
                    switch (type)
                    {
                        case 1:
                        case 2:
                            return _getWeekOfYear(date, type);
                        default:
                            return CalcErrorsNumber
                    }
                }
                function dt_weekday(args)
                {
                    var dt;
                    try
                    {
                        dt = CalcConvert.DT(args[0])
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                    var type;
                    if (isNaN(type = CalcConvert.I(Calc._Helper._argumentExists(args, 1) ? args[1] : 1)))
                    {
                        return CalcErrorsValue
                    }
                    var result;
                    switch (type)
                    {
                        case 1:
                            result = dt.getDay() + 1;
                            break;
                        case 2:
                            if (dt.getDay() === 0)
                            {
                                result = 7
                            }
                            else
                            {
                                result = dt.getDay()
                            }
                            break;
                        case 3:
                            if (dt.getDay() === 0)
                            {
                                result = 6
                            }
                            else
                            {
                                result = dt.getDay() - 1
                            }
                            break;
                        default:
                            return CalcErrorsNumber
                    }
                    return result
                }
                function dt_edate(args)
                {
                    var startDate;
                    var months;
                    try
                    {
                        startDate = CalcConvert.DT(args[0])
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                    if (isNaN(months = CalcConvert.I(args[1])))
                    {
                        return CalcErrorsValue
                    }
                    startDate.setMonth(startDate.getMonth() + months);
                    return startDate
                }
                function _getDaysInMonth(year, month)
                {
                    switch (month)
                    {
                        case 0:
                        case 2:
                        case 4:
                        case 6:
                        case 7:
                        case 9:
                        case 11:
                            return 31;
                        case 1:
                            return _isLeapYear(year) ? 29 : 28;
                        case 3:
                        case 5:
                        case 8:
                        case 10:
                            return 30
                    }
                }
                function dt_eomonth(args)
                {
                    var startDate;
                    var months;
                    try
                    {
                        startDate = CalcConvert.DT(args[0])
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                    if (isNaN(months = CalcConvert.I(args[1])))
                    {
                        return CalcErrorsValue
                    }
                    startDate.setMonth(startDate.getMonth() + months);
                    var days = _getDaysInMonth(startDate.getFullYear(), startDate.getMonth());
                    startDate.setDate(days);
                    return startDate
                }
                function _compareDateTime(date1, date2)
                {
                    return date1 - date2
                }
                function _containsDate(array, date)
                {
                    var length = array.length;
                    for (var i = 0; i < length; i++)
                    {
                        var current = array[i];
                        if (_compareDateTime(current, date) === 0)
                        {
                            return true
                        }
                    }
                    return false
                }
                function dt_workday(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var date = CalcConvert.DT(args[0]);
                    var days = CalcConvert.I(args[1]);
                    var values = [];
                    if (_Helper._argumentExists(args, 2))
                    {
                        values = CalcConvert.toArr(args[2], 4, true, true, true);
                        if (values.isError)
                        {
                            return values[0]
                        }
                        if (values.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                    }
                    var array = [];
                    array[0] = date;
                    array[1] = 3;
                    var o = dt_weekday(array);
                    if (CalcConvert.err(o))
                    {
                        return o
                    }
                    var weekdayValue = CalcConvert.I(o);
                    for (; days < 0; ++days)
                    {
                        try
                        {
                            date.setDate(date.getDate() - 1)
                        }
                        catch(err)
                        {
                            return CalcErrorsNumber
                        }
                        if (weekdayValue === 0)
                        {
                            weekdayValue = 6
                        }
                        else
                        {
                            weekdayValue--
                        }
                        if (weekdayValue === 5 || weekdayValue === 6)
                        {
                            days--
                        }
                        else
                        {
                            if (values.indexOf(Sheets._DateTimeHelper.___toOADate(date)) >= 0)
                            {
                                days--
                            }
                        }
                    }
                    for (; days > 0; --days)
                    {
                        try
                        {
                            date.setDate(date.getDate() + 1)
                        }
                        catch(err1)
                        {
                            return CalcErrorsNumber
                        }
                        if (weekdayValue === 6)
                        {
                            weekdayValue = 0
                        }
                        else
                        {
                            weekdayValue++
                        }
                        if (weekdayValue === 5 || weekdayValue === 6)
                        {
                            days++
                        }
                        else
                        {
                            if (values.indexOf(Sheets._DateTimeHelper.___toOADate(date)) >= 0)
                            {
                                days++
                            }
                        }
                    }
                    return new GcSpread.Sheets._DateTimeHelper(date).toOADate()
                }
                function dt_workday_intl(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var date = CalcConvert.DT(args[0]);
                    var days = CalcConvert.I(args[1]);
                    var weekend = _Helper._argumentExists(args, 2) ? args[2] : "0000011";
                    var weekendMask = __caculateWeekendMask(weekend);
                    if (CalcConvert.err(weekendMask))
                    {
                        return weekendMask
                    }
                    var tempWeekendMask = weekendMask.join("");
                    if (tempWeekendMask === "1111111")
                    {
                        return CalcErrorsValue
                    }
                    var values = [];
                    if (_Helper._argumentExists(args, 3))
                    {
                        values = CalcConvert.toArr(args[3], 4, true, true, true);
                        if (values.isError)
                        {
                            return values[0]
                        }
                        if (values.isConvertError)
                        {
                            return CalcErrorsValue
                        }
                    }
                    var array = [];
                    array[0] = date;
                    array[1] = 3;
                    var o = dt_weekday(array);
                    if (CalcConvert.err(o))
                    {
                        return o
                    }
                    var weekdayValue = CalcConvert.I(o);
                    for (; days < 0; ++days)
                    {
                        try
                        {
                            date.setDate(date.getDate() - 1)
                        }
                        catch(err)
                        {
                            return CalcErrorsNumber
                        }
                        if (weekdayValue === 0)
                        {
                            weekdayValue = 6
                        }
                        else
                        {
                            weekdayValue--
                        }
                        if (weekendMask[weekdayValue])
                        {
                            days--
                        }
                        else
                        {
                            if (values.indexOf(Sheets._DateTimeHelper.___toOADate(date)) >= 0)
                            {
                                days--
                            }
                        }
                    }
                    for (; days > 0; --days)
                    {
                        try
                        {
                            date.setDate(date.getDate() + 1)
                        }
                        catch(err1)
                        {
                            return CalcErrorsNumber
                        }
                        if (weekdayValue === 6)
                        {
                            weekdayValue = 0
                        }
                        else
                        {
                            weekdayValue++
                        }
                        if (weekendMask[weekdayValue])
                        {
                            days++
                        }
                        else
                        {
                            if (values.indexOf(Sheets._DateTimeHelper.___toOADate(date)) >= 0)
                            {
                                days++
                            }
                        }
                    }
                    return Sheets._DateTimeHelper.___toOADate(date)
                }
                function dt_days360(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var startDate = CalcConvert.DT(args[0]);
                    var endDate = CalcConvert.DT(args[1]);
                    var method = _Helper._argumentExists(args, 2) ? CalcConvert.B(args[2]) : false;
                    var startDay = startDate.getDate();
                    var endDay = endDate.getDate();
                    var startMonth = startDate.getMonth();
                    var endMonth = endDate.getMonth();
                    var StartYear = startDate.getFullYear();
                    var endYear = endDate.getFullYear();
                    if (method)
                    {
                        endDay = endDay === 31 ? 30 : endDay;
                        startDay = startDay === 31 ? 30 : startDay
                    }
                    else
                    {
                        startDay = startDay === 31 ? 30 : startDay;
                        if (endDay === 31)
                        {
                            if (startDay < 30)
                            {
                                endDay = 1;
                                endMonth++;
                                if (endMonth > 12)
                                {
                                    endMonth = 1;
                                    endYear++
                                }
                            }
                            else
                            {
                                endDay = 30
                            }
                        }
                    }
                    return ((endYear - StartYear) * 12 + (endMonth - startMonth)) * 30 + (endDay - startDay)
                }
                function _isWeekEnd(date, weekendMask)
                {
                    if (weekendMask && weekendMask.length && weekendMask.length > 0)
                    {
                        return weekendMask[dt_weekday([date, 3])]
                    }
                    else
                    {
                        return date.getDay() === 6 || date.getDay() === 0
                    }
                }
                function _removeHolidaies(args, start_serial, end_serial, res, isINTL)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var ele;
                    var weekendMask;
                    if (isINTL)
                    {
                        var weekend = _Helper._argumentExists(args, 2) ? args[2] : "0000011";
                        weekendMask = __caculateWeekendMask(weekend);
                        if (CalcConvert.err(weekendMask))
                        {
                            return weekendMask
                        }
                        if (_Helper._argumentExists(args, 3))
                        {
                            ele = CalcConvert.toArr(args[3], 4, true, true, false)
                        }
                    }
                    else
                    {
                        if (_Helper._argumentExists(args, 2))
                        {
                            ele = CalcConvert.toArr(args[2], 4, true, true, false)
                        }
                    }
                    if (!ele)
                    {
                        return res
                    }
                    if (ele.isError)
                    {
                        return ele[0]
                    }
                    var cnt = ele.length;
                    var list = [];
                    for (var k = 0; k < cnt; k++)
                    {
                        var tmpDateTime = ele[k];
                        var date = Sheets._DateTimeHelper._fromOADate(tmpDateTime);
                        if (list.indexOf(tmpDateTime) === -1 && !_isWeekEnd(date, weekendMask) && tmpDateTime >= start_serial && tmpDateTime <= end_serial)
                        {
                            list.push(tmpDateTime)
                        }
                    }
                    res -= list.length;
                    return res
                }
                function _removeWeekends(start_date, end_date, res)
                {
                    var Convert = CalcConvert,
                        DateTimeHelper = GcSpread.Sheets._DateTimeHelper;
                    var offsetInOneWeek = CalcConvert.I(new DateTimeHelper(end_date).toOADate() - new DateTimeHelper(start_date).toOADate()) % 7;
                    var weekDays = CalcConvert.I(dt_weekday([start_date, 2]) + offsetInOneWeek);
                    offsetInOneWeek = weekDays > 5 ? weekDays - 5 : 0;
                    var maxOffset = start_date.getDay() === 0 ? 1 : 2;
                    offsetInOneWeek = offsetInOneWeek > maxOffset ? maxOffset : offsetInOneWeek;
                    res -= offsetInOneWeek;
                    var weekends = Math_floor(res / 7) * 2;
                    res -= weekends;
                    return res
                }
                function dt_networkdays(args)
                {
                    var Convert = CalcConvert,
                        DateTimeHelper = GcSpread.Sheets._DateTimeHelper;
                    var start_date = CalcConvert.DT(args[0]);
                    var end_date = CalcConvert.DT(args[1]);
                    var start_serial = CalcConvert.I(new DateTimeHelper(start_date).toOADate());
                    var end_serial = CalcConvert.I(new DateTimeHelper(end_date).toOADate());
                    var isNegative = false;
                    if (start_serial > end_serial)
                    {
                        var tmpDate = start_date;
                        var tmp = start_serial;
                        start_serial = end_serial;
                        end_serial = tmp;
                        start_date = end_date;
                        end_date = tmpDate;
                        isNegative = true
                    }
                    var res = end_serial - start_serial + 1;
                    res = _removeWeekends(start_date, end_date, res);
                    if (res <= 0)
                    {
                        return 0
                    }
                    res = _removeHolidaies(args, start_serial, end_serial, res);
                    res = isNegative ? -res : res;
                    return res
                }
                function dt_networkdays_intl(args)
                {
                    var Convert = CalcConvert,
                        DateTimeHelper = GcSpread.Sheets._DateTimeHelper;
                    var start_date = CalcConvert.DT(args[0]);
                    var end_date = CalcConvert.DT(args[1]);
                    var start_serial = CalcConvert.I(new DateTimeHelper(start_date).toOADate());
                    var end_serial = CalcConvert.I(new DateTimeHelper(end_date).toOADate());
                    var isNegative = false;
                    if (start_serial > end_serial)
                    {
                        var tmpDate = start_date;
                        var tmp = start_serial;
                        start_serial = end_serial;
                        end_serial = tmp;
                        start_date = end_date;
                        end_date = tmpDate;
                        isNegative = true
                    }
                    var res = end_serial - start_serial + 1;
                    res = _removeWeekends_intl(args, start_date, end_date, res);
                    if (CalcConvert.err(res))
                    {
                        return res
                    }
                    if (res <= 0)
                    {
                        return 0
                    }
                    res = _removeHolidaies(args, start_serial, end_serial, res, true);
                    res = isNegative ? -res : res;
                    return res
                }
                function _removeWeekends_intl(args, start_date, end_date, res)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var weekend = _Helper._argumentExists(args, 2) ? args[2] : "0000011";
                    var weekendMask = __caculateWeekendMask(weekend);
                    if (CalcConvert.err(weekendMask))
                    {
                        return weekendMask
                    }
                    var weekendsCountInOneWeek = 0;
                    for (var index = 0; index < weekendMask.length; index++)
                    {
                        if (weekendMask[index] === 1)
                        {
                            weekendsCountInOneWeek++
                        }
                    }
                    var offsetWeekendsCount = 0;
                    if (res < 30)
                    {
                        for (i = 0; i < res; i++)
                        {
                            if (weekendMask[(CalcConvert.I(dt_weekday([start_date, 3])) + i) % 7])
                            {
                                offsetWeekendsCount++
                            }
                        }
                        res = res - offsetWeekendsCount;
                        return res
                    }
                    else
                    {
                        var tempRes = res;
                        var offsetHeader = 0,
                            offsetTail = 0;
                        var i;
                        for (i = 0; i < tempRes; i++)
                        {
                            if (CalcConvert.I(dt_weekday([start_date, 3]) + i) % 7 === 0)
                            {
                                break
                            }
                            offsetHeader++
                        }
                        for (i = 0; i < offsetHeader; i++)
                        {
                            if (weekendMask[(CalcConvert.I(dt_weekday([start_date, 3])) + i) % 7])
                            {
                                offsetWeekendsCount++
                            }
                        }
                        for (i = 0; i < tempRes; i++)
                        {
                            if ((CalcConvert.I(dt_weekday([end_date, 3])) + 7 - i) % 7 === 6)
                            {
                                break
                            }
                            offsetTail++
                        }
                        for (i = 0; i < offsetTail; i++)
                        {
                            if (weekendMask[(CalcConvert.I(dt_weekday([end_date, 3])) + 7 - i) % 7])
                            {
                                offsetWeekendsCount++
                            }
                        }
                        tempRes = tempRes - offsetHeader - offsetTail;
                        var weekendsCount = CalcConvert.I(tempRes / 7) * weekendsCountInOneWeek;
                        res -= weekendsCount;
                        res -= offsetWeekendsCount;
                        return res
                    }
                }
                function __caculateWeekendMask(weekend)
                {
                    if (typeof weekend === const_string)
                    {
                        if (weekend.length !== 7 || isNaN(parseInt(weekend)))
                        {
                            return CalcErrorsValue
                        }
                    }
                    else if (!isNaN(weekend))
                    {
                        if (Math_floor(weekend) < 1 || Math_floor(weekend) > 17)
                        {
                            return CalcErrorsNumber
                        }
                        weekend = weekend.toString()
                    }
                    var weekendMask = [0, 0, 0, 0, 0, 0, 0];
                    var length = weekend.length;
                    switch (length)
                    {
                        case 1:
                            switch (weekend)
                            {
                                case'1':
                                    weekendMask[5] = 1;
                                    weekendMask[6] = 1;
                                    break;
                                case'2':
                                    weekendMask[6] = 1;
                                    weekendMask[0] = 1;
                                    break;
                                case'3':
                                    weekendMask[0] = 1;
                                    weekendMask[1] = 1;
                                    break;
                                case'4':
                                    weekendMask[1] = 1;
                                    weekendMask[2] = 1;
                                    break;
                                case'5':
                                    weekendMask[2] = 1;
                                    weekendMask[3] = 1;
                                    break;
                                case'6':
                                    weekendMask[3] = 1;
                                    weekendMask[4] = 1;
                                    break;
                                case'7':
                                    weekendMask[4] = 1;
                                    weekendMask[5] = 1;
                                    break;
                                default:
                                    return CalcErrorsNumber
                            }
                            break;
                        case 2:
                            if (weekend[0] === '1')
                            {
                                switch (weekend[1])
                                {
                                    case'1':
                                        weekendMask[6] = 1;
                                        break;
                                    case'2':
                                        weekendMask[0] = 1;
                                        break;
                                    case'3':
                                        weekendMask[1] = 1;
                                        break;
                                    case'4':
                                        weekendMask[2] = 1;
                                        break;
                                    case'5':
                                        weekendMask[3] = 1;
                                        break;
                                    case'6':
                                        weekendMask[4] = 1;
                                        break;
                                    case'7':
                                        weekendMask[5] = 1;
                                        break;
                                    default:
                                        return CalcErrorsNumber
                                }
                            }
                            else
                            {
                                return CalcErrorsNumber
                            }
                            break;
                        case 7:
                            for (var i = 0; i < 7; i++)
                            {
                                weekendMask[i] = parseInt(weekend[i])
                            }
                            break;
                        default:
                            return CalcErrorsValue
                    }
                    return weekendMask
                }
                function _yearfracImp(from, to, basis)
                {
                    var Functions = Calc.Functions;
                    var _FinancialHelper = Functions._FinancialHelper;
                    var days = _FinancialHelper.__days_between_basis(from, to, basis);
                    var peryear;
                    if (days < 0)
                    {
                        var tmp;
                        days = -days;
                        tmp = from;
                        from = to;
                        to = tmp
                    }
                    if (basis === 1)
                    {
                        var y1 = from.getFullYear();
                        var y2 = to.getFullYear();
                        var d1,
                            d2;
                        var feb29s,
                            years;
                        d1 = from;
                        d1.setFullYear(d1.getFullYear() + 1);
                        if (_compareDateTime(to, d1) > 0)
                        {
                            years = y2 + 1 - y1;
                            d1 = new Date(y1, 0, 1);
                            d2 = new Date(y2 + 1, 0, 1);
                            var DateTimeHelper = GcSpread.Sheets._DateTimeHelper;
                            feb29s = CalcConvert.I(new DateTimeHelper(d2).toOADate() - new DateTimeHelper(d1).toOADate()) - 365 * (y2 + 1 - y1)
                        }
                        else
                        {
                            years = 1;
                            if ((_isLeapYear(y1) && from.getMonth() < 3) || (_isLeapYear(y2) && (to.getMonth() * 0x100 + to.getDate() >= 2 * 0x100 + 29)))
                            {
                                feb29s = 1
                            }
                            else
                            {
                                feb29s = 0
                            }
                        }
                        var d = CalcConvert.D(feb29s) / CalcConvert.D(years);
                        peryear = 365.0 + d
                    }
                    else
                    {
                        peryear = _FinancialHelper.__annual_year_basis(new Date, basis)
                    }
                    return days / peryear
                }
                function dt_yearfrac(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var startDate = CalcConvert.DT(args[0]);
                    var endDate = CalcConvert.DT(args[1]);
                    var basis = _Helper._argumentExists(args, 2) ? CalcConvert.I(args[2]) : 0;
                    if (basis < 0 || basis > 4)
                    {
                        return CalcErrorsNumber
                    }
                    return _yearfracImp(startDate, endDate, basis)
                }
                function _calcDateDifFunction()
                {
                    var builtinProcedure = [];
                    builtinProcedure[0] = (function(startDate, endDate)
                    {
                        return (endDate.getFullYear() - startDate.getFullYear()) + (endDate.getMonth() < startDate.getMonth() || (endDate.getMonth() === startDate.getMonth() && endDate.getDate() < startDate.getDate()) ? -1 : 0)
                    });
                    builtinProcedure[1] = (function(startDate, endDate)
                    {
                        return 12 * (endDate.getFullYear() - startDate.getFullYear()) + (endDate.getMonth() - startDate.getMonth()) + (endDate.getDate() < startDate.getDate() ? -1 : 0)
                    });
                    builtinProcedure[2] = (function(startDate, endDate)
                    {
                        return (endDate.getTime() - startDate.getTime()) / (1000 * 3600 * 24)
                    });
                    builtinProcedure[3] = (function(startDate, endDate)
                    {
                        var date = new Date(endDate.getFullYear(), endDate.getMonth() + endDate.getDate() < startDate.getDate() ? -1 : 0, startDate.getDate());
                        return (endDate.getTime() - date.getTime()) / (1000 * 3600 * 24)
                    });
                    builtinProcedure[4] = (function(startDate, endDate)
                    {
                        return (endDate.getMonth() - startDate.getMonth()) + (endDate.getMonth() < startDate.getMonth() || (endDate.getMonth() === startDate.getMonth() && endDate.getDate() < startDate.getDate()) ? 12 : 0) + (endDate.getDate() < startDate.getDate() ? -1 : 0)
                    });
                    builtinProcedure[5] = (function(startDate, endDate)
                    {
                        var date = new Date(endDate.getFullYear() + (endDate.getMonth() < startDate.getMonth() || (endDate.getMonth() === startDate.getMonth() && endDate.getDate() < startDate.getDate()) ? -1 : 0), startDate.getMonth(), startDate.getDate());
                        return (endDate - date) / (1000 * 3600 * 24)
                    });
                    return builtinProcedure
                }
                function _getValueFromBuiltinProcedure(builtinProcedure, unit)
                {
                    var index;
                    switch (unit)
                    {
                        case"Y":
                            index = 0;
                            break;
                        case"M":
                            index = 1;
                            break;
                        case"D":
                            index = 2;
                            break;
                        case"MD":
                            index = 3;
                            break;
                        case"YM":
                            index = 4;
                            break;
                        case"YD":
                            index = 5;
                            break;
                        default:
                            throw Sheets.SR.Exp_NotSupport;
                    }
                    return builtinProcedure[index]
                }
                function dt_datedif(args)
                {
                    var startDate = CalcConvert.DT(args[0]);
                    var endDate = CalcConvert.DT(args[1]);
                    var unit = CalcConvert.S(args[2]).toLocaleUpperCase();
                    if (endDate < startDate)
                    {
                        return CalcErrorsNumber
                    }
                    var builtinProcedure = _calcDateDifFunction();
                    var procedure = _getValueFromBuiltinProcedure(builtinProcedure, unit);
                    if (procedure)
                    {
                        try
                        {
                            return procedure(startDate, endDate)
                        }
                        catch(err)
                        {
                            return CalcErrorsValue
                        }
                    }
                    return CalcErrorsNumber
                }
                function _isControlChar(ch)
                {
                    return (0x0 <= ch && ch <= 0x1F) || (0x7F === ch) || (0x80 <= ch && ch <= 0x9F)
                }
                function tx_clean(args)
                {
                    var text = CalcConvert.S(args[0]);
                    var sb = [];
                    for (var i = 0; i < text.length; i++)
                    {
                        if (!_isControlChar(text.charCodeAt(i)))
                        {
                            sb.push(text[i])
                        }
                    }
                    return sb.join("")
                }
                function _isWhiteSpace(ch)
                {
                    return (ch === ' ') || (ch === '\t') || (ch === '\n')
                }
                function tx_trim(args)
                {
                    var text = CalcConvert.S(args[0]).trim();
                    var str = [];
                    var bAddWhiteSp = true;
                    for (var i = 0; i < text.length; i++)
                    {
                        var ch = text.charAt(i);
                        if (!_isWhiteSpace(ch) || bAddWhiteSp)
                        {
                            str.push(ch)
                        }
                        bAddWhiteSp = !_isWhiteSpace(ch)
                    }
                    return str.join("")
                }
                function _addCommas(value)
                {
                    var str = value.toString();
                    var prefix = "";
                    if (value < 0)
                    {
                        str = str.substr(1);
                        prefix = "-"
                    }
                    var splits = str.split(".");
                    if (splits.length < 1 || splits.length > 2)
                    {
                        return CalcErrorsValue
                    }
                    var result = [];
                    if (splits.length === 2)
                    {
                        result.push(splits[1]);
                        result.push(".")
                    }
                    str = splits[0];
                    for (var i = str.length - 1 - 2; i >= 0; i = i - 3)
                    {
                        result.push(str.substr(i, 3));
                        if (i > 0)
                        {
                            result.push(",")
                        }
                    }
                    result.push(str.substring(0, i + 3));
                    result.reverse();
                    return prefix + result.join("")
                }
                function _toCurrency(value)
                {
                    var commasValue = _addCommas(value);
                    if (value < 0)
                    {
                        commasValue = commasValue.substr(1)
                    }
                    var result = [];
                    result.push("$");
                    result.push(commasValue);
                    if (value < 0)
                    {
                        result.push(")");
                        result.unshift("(")
                    }
                    return result.join("")
                }
                function tx_dollar(args)
                {
                    var _number;
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    if (isNaN(_number = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    var decimals = _Helper._argumentExists(args, 1) ? CalcConvert.I(args[1]) : 2;
                    if (decimals > 99)
                    {
                        return CalcErrorsValue
                    }
                    _number = CalcConvert.D(mt_round([_number, decimals]));
                    return _toCurrency(_number)
                }
                function tx_fixed(args)
                {
                    var _number;
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    if (isNaN(_number = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    var decimals = _Helper._argumentExists(args, 1) ? CalcConvert.I(args[1]) : 2;
                    var noCommas = _Helper._argumentExists(args, 2) ? CalcConvert.B(args[2]) : false;
                    var list = [];
                    var divisor = 0;
                    if (decimals < 0)
                    {
                        divisor = CalcConvert.I(Math_pow(10, Math_abs(decimals)));
                        _number /= divisor;
                        list[0] = _number;
                        list[1] = 0
                    }
                    else
                    {
                        list[0] = _number;
                        list[1] = decimals
                    }
                    _number = CalcConvert.D(mt_round(list));
                    if (decimals < 0)
                    {
                        _number *= divisor
                    }
                    if (noCommas)
                    {
                        return _number.toString()
                    }
                    else
                    {
                        return _addCommas(_number)
                    }
                }
                function _removeColorFormat(format)
                {
                    if (Sheets.StringUtil.startsWith(format, '[$-'))
                    {
                        return format
                    }
                    if (format.indexOf("[") !== -1 && format.indexOf("]") !== -1)
                    {
                        var lpIndex = format.indexOf("[");
                        var rpIndex = format.indexOf("]", lpIndex);
                        while (lpIndex !== -1 && rpIndex !== -1)
                        {
                            var before = format.substring(0, lpIndex);
                            var after = format.substring(rpIndex + 1);
                            format = before.concat(after);
                            lpIndex = format.indexOf("[");
                            rpIndex = lpIndex === -1 ? -1 : format.indexOf("]", lpIndex)
                        }
                    }
                    return format
                }
                function tx_text(args)
                {
                    var value = args[0];
                    var Convert = CalcConvert,
                        StandardDateTimeFormatter = Sheets._StandardDateTimeFormatter,
                        StandardNumberFormatter = Sheets._StandardNumberFormatter;
                    var format = CalcConvert.S(args[1]);
                    if (format === "" || format === keyword_null || format === keyword_undefined)
                    {
                        return CalcConvert.S(value)
                    }
                    if (value === keyword_null || value === keyword_undefined)
                    {
                        value = 0
                    }
                    format = _removeColorFormat(format);
                    try
                    {
                        var formatter = new Sheets.GeneralFormatter(format);
                        return formatter.Format(value)
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function tx_value(args)
                {
                    var Convert = CalcConvert,
                        DateTimeHelper = GcSpread.Sheets._DateTimeHelper;
                    var text = CalcConvert.S(args[0]);
                    var dt = DateTimeHelper.parseLocale(text);
                    if (dt !== keyword_undefined && dt !== keyword_null)
                    {
                        var result = new DateTimeHelper(dt).toOADate();
                        if (!Convert.err(result))
                        {
                            return result
                        }
                        else
                        {
                            return dt_timevalue([dt])
                        }
                    }
                    var d;
                    if (!isNaN(d = parseFloat(text)))
                    {
                        return d
                    }
                    return CalcErrorsValue
                }
                function tx_lower(args)
                {
                    var text = CalcConvert.S(args[0]);
                    return text.toLowerCase()
                }
                function tx_upper(args)
                {
                    var text = CalcConvert.S(args[0]);
                    return text.toUpperCase()
                }
                function tx_char(args)
                {
                    var number = CalcConvert.I(args[0]);
                    if (number < 1 || 255 < number)
                    {
                        return CalcErrorsValue
                    }
                    return String.fromCharCode(number)
                }
                function tx_code(args)
                {
                    var text = CalcConvert.S(args[0]);
                    if (text === "" || text === keyword_undefined || text === keyword_null)
                    {
                        return CalcErrorsValue
                    }
                    try
                    {
                        return text[0].charCodeAt(0)
                    }
                    catch(err)
                    {
                        return CalcErrorsValue
                    }
                }
                function tx_replace(args)
                {
                    var oldText = CalcConvert.S(args[0]);
                    var start = CalcConvert.I(args[1]);
                    var length = CalcConvert.I(args[2]);
                    var newText = CalcConvert.S(args[3]);
                    if (start < 1 || length < 0)
                    {
                        return CalcErrorsValue
                    }
                    start = Math_min(start, oldText.length + 1);
                    length = Math_min(length, oldText.length - start + 1);
                    var before = oldText.substring(0, start - 1);
                    var after = oldText.substr(start - 1 + length);
                    return before.concat(newText).concat(after)
                }
                function tx_substitute(args)
                {
                    var searchtext = CalcConvert.S(args[0]);
                    var oldtext = CalcConvert.S(args[1]);
                    var newtext = CalcConvert.S(args[2]);
                    var result;
                    if (oldtext === "" || oldtext === keyword_undefined || oldtext === keyword_null)
                    {
                        return searchtext
                    }
                    if (args.length > 3)
                    {
                        var inst = CalcConvert.I(args[3]);
                        var index = 0;
                        if (inst < 1)
                        {
                            return CalcErrorsValue
                        }
                        for (var i = 0; i < inst; i++)
                        {
                            index = searchtext.indexOf(oldtext, index);
                            if (index === -1)
                            {
                                return searchtext
                            }
                            index += oldtext.length
                        }
                        index -= oldtext.length;
                        var before = searchtext.substring(0, index);
                        var after = searchtext.substr(index + oldtext.length);
                        result = before.concat(newtext).concat(after)
                    }
                    else
                    {
                        result = Sheets.StringUtil.replace(searchtext, oldtext, newtext)
                    }
                    return result
                }
                function tx_concatenate(args)
                {
                    var sb = [];
                    var length = args.length;
                    for (var i = 0; i < length; i++)
                    {
                        var array = CalcConvert.toArr(args[i], 0, true, false, false);
                        var len = array.length;
                        for (var j = 0; j < len; j++)
                        {
                            var tmpValue = array[j];
                            if (tmpValue !== keyword_undefined && tmpValue !== keyword_null)
                            {
                                sb.push(CalcConvert.S(tmpValue))
                            }
                        }
                    }
                    return sb.join("")
                }
                function tx_left(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var text = CalcConvert.S(args[0]);
                    var numChars = _Helper._argumentExists(args, 1) ? CalcConvert.I(args[1]) : 1;
                    if (numChars < 0)
                    {
                        return CalcErrorsValue
                    }
                    else if (numChars >= text.length)
                    {
                        return text
                    }
                    else
                    {
                        return text.substr(0, numChars)
                    }
                }
                function tx_mid(args)
                {
                    var text = CalcConvert.S(args[0]);
                    var start = CalcConvert.I(args[1]) - 1;
                    var length = CalcConvert.I(args[2]);
                    if (start < 0 || length < 0)
                    {
                        return CalcErrorsValue
                    }
                    else if (start >= text.length)
                    {
                        return ""
                    }
                    else if (text.length < start + length)
                    {
                        return text.substr(start)
                    }
                    else
                    {
                        return text.substr(start, length)
                    }
                }
                function tx_right(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var text = CalcConvert.S(args[0]);
                    var numChars = _Helper._argumentExists(args, 1) ? CalcConvert.I(args[1]) : 1;
                    if (numChars < 0)
                    {
                        return CalcErrorsValue
                    }
                    else if (text.length < numChars)
                    {
                        return text
                    }
                    else
                    {
                        return text.substr(text.length - numChars, numChars)
                    }
                }
                function tx_rept(args)
                {
                    var text = CalcConvert.S(args[0]);
                    var count = CalcConvert.I(args[1]);
                    if (count < 0 || 32767 < count * text.length)
                    {
                        return CalcErrorsValue
                    }
                    var result = [];
                    for (var i = 0; i < count; i++)
                    {
                        result.push(text)
                    }
                    return result.join("")
                }
                function tx_len(args)
                {
                    return CalcConvert.S(args[0]).length
                }
                function tx_find(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var searchtext = CalcConvert.S(args[0]);
                    var text = CalcConvert.S(args[1]);
                    var start = _Helper._argumentExists(args, 2) ? CalcConvert.I(args[2]) : 1;
                    var found;
                    if (start < 1 || text.length < start)
                    {
                        return CalcErrorsValue
                    }
                    found = text.indexOf(searchtext, start - 1);
                    if (found === -1)
                    {
                        return CalcErrorsValue
                    }
                    return found + 1
                }
                function tx_search(args)
                {
                    var Convert = CalcConvert,
                        _Helper = Calc._Helper;
                    var searchtext = CalcConvert.S(args[0]);
                    var text = CalcConvert.S(args[1]);
                    var startIndex = _Helper._argumentExists(args, 2) ? CalcConvert.I(args[2]) : 1;
                    startIndex--;
                    if (startIndex < 0)
                    {
                        return CalcErrorsValue
                    }
                    var index = -1;
                    try
                    {
                        var wildcardCriteria = Sheets.RegUtil.getWildcardCriteria(searchtext);
                        if (!wildcardCriteria)
                        {
                            index = text.toLowerCase().indexOf(searchtext.toLowerCase(), startIndex)
                        }
                        else
                        {
                            var regex = Sheets.RegUtil.getRegIgnoreCase(wildcardCriteria);
                            var matchStr = regex.exec(text);
                            if (matchStr !== keyword_undefined && matchStr !== keyword_null)
                            {
                                index = matchStr.index
                            }
                            else
                            {
                                index = -1
                            }
                        }
                    }
                    catch(err) {}
                    if (index === -1)
                    {
                        return CalcErrorsValue
                    }
                    return index + 1
                }
                function tx_exact(args)
                {
                    var text1 = CalcConvert.S(args[0]);
                    var text2 = CalcConvert.S(args[1]);
                    return text1 === text2
                }
                function tx_t(args)
                {
                    var val = args[0];
                    return typeof val === 'string' ? val : ""
                }
                function _isError(obj, ctx)
                {
                    if (CalcConvert.err(obj))
                    {
                        ctx.value = true
                    }
                    else if ((typeof obj) === const_string)
                    {
                        var err = Calc.CalcError._parseCore(obj);
                        ctx.value = (err !== keyword_undefined && err !== keyword_null)
                    }
                    ctx.value = false
                }
                function _isErr(obj, ctx)
                {
                    if (CalcConvert.err(obj) && (obj._code !== CalcErrorsNotAvailable._code))
                    {
                        ctx.value = true
                    }
                    else if ((typeof obj) === const_string)
                    {
                        var err = Calc.CalcError._parseCore(obj);
                        ctx.value = (err !== keyword_undefined && err !== keyword_null && err !== CalcErrorsNotAvailable)
                    }
                    ctx.value = false
                }
                function _checkArgumentsLength(args)
                {
                    if (args === keyword_undefined || args === keyword_null)
                    {
                        throw Sheets.SR.Exp_InvalidArgument;
                    }
                    else
                    {
                        if (args.length < 1 || args.length > 1)
                        {
                            throw Sheets.SR.Exp_InvalidArgument;
                        }
                    }
                }
                function in_isError(args)
                {
                    _checkArgumentsLength(args);
                    var result = {value: false};
                    if (CalcConvert.err(args[0]))
                    {
                        result.value = true
                    }
                    else
                    {
                        __iterate(args[0], _isError, result)
                    }
                    return result.value
                }
                function in_isErr(args)
                {
                    _checkArgumentsLength(args);
                    var result = {value: false};
                    if (CalcConvert.err(args[0]) && (args[0]._code !== CalcErrorsNotAvailable._code))
                    {
                        result.value = true
                    }
                    else if (CalcConvert.err(args[0]) && (args[0]._code === CalcErrorsNotAvailable._code))
                    {
                        result.value = false
                    }
                    else
                    {
                        __iterate(args[0], _isErr, result)
                    }
                    return result.value
                }
                function in_isNA(args)
                {
                    _checkArgumentsLength(args);
                    if (CalcConvert.err(args[0]))
                    {
                        return args[0]._code === CalcErrorsNotAvailable._code
                    }
                    return false
                }
                function in_error_Type(args)
                {
                    _checkArgumentsLength(args);
                    var err = args[0];
                    if (err !== keyword_undefined && err !== keyword_null)
                    {
                        if (CalcConvert.err(err))
                        {
                            switch (err._code)
                            {
                                case CalcErrorsNull._code:
                                    return 1;
                                case CalcErrorsDivideByZero._code:
                                    return 2;
                                case CalcErrorsValue._code:
                                    return 3;
                                case CalcErrorsReference._code:
                                    return 4;
                                case CalcErrorsName._code:
                                    return 5;
                                case CalcErrorsNumber._code:
                                    return 6;
                                case CalcErrorsNotAvailable._code:
                                    return 7;
                                default:
                                    break
                            }
                        }
                    }
                    return CalcErrorsNotAvailable
                }
                function in_isNumber(args)
                {
                    _checkArgumentsLength(args);
                    return CalcConvert.num(args[0])
                }
                function in_isEven(args)
                {
                    _checkArgumentsLength(args);
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return Functions._MathHelper.approxFloor(Math_abs(num)) % 2.0 === 0.0
                }
                function in_isOdd(args)
                {
                    _checkArgumentsLength(args);
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    return Functions._MathHelper.approxFloor(Math_abs(num)) % 2.0 !== 0.0
                }
                function in_number(args)
                {
                    _checkArgumentsLength(args);
                    var value = args[0];
                    if (CalcConvert.num(value))
                    {
                        return CalcConvert.D(value)
                    }
                    else if ((typeof value) === const_boolean)
                    {
                        return (value) ? 1.0 : 0.0
                    }
                    else if (CalcConvert.err(value))
                    {
                        return value
                    }
                    return 0.0
                }
                function in_isBlank(args)
                {
                    _checkArgumentsLength(args);
                    return args[0] === keyword_undefined || args[0] === keyword_null
                }
                function in_isLogical(args)
                {
                    _checkArgumentsLength(args);
                    return (typeof args[0]) === const_boolean
                }
                function in_isText(args)
                {
                    _checkArgumentsLength(args);
                    return (typeof args[0]) === const_string
                }
                function in_isNonText(args)
                {
                    _checkArgumentsLength(args);
                    return (typeof args[0]) !== const_string
                }
                function in_isRef(args)
                {
                    _checkArgumentsLength(args);
                    return CalcConvert.ref(args[0])
                }
                function in_type(args)
                {
                    _checkArgumentsLength(args);
                    var value = args[0];
                    if ((typeof value) === const_boolean)
                    {
                        return 4
                    }
                    else if (CalcConvert.num(value))
                    {
                        return 1
                    }
                    else if ((typeof value) === const_string)
                    {
                        return 2
                    }
                    else if (CalcConvert.err(value))
                    {
                        return 16
                    }
                    else if (CalcConvert.arr(value))
                    {
                        return 64
                    }
                    else
                    {
                        return CalcErrorsValue
                    }
                }
                function in_na(args)
                {
                    return CalcErrorsNotAvailable
                }
                _Functions._MathHelper = (function()
                {
                    function _approxFloor(x)
                    {
                        var r = Math_floor(x);
                        if (Functions._MathHelper.approxEqual(x, r + 1.0))
                        {
                            return r + 1.0
                        }
                        return r
                    }
                    function _approxCeiling(x)
                    {
                        var r = Math_ceil(x);
                        if (Functions._MathHelper.approxEqual(x, r - 1.0))
                        {
                            return r - 1.0
                        }
                        return r
                    }
                    function _approxEqual(x, y)
                    {
                        if (x === y)
                        {
                            return true
                        }
                        return Math_abs(x - y) < Math_abs(x) / (16777216.0 * 16777216.0)
                    }
                    function _initPow10()
                    {
                        var pow10Array = [];
                        pow10Array[0x00] = 1e0;
                        pow10Array[0x01] = 1e1;
                        pow10Array[0x02] = 1e2;
                        pow10Array[0x03] = 1e3;
                        pow10Array[0x04] = 1e4;
                        pow10Array[0x05] = 1e5;
                        pow10Array[0x06] = 1e6;
                        pow10Array[0x07] = 1e7;
                        pow10Array[0x08] = 1e8;
                        pow10Array[0x09] = 1e9;
                        pow10Array[0x0a] = 1e10;
                        pow10Array[0x0b] = 1e11;
                        pow10Array[0x0c] = 1e12;
                        pow10Array[0x0d] = 1e13;
                        pow10Array[0x0e] = 1e14;
                        pow10Array[0x0f] = 1e15;
                        pow10Array[0x10] = 1e16;
                        return pow10Array
                    }
                    function _pow10(n)
                    {
                        var pow10Array = _initPow10();
                        var value = pow10Array[n];
                        if (value !== keyword_undefined && value !== keyword_null)
                        {
                            return value
                        }
                        return Math_pow(10.0, parseFloat(n))
                    }
                    function _buildCriteria(crit, criteria)
                    {
                        var compareString;
                        var regMatchString;
                        var compareDouble;
                        var wildcardCriteria;
                        var reg;
                        switch (crit)
                        {
                            case 0:
                                compareString = (function(v1, v2)
                                {
                                    return v1 <= v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 <= v2
                                });
                                break;
                            case 1:
                                compareString = (function(v1, v2)
                                {
                                    return v1 >= v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 >= v2
                                });
                                break;
                            case 2:
                                compareString = (function(v1, v2)
                                {
                                    return v1 !== v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 !== v2
                                });
                                break;
                            case 3:
                                compareString = (function(v1, v2)
                                {
                                    return v1 < v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 < v2
                                });
                                break;
                            case 4:
                                compareString = (function(v1, v2)
                                {
                                    return v1 === v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 === v2
                                });
                                wildcardCriteria = Sheets.RegUtil.getWildcardCriteriaFullMatch(criteria);
                                if (wildcardCriteria)
                                {
                                    reg = Sheets.RegUtil.getRegIgnoreCase(wildcardCriteria);
                                    regMatchString = (function(v1)
                                    {
                                        reg.lastIndex = 0;
                                        return reg.test(v1)
                                    })
                                }
                                break;
                            case 5:
                                compareString = (function(v1, v2)
                                {
                                    return v1 > v2
                                });
                                compareDouble = (function(v1, v2)
                                {
                                    return v1 > v2
                                });
                                break;
                            default:
                                return (function(v)
                                    {
                                        return false
                                    })
                        }
                        var critVal = -1;
                        var isCritNumber = true;
                        try
                        {
                            var doubleValue = {value: 0};
                            if (criteria === keyword_undefined || criteria === keyword_null)
                            {
                                critVal = 0
                            }
                            else if (CalcConvert.rD(criteria.toString(), doubleValue))
                            {
                                critVal = doubleValue.value
                            }
                            else
                            {
                                isCritNumber = false
                            }
                        }
                        catch(e)
                        {
                            isCritNumber = false
                        }
                        return (function(value)
                            {
                                if (value === keyword_undefined || value === keyword_null)
                                {
                                    value = ""
                                }
                                if (isCritNumber)
                                {
                                    var chkVal = -1;
                                    try
                                    {
                                        var doubleValue = {value: 0};
                                        if (CalcConvert.rD(value, doubleValue))
                                        {
                                            return compareDouble(doubleValue.value, critVal)
                                        }
                                    }
                                    catch(e) {}
                                }
                                if (wildcardCriteria && regMatchString)
                                {
                                    return regMatchString(value.toString())
                                }
                                return compareString(value.toString().toUpperCase(), (criteria !== keyword_undefined && criteria !== keyword_null) ? criteria.toString().toUpperCase() : "")
                            })
                    }
                    function _parseCriteria(criteria)
                    {
                        if (CalcConvert.num(criteria))
                        {
                            return _buildCriteria(4, criteria)
                        }
                        var OPERATORS_INFIX = "=><";
                        var critString = (criteria !== keyword_undefined && criteria !== keyword_null) ? criteria.toString().toUpperCase() : "";
                        var prevChar = '\0';
                        for (var i = 0; i < 2 && i < critString.length; i++)
                        {
                            var tc = critString[i];
                            if (OPERATORS_INFIX.indexOf(tc) !== -1)
                            {
                                if (tc === '=')
                                {
                                    switch (prevChar)
                                    {
                                        case'<':
                                            return _buildCriteria(0, critString.substring(2));
                                        case'>':
                                            return _buildCriteria(1, critString.substring(2));
                                        default:
                                            return _buildCriteria(4, (prevChar === '\0') ? critString.substring(1) : criteria)
                                    }
                                }
                                else
                                {
                                    if (prevChar === '\0')
                                    {
                                        prevChar = tc;
                                        continue
                                    }
                                    if (prevChar === '<')
                                    {
                                        if (tc === '>')
                                        {
                                            return _buildCriteria(2, critString.substring(2))
                                        }
                                        else
                                        {
                                            return _buildCriteria(3, critString.substring(1))
                                        }
                                    }
                                    else if (prevChar === '>')
                                    {
                                        return _buildCriteria(5, critString.substring(1))
                                    }
                                }
                            }
                            else
                            {
                                switch (prevChar)
                                {
                                    case'<':
                                        return _buildCriteria(3, critString.substring(1));
                                    case'>':
                                        return _buildCriteria(5, critString.substring(1));
                                    default:
                                        break
                                }
                            }
                        }
                        return _buildCriteria(4, criteria)
                    }
                    function _round(number, digits)
                    {
                        if (isNaN(number))
                        {
                            return CalcErrorsValue
                        }
                        var power = _pow10(Math_abs(digits));
                        if (digits < 0)
                        {
                            number /= power
                        }
                        else
                        {
                            number *= power
                        }
                        if (number < 0.0)
                        {
                            number = _approxCeiling(number - 0.5)
                        }
                        else
                        {
                            number = _approxFloor(number + 0.5)
                        }
                        if (digits < 0)
                        {
                            number *= power
                        }
                        else
                        {
                            number /= power
                        }
                        return CalcConvert.toResult(number)
                    }
                    function _combin(n, k)
                    {
                        if (isNaN(n) || isNaN(k))
                        {
                            return CalcErrorsValue
                        }
                        if (n < 0.0 || k < 0.0 || n < k)
                        {
                            return CalcErrorsNumber
                        }
                        var result = 1.0;
                        k = Math_min(n - k, k);
                        for (var i = 1.0; i <= k; i++)
                        {
                            result *= n - i + 1.0;
                            result /= i
                        }
                        return CalcConvert.toResult(result)
                    }
                    function _log1p(x)
                    {
                        return Math_log(1.0 + x) - (((1.0 + x) - 1.0) - x) / (1.0 + x)
                    }
                    function _pow1p(x, y)
                    {
                        var ret;
                        if (Math_abs(x) > 0.5)
                        {
                            ret = Math_pow(1.0 + x, y)
                        }
                        else
                        {
                            ret = Math_exp(y * _log1p(x))
                        }
                        if (!isFinite(ret))
                        {
                            if (ret === Number.POSITIVE_INFINITY)
                            {
                                ret = 1.79769e+308
                            }
                            else if (ret === Number.NEGATIVE_INFINITY)
                            {
                                ret = -1.79769e+308
                            }
                        }
                        else if (isNaN(ret))
                        {
                            ret = 4.94066e-324
                        }
                        return ret
                    }
                    function _cosh(d)
                    {
                        return (Math_exp(d) + Math_exp(-d)) / 2
                    }
                    function _sinh(d)
                    {
                        return (Math_exp(d) - Math_exp(-d)) / 2
                    }
                    return {
                            approxFloor: _approxFloor, approxCeiling: _approxCeiling, approxEqual: _approxEqual, pow10: _pow10, parseCriteria: _parseCriteria, round: _round, combin: _combin, log10: MathEx.log10, log: MathEx.log, pow1p: _pow1p, log1p: _log1p, cosh: _cosh, sinh: _sinh
                        }
                })();
                function st_trend(args)
                {
                    var convert = CalcConvert,
                        helper = Calc._Helper;
                    var knownY = CalcConvert.toArr(args[0], 0, false, true, false);
                    var knownX = [];
                    if (helper._argumentExists(args, 1))
                    {
                        knownX = CalcConvert.toArr(args[1], 0, false, true, false)
                    }
                    else
                    {
                        knownX = knownY
                    }
                    var newX = helper._argumentExists(args, 2) ? CalcConvert.toArr(args[2], 0, false, true, false) : knownX;
                    var constant = helper._argumentExists(args, 3) ? CalcConvert.B(args[3]) : true;
                    var i,
                        j;
                    for (i = 0; i < knownY.rowCount; i++)
                    {
                        for (j = 0; j < knownY.colCount; j++)
                        {
                            if (!convert.num(knownY[i][j]))
                            {
                                return CalcErrorsValue
                            }
                        }
                    }
                    for (i = 0; i < knownX.rowCount; i++)
                    {
                        for (j = 0; j < knownX.colCount; j++)
                        {
                            if (!convert.num(knownX[i][j]))
                            {
                                return CalcErrorsValue
                            }
                        }
                    }
                    for (i = 0; i < newX.rowCount; i++)
                    {
                        for (j = 0; j < newX.colCount; j++)
                        {
                            if (!convert.num(newX[i][j]))
                            {
                                return CalcErrorsValue
                            }
                        }
                    }
                    var d,
                        k,
                        m,
                        n,
                        x,
                        y,
                        result,
                        found,
                        val,
                        temp;
                    if (knownY.rowCount === knownX.rowCount && knownY.colCount === knownX.colCount)
                    {
                        n = knownX.rowCount * knownX.colCount;
                        var sumx = 0.0,
                            sumx2 = 0.0,
                            sumy = 0.0,
                            sumxy = 0.0,
                            b;
                        for (i = 0; i < knownX.rowCount; i++)
                        {
                            for (j = 0; j < knownX.colCount; j++)
                            {
                                if (isNaN(x = CalcConvert.D(knownX[i][j])) || isNaN(y = CalcConvert.D(knownY[i][j])))
                                {
                                    return CalcErrorsValue
                                }
                                sumx += x;
                                sumx2 += x * x;
                                sumy += y;
                                sumxy += x * y
                            }
                        }
                        if (constant)
                        {
                            m = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
                            b = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx)
                        }
                        else
                        {
                            m = sumxy / sumx2;
                            b = 0.0
                        }
                        result = [];
                        for (i = 0; i < newX.rowCount; i++)
                        {
                            result[i] = [];
                            for (j = 0; j < newX.colCount; j++)
                            {
                                if (isNaN(x = CalcConvert.D(newX[i][j])))
                                {
                                    return CalcErrorsValue
                                }
                                result[i][j] = m * x + b
                            }
                        }
                        return new Calc._ConcreteArray(result)
                    }
                    else if ((knownY.colCount === 1 && knownY.rowCount === knownX.rowCount) || (knownY.rowCount === 1 && knownY.colCount === knownX.colCount))
                    {
                        y = [];
                        x = [];
                        if (knownY.colCount === 1)
                        {
                            n = knownX.rowCount;
                            m = knownX.colCount;
                            for (i = 0; i < n; i++)
                            {
                                if (isNaN(d = CalcConvert.D(knownY[i][0])))
                                {
                                    return CalcErrorsValue
                                }
                                y[i] = d
                            }
                            for (i = 0; i < n; i++)
                            {
                                x[i] = [];
                                for (j = 0; j < m; j++)
                                {
                                    if (isNaN(d = CalcConvert.D(knownX[i][j])))
                                    {
                                        return CalcErrorsValue
                                    }
                                    x[i][j] = d
                                }
                            }
                        }
                        else
                        {
                            n = knownX.colCount;
                            m = knownX.rowCount;
                            x = [];
                            y = [];
                            for (i = 0; i < n; i++)
                            {
                                if (isNaN(d = CalcConvert.D(knownY[0][i])))
                                {
                                    return CalcErrorsValue
                                }
                                y[i] = d
                            }
                            for (i = 0; i < n; i++)
                            {
                                x[i] = [];
                                for (j = 0; j < m; j++)
                                {
                                    if (isNaN(d = CalcConvert.D(knownX[j][i])))
                                    {
                                        return CalcErrorsValue
                                    }
                                    x[i][j] = d
                                }
                            }
                        }
                        var q = [];
                        for (k = 0; k < m + 1; k++)
                        {
                            q[k] = []
                        }
                        for (var mm = 0; mm < m + 1; mm++)
                        {
                            for (var nn = 0; nn < m + 2; nn++)
                            {
                                q[mm][nn] = 0
                            }
                        }
                        for (k = 0; k < n; k++)
                        {
                            q[0][m + 1] = q[0][m + 1] + y[k];
                            for (i = 0; i < m; i++)
                            {
                                q[0][i + 1] = q[0][i + 1] + x[k][i];
                                q[i + 1][0] = q[0][i + 1];
                                q[i + 1][m + 1] = q[i + 1][m + 1] + x[k][i] * y[k];
                                for (j = i; j < m; j++)
                                {
                                    q[j + 1][i + 1] = q[j + 1][i + 1] + x[k][i] * x[k][j];
                                    q[i + 1][j + 1] = q[j + 1][i + 1]
                                }
                            }
                        }
                        q[0][0] = n;
                        if (constant)
                        {
                            for (i = 0; i < m + 1; i++)
                            {
                                if (q[i][i] === 0.0)
                                {
                                    found = false;
                                    for (j = i + 1; !found && j < m + 1; j++)
                                    {
                                        if (q[j][i] !== 0.0)
                                        {
                                            for (k = 0; k < m + 2; k++)
                                            {
                                                temp = q[i][k];
                                                q[i][k] = q[j][k];
                                                q[j][k] = temp
                                            }
                                            found = true
                                        }
                                    }
                                    if (!found)
                                    {
                                        return CalcErrorsNotAvailable
                                    }
                                }
                                val = 1.0 / q[i][i];
                                for (k = 0; k < m + 2; k++)
                                {
                                    q[i][k] = q[i][k] * val
                                }
                                for (j = 0; j < m + 1; j++)
                                {
                                    if (j !== i)
                                    {
                                        val = -q[j][i];
                                        for (k = 0; k < m + 2; k++)
                                        {
                                            q[j][k] = q[j][k] + val * q[i][k]
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            for (i = 1; i < m + 1; i++)
                            {
                                if (q[i][i] === 0.0)
                                {
                                    found = false;
                                    for (j = i + 1; !found && j < m + 1; j++)
                                    {
                                        if (q[j][i] !== 0.0)
                                        {
                                            for (k = 0; k < m + 2; k++)
                                            {
                                                temp = q[i][k];
                                                q[i][k] = q[j][k];
                                                q[j][k] = temp
                                            }
                                            found = true
                                        }
                                    }
                                    if (!found)
                                    {
                                        return CalcErrorsNotAvailable
                                    }
                                }
                                val = 1.0 / q[i][i];
                                for (k = 1; k < m + 2; k++)
                                {
                                    q[i][k] = q[i][k] * val
                                }
                                for (j = 1; j < m + 1; j++)
                                {
                                    if (j !== i)
                                    {
                                        val = -q[j][i];
                                        for (k = 1; k < m + 2; k++)
                                        {
                                            q[j][k] = q[j][k] + val * q[i][k]
                                        }
                                    }
                                }
                                q[0][m + 1] = 0.0
                            }
                        }
                        if (knownY.colCount === 1)
                        {
                            result = [];
                            for (i = 0; i < newX.rowCount; i++)
                            {
                                result[i] = [];
                                val = q[0][m + 1];
                                for (j = 0; j < m; j++)
                                {
                                    if (isNaN(d = CalcConvert.D(newX[i][j])))
                                    {
                                        return CalcErrorsValue
                                    }
                                    val += q[j + 1][m + 1] * d
                                }
                                result[i][0] = val
                            }
                            return new Calc._ConcreteArray(result)
                        }
                        else
                        {
                            result = [];
                            result[0] = [];
                            for (i = 0; i < newX.colCount; i++)
                            {
                                val = q[0][m + 1];
                                for (j = 0; j < m; j++)
                                {
                                    if (isNaN(d = CalcConvert.D(newX[j][i])))
                                    {
                                        return CalcErrorsValue
                                    }
                                    val += q[j + 1][m + 1] * d
                                }
                                result[0][i] = val
                            }
                            return new Calc._ConcreteArray(result)
                        }
                    }
                    return CalcErrorsNotAvailable
                }
                function st_growth(args)
                {
                    var convert = Calc.Convert,
                        helper = Calc._Helper;
                    var knownY = CalcConvert.toArr(args[0], 1, false, true, true);
                    var knownX = [];
                    if (helper._argumentExists(args, 1))
                    {
                        knownX = CalcConvert.toArr(args[1], 1, false, true, true)
                    }
                    else
                    {
                        knownX = knownY
                    }
                    var newX = helper._argumentExists(args, 2) ? CalcConvert.toArr(args[2], 1, false, true, true) : knownX;
                    var constant = helper._argumentExists(args, 3) ? CalcConvert.B(args[3]) : true;
                    var d,
                        k,
                        i,
                        j,
                        m,
                        n,
                        x,
                        y,
                        mm,
                        nn,
                        result,
                        s,
                        val,
                        L;
                    for (i = 0; i < knownY.rowCount; i++)
                    {
                        for (j = 0; j < knownY.colCount; j++)
                        {
                            val = knownY[i][j];
                            if (val <= 0.0)
                            {
                                return CalcErrorsNumber
                            }
                        }
                    }
                    if (knownY.rowCount === knownX.rowCount && knownY.colCount === knownX.colCount)
                    {
                        n = knownX.rowCount * knownX.colCount;
                        var sumx = 0.0,
                            sumx2 = 0.0,
                            sumy = 0.0,
                            sumxy = 0.0,
                            b;
                        for (i = 0; i < knownX.rowCount; i++)
                        {
                            for (j = 0; j < knownX.colCount; j++)
                            {
                                x = knownX[i][j];
                                y = knownY[i][j];
                                y = Math_log(y);
                                sumx += x;
                                sumx2 += x * x;
                                sumy += y;
                                sumxy += x * y
                            }
                        }
                        if (constant)
                        {
                            m = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
                            b = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx)
                        }
                        else
                        {
                            m = sumxy / sumx2;
                            b = 0.0
                        }
                        result = [];
                        for (i = 0; i < newX.rowCount; i++)
                        {
                            result[i] = [];
                            for (j = 0; j < newX.colCount; j++)
                            {
                                x = newX[i][j];
                                result[i][j] = Math_exp(m * x + b)
                            }
                        }
                        return new Calc._ConcreteArray(result)
                    }
                    else if ((knownY.colCount === 1 && knownY.rowCount === knownX.rowCount) || (knownY.rowCount === 1 && knownY.colCount === knownX.colCount))
                    {
                        y = [];
                        x = [];
                        if (knownY.colCount === 1)
                        {
                            n = knownX.rowCount;
                            m = knownX.colCount;
                            for (i = 0; i < n; i++)
                            {
                                d = knownY[i][0];
                                y[i] = Math_log(d)
                            }
                            for (i = 0; i < n; i++)
                            {
                                x[i] = [];
                                for (j = 0; j < m; j++)
                                {
                                    d = knownX[i][j];
                                    x[i][j] = d
                                }
                            }
                        }
                        else
                        {
                            n = knownX.colCount;
                            m = knownX.rowCount;
                            x = [];
                            y = [];
                            for (i = 0; i < n; i++)
                            {
                                d = knownY[0][i];
                                y[i] = d
                            }
                            for (i = 0; i < n; i++)
                            {
                                x[i] = [];
                                for (j = 0; j < m; j++)
                                {
                                    d = knownX[j][i];
                                    x[i][j] = d
                                }
                            }
                        }
                        var q = [];
                        for (mm = 0; mm < m + 1; mm++)
                        {
                            q[mm] = [];
                            for (nn = 0; nn < m + 2; nn++)
                            {
                                q[mm][nn] = 0
                            }
                        }
                        var e = [];
                        for (mm = 0; mm < m + 2; mm++)
                        {
                            e[mm] = 0
                        }
                        for (k = 0; k < n; k++)
                        {
                            e[m + 1] = e[m + 1] + y[k] * y[k];
                            q[0][m + 1] = q[0][m + 1] + y[k];
                            e[0] = q[0][m + 1];
                            for (i = 0; i < m; i++)
                            {
                                q[0][i + 1] = q[0][i + 1] + x[k][i];
                                q[i + 1][0] = q[0][i + 1];
                                q[i + 1][m + 1] = q[i + 1][m + 1] + x[k][i] * y[k];
                                e[i + 1] = q[i + 1][m + 1];
                                for (j = i; j < m; j++)
                                {
                                    q[j + 1][i + 1] = q[j + 1][i + 1] + x[k][i] * x[k][j];
                                    q[i + 1][j + 1] = q[j + 1][i + 1]
                                }
                            }
                        }
                        q[0][0] = n;
                        if (constant)
                        {
                            for (s = 0; s < m + 1; s++)
                            {
                                i = s;
                                while (i < m + 1 && q[i][s] === 0.0)
                                {
                                    i++
                                }
                                if (i >= m + 1)
                                {
                                    return CalcErrorsNotAvailable
                                }
                                for (L = 0; L < m + 2; L++)
                                {
                                    val = q[s][L];
                                    q[s][L] = q[i][L];
                                    q[i][L] = val
                                }
                                val = 1.0 / q[s][s];
                                for (L = 0; L < m + 2; L++)
                                {
                                    q[s][L] = q[s][L] * val
                                }
                                for (i = 0; i < m + 1; i++)
                                {
                                    if (i !== s)
                                    {
                                        val = -q[i][s];
                                        for (L = 0; L < m + 2; L++)
                                        {
                                            q[i][L] = q[i][L] + val * q[s][L]
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            for (s = 1; s < m + 1; s++)
                            {
                                i = s;
                                while (i < m + 1 && q[i][s] === 0.0)
                                {
                                    i++
                                }
                                if (i >= m + 1)
                                {
                                    return CalcErrorsNotAvailable
                                }
                                for (L = 1; L < m + 2; L++)
                                {
                                    val = q[s][L];
                                    q[s][L] = q[i][L];
                                    q[i][L] = val
                                }
                                val = 1.0 / q[s][s];
                                q[s][L] = q[s][L] * val;
                                for (i = 1; i < m + 1; i++)
                                {
                                    if (i !== s)
                                    {
                                        val = -q[i][s];
                                        q[i][L] = q[i][L] + val * q[s][L]
                                    }
                                }
                                q[0][m + 1] = 0.0
                            }
                        }
                        if (knownY.colCount === 1)
                        {
                            result = [];
                            for (i = 0; i < newX.rowCount; i++)
                            {
                                result[i] = [];
                                val = q[0][m + 1];
                                for (j = 0; j < m; j++)
                                {
                                    d = newX[(i, j)];
                                    val += q[j + 1][m + 1] * d
                                }
                                result[i][0] = Math_exp(val)
                            }
                            return new Calc._ConcreteArray(result)
                        }
                        else
                        {
                            result = [];
                            result[0] = [];
                            for (i = 0; i < newX.colCount; i++)
                            {
                                val = q[0][m + 1];
                                for (j = 0; j < m; j++)
                                {
                                    d = newX[j][i];
                                    val += q[j + 1][m + 1] * d
                                }
                                result[0][i] = Math_exp(val)
                            }
                            return new Calc._ConcreteArray(result)
                        }
                    }
                    return CalcErrorsNotAvailable
                }
                function st_forecast(args)
                {
                    var num;
                    if (isNaN(num = CalcConvert.D(args[0])))
                    {
                        return CalcErrorsValue
                    }
                    var y,
                        x,
                        sumy = 0.0,
                        sumx = 0.0,
                        sumx2 = 0.0,
                        sumxy = 0.0,
                        a,
                        b;
                    var array1 = CalcConvert.toArr(args[1], 1, true, true, false);
                    if (array1.isError)
                    {
                        return array1[0]
                    }
                    var array2 = CalcConvert.toArr(args[2], 1, true, true, false);
                    if (array2.isError)
                    {
                        return array2[0]
                    }
                    var n = array1.length;
                    if (n !== array2.length)
                    {
                        return CalcErrorsNotAvailable
                    }
                    var count = 0;
                    for (var i = 0; i < n; i++)
                    {
                        y = array1[i];
                        x = array2[i];
                        if (y !== CalcConvert.CalcConvertedError && x !== CalcConvert.CalcConvertedError)
                        {
                            sumy += y;
                            sumx += x;
                            sumx2 += x * x;
                            sumxy += x * y;
                            count++
                        }
                    }
                    if (count === 0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    if (count * sumx2 - sumx * sumx === 0.0)
                    {
                        return CalcErrorsDivideByZero
                    }
                    b = (count * sumxy - sumx * sumy) / (count * sumx2 - sumx * sumx);
                    a = (sumy / count) - b * (sumx / count);
                    return CalcConvert.toResult(a + b * num)
                }
                function st_average(args)
                {
                    return _StatHelper.__averageIncludeSubtotals(args, true, true)
                }
                function st_stdev(args)
                {
                    return _StatHelper.__stdevIncludeSubtotals(args, true, true)
                }
                function st_percentile(args)
                {
                    var k,
                        convert = Calc.Convert;
                    if (isNaN(k = CalcConvert.D(args[1])))
                    {
                        return CalcErrorsValue
                    }
                    var array = CalcConvert.toArr(args[0], 1, true, true, false);
                    if (array.isError)
                    {
                        return array[0]
                    }
                    if (array.isConvertError)
                    {
                        return CalcErrorsValue
                    }
                    var list = [];
                    for (var i = 0; i < array.length; i++)
                    {
                        var x = array[i];
                        if (x !== CalcConvert.CalcConvertedError)
                        {
                            list.push(x)
                        }
                    }
                    list.sort(function(x, y)
                    {
                        return x - y
                    });
                    if (list.length === 0)
                    {
                        return CalcErrorsNumber
                    }
                    if (k < 0 || 1 < k)
                    {
                        return CalcErrorsNumber
                    }
                    var index = k * (list.length - 1);
                    var rem = index % 1.0;
                    index = parseInt(index.toString(), 10);
                    if (rem === 0.0)
                    {
                        return list[index]
                    }
                    else
                    {
                        return CalcConvert.D(list[index]) + rem * (CalcConvert.D(list[index + 1]) - CalcConvert.D(list[index]))
                    }
                }
                _Functions.def("ABS", mt_abs, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ACOS", mt_acos, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ASIN", mt_asin, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ATAN", mt_atan, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ATAN2", mt_atan2, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("COS", mt_cos, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("CEILING", mt_ceiling, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("ODD", mt_odd, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("EVEN", mt_even, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("FLOOR", mt_floor, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("LN", mt_ln, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SQRT", mt_sqrt, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SIN", mt_sin, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("TAN", mt_tan, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SIGN", mt_sign, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("GCD", mt_gcd, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("LCM", mt_lcm, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("PRODUCT", mt_product, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("POWER", mt_power, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("MOD", mt_mod, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("QUOTIENT", mt_quotient, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("SUBTOTAL", mt_subtotal, {
                    minArgs: 2, acceptsReference: acceptsNotZero, acceptsArray: acceptsNotZero
                });
                _Functions.def("INT", mt_int, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("MROUND", mt_mround, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("ROUND", mt_round, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("ROUNDDOWN", mt_rounddown, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("ROUNDUP", mt_roundup, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("TRUNC", mt_trunc, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("EXP", mt_exp, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("LOG", mt_log, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("LOG10", mt_log10, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SUM", mt_sum, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("SUMIF", mt_sumif, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo, acceptsReference: acceptsZeroTwo, acceptsArray: acceptsZeroTwo
                });
                _Functions.def("SUMIFS", mt_sumifs, {
                    minArgs: 3, acceptsReference: acceptsZeroOdd, acceptsArray: acceptsZeroOdd
                });
                _Functions.def("SUMPRODUCT", mt_sumproduct, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny, arrayArgumentEvaluateMode: 1
                });
                _Functions.def("SUMSQ", mt_sumsq, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("SUMX2MY2", mt_sumx2my2, {
                    minArgs: 2, maxArgs: 2, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("SUMX2PY2", mt_sumx2py2, {
                    minArgs: 2, maxArgs: 2, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("SUMXMY2", mt_sumxmy2, {
                    minArgs: 2, maxArgs: 2, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("SERIESSUM", mt_seriessum, {
                    minArgs: 4, maxArgs: 4, acceptsReference: acceptsThree, acceptsArray: acceptsThree
                });
                _Functions.def("PI", mt_pi, {
                    minArgs: 0, maxArgs: 0
                });
                _Functions.def("SQRTPI", mt_sqrtpi, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("DEGREES", mt_degrees, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("RADIANS", mt_radians, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("COSH", mt_cosh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ACOSH", mt_acosh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SINH", mt_sinh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ASINH", mt_asinh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("TANH", mt_tanh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ATANH", mt_atanh, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("MDETERM", mt_mdeterm, {
                    minArgs: 1, maxArgs: 1, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("MINVERSE", mt_minverse, {
                    minArgs: 1, maxArgs: 1, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("MMULT", mt_mmult, {
                    minArgs: 2, maxArgs: 2, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("FACT", mt_fact, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("FACTDOUBLE", mt_factdouble, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("MULTINOMIAL", mt_multinomial, {
                    minArgs: 1, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("RAND", mt_rand, {
                    minArgs: 0, maxArgs: 0, isVolatile: isVolatile
                });
                _Functions.def("RANDBETWEEN", mt_randbetween, {
                    minArgs: 2, maxArgs: 2, isVolatile: isVolatile
                });
                _Functions.def("COMBIN", mt_combin, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("ROMAN", mt_roman, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("CEILING.PRECISE", mt_ceilingprecise, {
                    minArgs: 1, maxArgs: 2
                });
                _Functions.def("ISO.CEILING", mt_ceilingprecise, {
                    minArgs: 1, maxArgs: 2
                });
                _Functions.def("FLOOR.PRECISE", mt_floorprecise, {
                    minArgs: 1, maxArgs: 2
                });
                _Functions.def("AND", lg_and, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("OR", lg_or, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("NOT", lg_not, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("IF", lg_if, {
                    minArgs: 2, maxArgs: 3, acceptsReference: acceptsOneTwo, acceptsArray: acceptsOneTwo, acceptsError: acceptsOneTwo, acceptsMissingArgument: acceptsTwo, isBranch: isBranch, findTestArgument: findTestArgument, findBranchArgument: findBranchArgument
                });
                _Functions.def("IFERROR", lg_iferror, {
                    minArgs: 2, maxArgs: 2, acceptsReference: acceptsZero, acceptsError: acceptsZero
                });
                _Functions.def("TRUE", lg_true, {
                    minArgs: 0, maxArgs: 0
                });
                _Functions.def("FALSE", lg_false, {
                    minArgs: 0, maxArgs: 0
                });
                _Functions.def("DATE", dt_date, {
                    minArgs: 3, maxArgs: 3
                });
                _Functions.def("TIME", dt_time, {
                    minArgs: 3, maxArgs: 3
                });
                _Functions.def("DATEVALUE", dt_datevalue, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("TIMEVALUE", dt_timevalue, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("NOW", dt_now, {
                    minArgs: 0, maxArgs: 0, isVolatile: isVolatile
                });
                _Functions.def("TODAY", dt_today, {
                    minArgs: 0, maxArgs: 0, isVolatile: isVolatile
                });
                _Functions.def("HOUR", dt_hour, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("MINUTE", dt_minute, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("SECOND", dt_second, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("DAY", dt_day, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("MONTH", dt_month, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("YEAR", dt_year, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("WEEKNUM", dt_weeknum, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("WEEKDAY", dt_weekday, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("EDATE", dt_edate, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("EOMONTH", dt_eomonth, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("WORKDAY", dt_workday, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo, acceptsArray: acceptsTwo, acceptsReference: acceptsTwo
                });
                _Functions.def("WORKDAY.INTL", dt_workday_intl, {
                    minArgs: 2, maxArgs: 4, acceptsMissingArgument: acceptsTwoThree, acceptsArray: acceptsTwoThree, acceptsReference: acceptsTwoThree
                });
                _Functions.def("DAYS360", dt_days360, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo
                });
                _Functions.def("NETWORKDAYS", dt_networkdays, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo, acceptsArray: acceptsTwo, acceptsReference: acceptsTwo
                });
                _Functions.def("NETWORKDAYS.INTL", dt_networkdays_intl, {
                    minArgs: 2, maxArgs: 4, acceptsMissingArgument: acceptsTwoThree, acceptsArray: acceptsTwoThree, acceptsReference: acceptsTwoThree
                });
                _Functions.def("YEARFRAC", dt_yearfrac, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo
                });
                _Functions.def("DATEDIF", dt_datedif, {
                    minArgs: 3, maxArgs: 3
                });
                _Functions.def("CLEAN", tx_clean, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("TRIM", tx_trim, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("DOLLAR", tx_dollar, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("FIXED", tx_fixed, {
                    minArgs: 1, maxArgs: 3, acceptsMissingArgument: acceptsOneTwo
                });
                _Functions.def("TEXT", tx_text, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("VALUE", tx_value, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("LOWER", tx_lower, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("UPPER", tx_upper, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("CHAR", tx_char, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("CODE", tx_code, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("REPLACE", tx_replace, {
                    minArgs: 4, maxArgs: 4, acceptsMissingArgument: acceptsTwo
                });
                _Functions.def("SUBSTITUTE", tx_substitute, {
                    minArgs: 3, maxArgs: 4, acceptsMissingArgument: acceptsThree
                });
                _Functions.def("CONCATENATE", tx_concatenate, {
                    minArgs: 2, acceptsArray: acceptsAny
                });
                _Functions.def("LEFT", tx_left, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("MID", tx_mid, {
                    minArgs: 3, maxArgs: 3
                });
                _Functions.def("RIGHT", tx_right, {
                    minArgs: 1, maxArgs: 2, acceptsMissingArgument: acceptsOne
                });
                _Functions.def("REPT", tx_rept, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("LEN", tx_len, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("FIND", tx_find, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo
                });
                _Functions.def("SEARCH", tx_search, {
                    minArgs: 2, maxArgs: 3, acceptsMissingArgument: acceptsTwo
                });
                _Functions.def("EXACT", tx_exact, {
                    minArgs: 2, maxArgs: 2
                });
                _Functions.def("T", tx_t, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ISERROR", in_isError, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISERR", in_isErr, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISNA", in_isNA, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ERROR.TYPE", in_error_Type, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISNUMBER", in_isNumber, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISEVEN", in_isEven, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ISODD", in_isOdd, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("N", in_number, {
                    minArgs: 1, maxArgs: 1
                });
                _Functions.def("ISBLANK", in_isBlank, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISLOGICAL", in_isLogical, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISTEXT", in_isText, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISNONTEXT", in_isNonText, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny
                });
                _Functions.def("ISREF", in_isRef, {
                    minArgs: 1, maxArgs: 1, acceptsError: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("TYPE", in_type, {
                    minArgs: 1, maxArgs: 1, acceptsArray: acceptsAny, acceptsError: acceptsAny
                });
                _Functions.def("NA", in_na, {
                    minArgs: 0, maxArgs: 0
                });
                _Functions.def("TREND", st_trend, {
                    minArgs: 1, maxArgs: 4, acceptsReference: acceptsFirstOrSecondOrThird, acceptsArray: acceptsFirstOrSecondOrThird, acceptsMissingArgument: acceptsSecondOrThirdOrFourth
                });
                _Functions.def("GROWTH", st_growth, {
                    minArgs: 1, maxArgs: 4, acceptsReference: acceptsNotFourth, acceptsArray: acceptsNotFourth, acceptsMissingArgument: acceptsSecondOrThirdOrFourth
                });
                _Functions.def("FORECAST", st_forecast, {
                    minArgs: 3, maxArgs: 3, acceptsArray: acceptAboveZero, acceptsReference: acceptAboveZero
                });
                _Functions.def("AVERAGE", st_average, {
                    minArgs: 1, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("STDEV", st_stdev, {
                    minArgs: 1, acceptsArray: acceptsAny, acceptsReference: acceptsAny
                });
                _Functions.def("STDEV.S", st_stdev, {
                    minArgs: 1, acceptsReference: acceptsAny, acceptsArray: acceptsAny
                });
                _Functions.def("PERCENTILE", st_percentile, {
                    minArgs: 2, maxArgs: 2, acceptsArray: acceptsFirst, acceptsReference: acceptsFirst
                });
                _Functions.def("PERCENTILE.INC", st_percentile, {
                    minArgs: 2, maxArgs: 2, acceptsReference: acceptsFirst, acceptArray: acceptsFirst
                })
            })(Calc.Functions || (Calc.Functions = {}));
            var Functions = Calc.Functions
        })(Sheets.Calc || (Sheets.Calc = {}));
        var Calc = Sheets.Calc
    })(GcSpread.Sheets || (GcSpread.Sheets = {}));
    var Sheets = GcSpread.Sheets
})(GcSpread || (GcSpread = {}))

